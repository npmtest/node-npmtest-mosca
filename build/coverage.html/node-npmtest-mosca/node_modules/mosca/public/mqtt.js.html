<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-mosca/node_modules/mosca/public/mqtt.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-mosca">npmtest-mosca (v0.0.2)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-mosca/node_modules/mosca/public/mqtt.js</span></h1>
    <h2>
        
        Statements: <span class="metric">16.91% <small>(1094 / 6470)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">3.2% <small>(130 / 4057)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">16.5% <small>(135 / 818)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(7 / 7)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-mosca/node_modules/mosca/public/</a> &#187; mqtt.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9</td><td class="line-coverage"><span class="cline-any cline-yes">262590</span>
<span class="cline-any cline-yes">48</span>
<span class="cline-any cline-yes">40</span>
<span class="cline-any cline-yes">131072</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">6</span>
<span class="cline-any cline-yes">4</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">(function(f){<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof exports==="object"&amp;&amp;typeof module!=="undefined"){module.exports=f()}else <span class="cstat-no" title="statement not covered" >if(typeof define==="function"&amp;&amp;define.amd){<span class="cstat-no" title="statement not covered" >define([],f)}</span>else{<span class="cstat-no" title="statement not covered" >var g;<span class="cstat-no" title="statement not covered" >i</span>f(typeof window!=="undefined"){<span class="cstat-no" title="statement not covered" >g=window}</span>else <span class="cstat-no" title="statement not covered" >if(typeof global!=="undefined"){<span class="cstat-no" title="statement not covered" >g=global}</span>else <span class="cstat-no" title="statement not covered" >if(typeof self!=="undefined"){<span class="cstat-no" title="statement not covered" >g=self}</span>else{<span class="cstat-no" title="statement not covered" >g=this}<span class="cstat-no" title="statement not covered" ></span>g</span></span></span>.mqtt=f()}</span>}</span>)(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&amp;&amp;require;<span class="missing-if-branch" title="else path not taken" >E</span>if(!u&amp;&amp;a)return a(o,!0);<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >return i(o,!0);<span class="cstat-no" title="statement not covered" >v</span></span>ar f=new Error("Cannot find module '"+o+"'");<span class="cstat-no" title="statement not covered" >t</span>hrow f.code="MODULE_NOT_FOUND",f}</span>var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)<span class="cstat-no" title="statement not covered" >s(r[o]);r</span>eturn s}({1:[function(require,module,exports){"use strict";exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=="undefined"?Uint8Array:<span class="branch-1 cbranch-no" title="branch not covered" >Array;</span>var code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var i=0,len=code.length;i&lt;len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i}revLookup["-".charCodeAt(0)]=62;revLookup["_".charCodeAt(0)]=63;<span class="fstat-no" title="function not covered" >function placeHoldersCount(b64){<span class="cstat-no" title="statement not covered" ></span>var len=b64.length;<span class="cstat-no" title="statement not covered" >i</span>f(len%4&gt;0){<span class="cstat-no" title="statement not covered" >throw new Error("Invalid string. Length must be a multiple of 4")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b64[len-2]==="="?2:b64[len-1]==="="?1:0}<span class="fstat-no" title="function not covered" ></span>function byteLength(b64){<span class="cstat-no" title="statement not covered" ></span>return b64.length*3/4-placeHoldersCount(b64)}<span class="fstat-no" title="function not covered" ></span>function toByteArray(b64){<span class="cstat-no" title="statement not covered" ></span>var i,j,l,tmp,placeHolders,arr;<span class="cstat-no" title="statement not covered" >v</span>ar len=b64.length;<span class="cstat-no" title="statement not covered" >p</span>laceHolders=placeHoldersCount(b64);<span class="cstat-no" title="statement not covered" >a</span>rr=new Arr(len*3/4-placeHolders);<span class="cstat-no" title="statement not covered" >l</span>=placeHolders&gt;0?len-4:len;<span class="cstat-no" title="statement not covered" >v</span>ar L=0;<span class="cstat-no" title="statement not covered" >f</span>or(i=0,j=0;i&lt;l;i+=4,j+=3){<span class="cstat-no" title="statement not covered" >tmp=revLookup[b64.charCodeAt(i)]&lt;&lt;18|revLookup[b64.charCodeAt(i+1)]&lt;&lt;12|revLookup[b64.charCodeAt(i+2)]&lt;&lt;6|revLookup[b64.charCodeAt(i+3)];<span class="cstat-no" title="statement not covered" >a</span>rr[L++]=tmp&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >a</span>rr[L++]=tmp&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >a</span>rr[L++]=tmp&amp;255}<span class="cstat-no" title="statement not covered" ></span>i</span>f(placeHolders===2){<span class="cstat-no" title="statement not covered" >tmp=revLookup[b64.charCodeAt(i)]&lt;&lt;2|revLookup[b64.charCodeAt(i+1)]&gt;&gt;4;<span class="cstat-no" title="statement not covered" >a</span>rr[L++]=tmp&amp;255}</span>else <span class="cstat-no" title="statement not covered" >if(placeHolders===1){<span class="cstat-no" title="statement not covered" >tmp=revLookup[b64.charCodeAt(i)]&lt;&lt;10|revLookup[b64.charCodeAt(i+1)]&lt;&lt;4|revLookup[b64.charCodeAt(i+2)]&gt;&gt;2;<span class="cstat-no" title="statement not covered" >a</span>rr[L++]=tmp&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >a</span>rr[L++]=tmp&amp;255}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn arr}<span class="fstat-no" title="function not covered" ></span>function tripletToBase64(num){<span class="cstat-no" title="statement not covered" ></span>return lookup[num&gt;&gt;18&amp;63]+lookup[num&gt;&gt;12&amp;63]+lookup[num&gt;&gt;6&amp;63]+lookup[num&amp;63]}<span class="fstat-no" title="function not covered" ></span>function encodeChunk(uint8,start,end){<span class="cstat-no" title="statement not covered" ></span>var tmp;<span class="cstat-no" title="statement not covered" >v</span>ar output=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=start;i&lt;end;i+=3){<span class="cstat-no" title="statement not covered" >tmp=(uint8[i]&lt;&lt;16)+(uint8[i+1]&lt;&lt;8)+uint8[i+2];<span class="cstat-no" title="statement not covered" >o</span>utput.push(tripletToBase64(tmp))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn output.join("")}<span class="fstat-no" title="function not covered" ></span>function fromByteArray(uint8){<span class="cstat-no" title="statement not covered" ></span>var tmp;<span class="cstat-no" title="statement not covered" >v</span>ar len=uint8.length;<span class="cstat-no" title="statement not covered" >v</span>ar extraBytes=len%3;<span class="cstat-no" title="statement not covered" >v</span>ar output="";<span class="cstat-no" title="statement not covered" >v</span>ar parts=[];<span class="cstat-no" title="statement not covered" >v</span>ar maxChunkLength=16383;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,len2=len-extraBytes;i&lt;len2;i+=maxChunkLength){<span class="cstat-no" title="statement not covered" >parts.push(encodeChunk(uint8,i,i+maxChunkLength&gt;len2?len2:i+maxChunkLength))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(extraBytes===1){<span class="cstat-no" title="statement not covered" >tmp=uint8[len-1];<span class="cstat-no" title="statement not covered" >o</span>utput+=lookup[tmp&gt;&gt;2];<span class="cstat-no" title="statement not covered" >o</span>utput+=lookup[tmp&lt;&lt;4&amp;63];<span class="cstat-no" title="statement not covered" >o</span>utput+="=="}</span>else <span class="cstat-no" title="statement not covered" >if(extraBytes===2){<span class="cstat-no" title="statement not covered" >tmp=(uint8[len-2]&lt;&lt;8)+uint8[len-1];<span class="cstat-no" title="statement not covered" >o</span>utput+=lookup[tmp&gt;&gt;10];<span class="cstat-no" title="statement not covered" >o</span>utput+=lookup[tmp&gt;&gt;4&amp;63];<span class="cstat-no" title="statement not covered" >o</span>utput+=lookup[tmp&lt;&lt;2&amp;63];<span class="cstat-no" title="statement not covered" >o</span>utput+="="}<span class="cstat-no" title="statement not covered" ></span>p</span></span>arts.push(output);<span class="cstat-no" title="statement not covered" >r</span>eturn parts.join("")}</span>},{}],2:[function(require,module,exports){},{}],3:[function(require,module,exports){(function(global){"use strict";var buffer=require("buffer");var Buffer=buffer.Buffer;var SlowBuffer=buffer.SlowBuffer;var MAX_LEN=buffer.kMaxLength||<span class="branch-1 cbranch-no" title="branch not covered" >2147483647;</span>exports.alloc=<span class="fstat-no" title="function not covered" >function alloc(size,fill,encoding){<span class="cstat-no" title="statement not covered" ></span>if(typeof Buffer.alloc==="function"){<span class="cstat-no" title="statement not covered" >return Buffer.alloc(size,fill,encoding)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof encoding==="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError("encoding must not be number")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof size!=="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError("size must be a number")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(size&gt;MAX_LEN){<span class="cstat-no" title="statement not covered" >throw new RangeError("size is too large")}<span class="cstat-no" title="statement not covered" ></span>v</span>ar enc=encoding;<span class="cstat-no" title="statement not covered" >v</span>ar _fill=fill;<span class="cstat-no" title="statement not covered" >i</span>f(_fill===undefined){<span class="cstat-no" title="statement not covered" >enc=undefined;<span class="cstat-no" title="statement not covered" >_</span>fill=0}<span class="cstat-no" title="statement not covered" ></span>v</span>ar buf=new Buffer(size);<span class="cstat-no" title="statement not covered" >i</span>f(typeof _fill==="string"){<span class="cstat-no" title="statement not covered" >var fillBuf=new Buffer(_fill,enc);<span class="cstat-no" title="statement not covered" >v</span>ar flen=fillBuf.length;<span class="cstat-no" title="statement not covered" >v</span>ar i=-1;<span class="cstat-no" title="statement not covered" >w</span>hile(++i&lt;size){<span class="cstat-no" title="statement not covered" >buf[i]=fillBuf[i%flen]}</span>}</span>else{<span class="cstat-no" title="statement not covered" >buf.fill(_fill)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn buf}</span>;exports.allocUnsafe=<span class="fstat-no" title="function not covered" >function allocUnsafe(size){<span class="cstat-no" title="statement not covered" ></span>if(typeof Buffer.allocUnsafe==="function"){<span class="cstat-no" title="statement not covered" >return Buffer.allocUnsafe(size)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof size!=="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError("size must be a number")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(size&gt;MAX_LEN){<span class="cstat-no" title="statement not covered" >throw new RangeError("size is too large")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Buffer(size)}</span>;exports.from=<span class="fstat-no" title="function not covered" >function from(value,encodingOrOffset,length){<span class="cstat-no" title="statement not covered" ></span>if(typeof Buffer.from==="function"&amp;&amp;(!global.Uint8Array||Uint8Array.from!==Buffer.from)){<span class="cstat-no" title="statement not covered" >return Buffer.from(value,encodingOrOffset,length)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof value==="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError('"value" argument must not be a number')}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof value==="string"){<span class="cstat-no" title="statement not covered" >return new Buffer(value,encodingOrOffset)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof ArrayBuffer!=="undefined"&amp;&amp;value instanceof ArrayBuffer){<span class="cstat-no" title="statement not covered" >var offset=encodingOrOffset;<span class="cstat-no" title="statement not covered" >i</span>f(arguments.length===1){<span class="cstat-no" title="statement not covered" >return new Buffer(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof offset==="undefined"){<span class="cstat-no" title="statement not covered" >offset=0}<span class="cstat-no" title="statement not covered" ></span>v</span>ar len=length;<span class="cstat-no" title="statement not covered" >i</span>f(typeof len==="undefined"){<span class="cstat-no" title="statement not covered" >len=value.byteLength-offset}<span class="cstat-no" title="statement not covered" ></span>i</span>f(offset&gt;=value.byteLength){<span class="cstat-no" title="statement not covered" >throw new RangeError("'offset' is out of bounds")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(len&gt;value.byteLength-offset){<span class="cstat-no" title="statement not covered" >throw new RangeError("'length' is out of bounds")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Buffer(value.slice(offset,offset+len))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Buffer.isBuffer(value)){<span class="cstat-no" title="statement not covered" >var out=new Buffer(value.length);<span class="cstat-no" title="statement not covered" >v</span>alue.copy(out,0,0,value.length);<span class="cstat-no" title="statement not covered" >r</span>eturn out}<span class="cstat-no" title="statement not covered" ></span>i</span>f(value){<span class="cstat-no" title="statement not covered" >if(Array.isArray(value)||typeof ArrayBuffer!=="undefined"&amp;&amp;value.buffer instanceof ArrayBuffer||"length"in value){<span class="cstat-no" title="statement not covered" >return new Buffer(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(value.type==="Buffer"&amp;&amp;Array.isArray(value.data)){<span class="cstat-no" title="statement not covered" >return new Buffer(value.data)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new TypeError("First argument must be a string, Buffer, "+"ArrayBuffer, Array, or array-like object.")}</span>;exports.allocUnsafeSlow=<span class="fstat-no" title="function not covered" >function allocUnsafeSlow(size){<span class="cstat-no" title="statement not covered" ></span>if(typeof Buffer.allocUnsafeSlow==="function"){<span class="cstat-no" title="statement not covered" >return Buffer.allocUnsafeSlow(size)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof size!=="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError("size must be a number")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(size&gt;=MAX_LEN){<span class="cstat-no" title="statement not covered" >throw new RangeError("size is too large")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new SlowBuffer(size)}</span>}).call(this,typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})</span>},{buffer:4}],4:[function(require,module,exports){(function(global){"use strict";var base64=require("base64-js");var ieee754=require("ieee754");var isArray=require("isarray");exports.Buffer=Buffer;exports.SlowBuffer=SlowBuffer;exports.INSPECT_MAX_BYTES=50;Buffer.TYPED_ARRAY_SUPPORT=global.TYPED_ARRAY_SUPPORT!==undefined?<span class="branch-0 cbranch-no" title="branch not covered" >global.TYPED_ARRAY_SUPPORT:</span>typedArraySupport();exports.kMaxLength=kMaxLength();function typedArraySupport(){try{var arr=new Uint8Array(1);arr.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}};return arr.foo()===42&amp;&amp;typeof arr.subarray==="function"&amp;&amp;arr.subarray(1,1).byteLength===0}catch(e){<span class="cstat-no" title="statement not covered" >return false}</span>}function kMaxLength(){return Buffer.TYPED_ARRAY_SUPPORT?2147483647:<span class="branch-1 cbranch-no" title="branch not covered" >1073741823}</span>function createBuffer(that,length){<span class="missing-if-branch" title="if path not taken" >I</span>if(kMaxLength()&lt;length){<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid typed array length")}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(Buffer.TYPED_ARRAY_SUPPORT){that=new Uint8Array(length);that.__proto__=Buffer.prototype}else{<span class="cstat-no" title="statement not covered" >if(that===null){<span class="cstat-no" title="statement not covered" >that=new Buffer(length)}<span class="cstat-no" title="statement not covered" ></span>t</span>hat.length=length}</span>return that}function Buffer(arg,encodingOrOffset,length){<span class="missing-if-branch" title="if path not taken" >I</span>if(!Buffer.TYPED_ARRAY_SUPPORT&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!(this instanceof Buffer))</span>{<span class="cstat-no" title="statement not covered" >return new Buffer(arg,encodingOrOffset,length)}</span>if(typeof arg==="number"){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof encodingOrOffset==="string"){<span class="cstat-no" title="statement not covered" >throw new Error("If encoding is specified then the first argument must be a string")}</span>return allocUnsafe(this,arg)}return from(this,arg,encodingOrOffset,length)}Buffer.poolSize=8192;Buffer._augment=<span class="fstat-no" title="function not covered" >function(arr){<span class="cstat-no" title="statement not covered" ></span>arr.__proto__=Buffer.prototype;<span class="cstat-no" title="statement not covered" >r</span>eturn arr}</span>;function from(that,value,encodingOrOffset,length){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof value==="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError('"value" argument must not be a number')}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(typeof ArrayBuffer!=="undefined"&amp;&amp;value instanceof ArrayBuffer){<span class="cstat-no" title="statement not covered" >return fromArrayBuffer(that,value,encodingOrOffset,length)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(typeof value==="string"){<span class="cstat-no" title="statement not covered" >return fromString(that,value,encodingOrOffset)}</span>return fromObject(that,value)}Buffer.from=<span class="fstat-no" title="function not covered" >function(value,encodingOrOffset,length){<span class="cstat-no" title="statement not covered" ></span>return from(null,value,encodingOrOffset,length)}</span>;<span class="missing-if-branch" title="else path not taken" >E</span>if(Buffer.TYPED_ARRAY_SUPPORT){Buffer.prototype.__proto__=Uint8Array.prototype;Buffer.__proto__=Uint8Array;<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof Symbol!=="undefined"&amp;&amp;Symbol.species&amp;&amp;Buffer[Symbol.species]===Buffer){Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:true})}}function assertSize(size){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof size!=="number"){<span class="cstat-no" title="statement not covered" >throw new TypeError('"size" argument must be a number')}</span>else <span class="missing-if-branch" title="if path not taken" >I</span>if(size&lt;0){<span class="cstat-no" title="statement not covered" >throw new RangeError('"size" argument must not be negative')}</span>}<span class="fstat-no" title="function not covered" >function alloc(that,size,fill,encoding){<span class="cstat-no" title="statement not covered" ></span>assertSize(size);<span class="cstat-no" title="statement not covered" >i</span>f(size&lt;=0){<span class="cstat-no" title="statement not covered" >return createBuffer(that,size)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(fill!==undefined){<span class="cstat-no" title="statement not covered" >return typeof encoding==="string"?createBuffer(that,size).fill(fill,encoding):createBuffer(that,size).fill(fill)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn createBuffer(that,size)}</span>Buffer.alloc=<span class="fstat-no" title="function not covered" >function(size,fill,encoding){<span class="cstat-no" title="statement not covered" ></span>return alloc(null,size,fill,encoding)}</span>;function allocUnsafe(that,size){assertSize(size);that=createBuffer(that,size&lt;0?<span class="branch-0 cbranch-no" title="branch not covered" >0:</span>checked(size)|0);<span class="missing-if-branch" title="if path not taken" >I</span>if(!Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;size;++i){<span class="cstat-no" title="statement not covered" >that[i]=0}</span>}</span>return that}Buffer.allocUnsafe=<span class="fstat-no" title="function not covered" >function(size){<span class="cstat-no" title="statement not covered" ></span>return allocUnsafe(null,size)}</span>;Buffer.allocUnsafeSlow=<span class="fstat-no" title="function not covered" >function(size){<span class="cstat-no" title="statement not covered" ></span>return allocUnsafe(null,size)}</span>;<span class="fstat-no" title="function not covered" >function fromString(that,string,encoding){<span class="cstat-no" title="statement not covered" ></span>if(typeof encoding!=="string"||encoding===""){<span class="cstat-no" title="statement not covered" >encoding="utf8"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Buffer.isEncoding(encoding)){<span class="cstat-no" title="statement not covered" >throw new TypeError('"encoding" must be a valid string encoding')}<span class="cstat-no" title="statement not covered" ></span>v</span>ar length=byteLength(string,encoding)|0;<span class="cstat-no" title="statement not covered" >t</span>hat=createBuffer(that,length);<span class="cstat-no" title="statement not covered" >v</span>ar actual=that.write(string,encoding);<span class="cstat-no" title="statement not covered" >i</span>f(actual!==length){<span class="cstat-no" title="statement not covered" >that=that.slice(0,actual)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn that}</span>function fromArrayLike(that,array){var length=array.length&lt;0?<span class="branch-0 cbranch-no" title="branch not covered" >0:</span>checked(array.length)|0;that=createBuffer(that,length);for(var i=0;i&lt;length;i+=1){that[i]=array[i]&amp;255}return that}<span class="fstat-no" title="function not covered" >function fromArrayBuffer(that,array,byteOffset,length){<span class="cstat-no" title="statement not covered" ></span>array.byteLength;<span class="cstat-no" title="statement not covered" >i</span>f(byteOffset&lt;0||array.byteLength&lt;byteOffset){<span class="cstat-no" title="statement not covered" >throw new RangeError("'offset' is out of bounds")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(array.byteLength&lt;byteOffset+(length||0)){<span class="cstat-no" title="statement not covered" >throw new RangeError("'length' is out of bounds")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(byteOffset===undefined&amp;&amp;length===undefined){<span class="cstat-no" title="statement not covered" >array=new Uint8Array(array)}</span>else <span class="cstat-no" title="statement not covered" >if(length===undefined){<span class="cstat-no" title="statement not covered" >array=new Uint8Array(array,byteOffset)}</span>else{<span class="cstat-no" title="statement not covered" >array=new Uint8Array(array,byteOffset,length)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >that=array;<span class="cstat-no" title="statement not covered" >t</span>hat.__proto__=Buffer.prototype}</span>else{<span class="cstat-no" title="statement not covered" >that=fromArrayLike(that,array)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn that}</span>function fromObject(that,obj){<span class="missing-if-branch" title="if path not taken" >I</span>if(Buffer.isBuffer(obj)){<span class="cstat-no" title="statement not covered" >var len=checked(obj.length)|0;<span class="cstat-no" title="statement not covered" >t</span>hat=createBuffer(that,len);<span class="cstat-no" title="statement not covered" >i</span>f(that.length===0){<span class="cstat-no" title="statement not covered" >return that}<span class="cstat-no" title="statement not covered" ></span>o</span>bj.copy(that,0,0,len);<span class="cstat-no" title="statement not covered" >r</span>eturn that}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(obj){<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof ArrayBuffer!=="undefined"&amp;&amp;obj.buffer instanceof ArrayBuffer||"length"in obj){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof obj.length!=="number"||isnan(obj.length)){<span class="cstat-no" title="statement not covered" >return createBuffer(that,0)}</span>return fromArrayLike(that,obj)}<span class="cstat-no" title="statement not covered" >if(obj.type==="Buffer"&amp;&amp;isArray(obj.data)){<span class="cstat-no" title="statement not covered" >return fromArrayLike(that,obj.data)}</span>}<span class="cstat-no" title="statement not covered" ></span>throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}</span>function checked(length){<span class="missing-if-branch" title="if path not taken" >I</span>if(length&gt;=kMaxLength()){<span class="cstat-no" title="statement not covered" >throw new RangeError("Attempt to allocate Buffer larger than maximum "+"size: 0x"+kMaxLength().toString(16)+" bytes")}</span>return length|0}<span class="fstat-no" title="function not covered" >function SlowBuffer(length){<span class="cstat-no" title="statement not covered" ></span>if(+length!=length){<span class="cstat-no" title="statement not covered" >length=0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Buffer.alloc(+length)}</span>Buffer.isBuffer=function isBuffer(b){return!!(b!=null&amp;&amp;b._isBuffer)};Buffer.compare=<span class="fstat-no" title="function not covered" >function compare(a,b){<span class="cstat-no" title="statement not covered" ></span>if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Arguments must be Buffers")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a===b)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >v</span></span>ar x=a.length;<span class="cstat-no" title="statement not covered" >v</span>ar y=b.length;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,len=Math.min(x,y);i&lt;len;++i){<span class="cstat-no" title="statement not covered" >if(a[i]!==b[i]){<span class="cstat-no" title="statement not covered" >x=a[i];<span class="cstat-no" title="statement not covered" >y</span>=b[i];<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x&lt;y)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(y&lt;x)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0}</span>;Buffer.isEncoding=<span class="fstat-no" title="function not covered" >function isEncoding(encoding){<span class="cstat-no" title="statement not covered" ></span>switch(String(encoding).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return true;d</span>efault:<span class="cstat-no" title="statement not covered" >return false}</span>}</span>;Buffer.concat=<span class="fstat-no" title="function not covered" >function concat(list,length){<span class="cstat-no" title="statement not covered" ></span>if(!isArray(list)){<span class="cstat-no" title="statement not covered" >throw new TypeError('"list" argument must be an Array of Buffers')}<span class="cstat-no" title="statement not covered" ></span>i</span>f(list.length===0){<span class="cstat-no" title="statement not covered" >return Buffer.alloc(0)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar i;<span class="cstat-no" title="statement not covered" >i</span>f(length===undefined){<span class="cstat-no" title="statement not covered" >length=0;<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;list.length;++i){<span class="cstat-no" title="statement not covered" >length+=list[i].length}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar buffer=Buffer.allocUnsafe(length);<span class="cstat-no" title="statement not covered" >v</span>ar pos=0;<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;list.length;++i){<span class="cstat-no" title="statement not covered" >var buf=list[i];<span class="cstat-no" title="statement not covered" >i</span>f(!Buffer.isBuffer(buf)){<span class="cstat-no" title="statement not covered" >throw new TypeError('"list" argument must be an Array of Buffers')}<span class="cstat-no" title="statement not covered" ></span>b</span>uf.copy(buffer,pos);<span class="cstat-no" title="statement not covered" >p</span>os+=buf.length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn buffer}</span>;<span class="fstat-no" title="function not covered" >function byteLength(string,encoding){<span class="cstat-no" title="statement not covered" ></span>if(Buffer.isBuffer(string)){<span class="cstat-no" title="statement not covered" >return string.length}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof ArrayBuffer!=="undefined"&amp;&amp;typeof ArrayBuffer.isView==="function"&amp;&amp;(ArrayBuffer.isView(string)||string instanceof ArrayBuffer)){<span class="cstat-no" title="statement not covered" >return string.byteLength}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof string!=="string"){<span class="cstat-no" title="statement not covered" >string=""+string}<span class="cstat-no" title="statement not covered" ></span>v</span>ar len=string.length;<span class="cstat-no" title="statement not covered" >i</span>f(len===0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >v</span></span>ar loweredCase=false;<span class="cstat-no" title="statement not covered" >f</span>or(;;){<span class="cstat-no" title="statement not covered" >switch(encoding){case"ascii":case"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return len;c</span>ase"utf8":case"utf-8":case undefined:<span class="cstat-no" title="statement not covered" >return utf8ToBytes(string).length;c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return len*2;c</span>ase"hex":<span class="cstat-no" title="statement not covered" >return len&gt;&gt;&gt;1;c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return base64ToBytes(string).length;d</span>efault:<span class="cstat-no" title="statement not covered" >if(loweredCase)<span class="cstat-no" title="statement not covered" >return utf8ToBytes(string).length;<span class="cstat-no" title="statement not covered" >e</span></span>ncoding=(""+encoding).toLowerCase();<span class="cstat-no" title="statement not covered" >l</span>oweredCase=true}</span>}</span>}</span>Buffer.byteLength=byteLength;<span class="fstat-no" title="function not covered" >function slowToString(encoding,start,end){<span class="cstat-no" title="statement not covered" ></span>var loweredCase=false;<span class="cstat-no" title="statement not covered" >i</span>f(start===undefined||start&lt;0){<span class="cstat-no" title="statement not covered" >start=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(start&gt;this.length){<span class="cstat-no" title="statement not covered" >return""}<span class="cstat-no" title="statement not covered" ></span>i</span>f(end===undefined||end&gt;this.length){<span class="cstat-no" title="statement not covered" >end=this.length}<span class="cstat-no" title="statement not covered" ></span>i</span>f(end&lt;=0){<span class="cstat-no" title="statement not covered" >return""}<span class="cstat-no" title="statement not covered" ></span>e</span>nd&gt;&gt;&gt;=0;<span class="cstat-no" title="statement not covered" >s</span>tart&gt;&gt;&gt;=0;<span class="cstat-no" title="statement not covered" >i</span>f(end&lt;=start){<span class="cstat-no" title="statement not covered" >return""}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!encoding)<span class="cstat-no" title="statement not covered" >encoding="utf8";<span class="cstat-no" title="statement not covered" >w</span></span>hile(true){<span class="cstat-no" title="statement not covered" >switch(encoding){case"hex":<span class="cstat-no" title="statement not covered" >return hexSlice(this,start,end);c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return utf8Slice(this,start,end);c</span>ase"ascii":<span class="cstat-no" title="statement not covered" >return asciiSlice(this,start,end);c</span>ase"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return latin1Slice(this,start,end);c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return base64Slice(this,start,end);c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return utf16leSlice(this,start,end);d</span>efault:<span class="cstat-no" title="statement not covered" >if(loweredCase)<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+encoding);<span class="cstat-no" title="statement not covered" >e</span></span>ncoding=(encoding+"").toLowerCase();<span class="cstat-no" title="statement not covered" >l</span>oweredCase=true}</span>}</span>}</span>Buffer.prototype._isBuffer=true;<span class="fstat-no" title="function not covered" >function swap(b,n,m){<span class="cstat-no" title="statement not covered" ></span>var i=b[n];<span class="cstat-no" title="statement not covered" >b</span>[n]=b[m];<span class="cstat-no" title="statement not covered" >b</span>[m]=i}</span>Buffer.prototype.swap16=<span class="fstat-no" title="function not covered" >function swap16(){<span class="cstat-no" title="statement not covered" ></span>var len=this.length;<span class="cstat-no" title="statement not covered" >i</span>f(len%2!==0){<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 16-bits")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;len;i+=2){<span class="cstat-no" title="statement not covered" >swap(this,i,i+1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;Buffer.prototype.swap32=<span class="fstat-no" title="function not covered" >function swap32(){<span class="cstat-no" title="statement not covered" ></span>var len=this.length;<span class="cstat-no" title="statement not covered" >i</span>f(len%4!==0){<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 32-bits")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;len;i+=4){<span class="cstat-no" title="statement not covered" >swap(this,i,i+3);<span class="cstat-no" title="statement not covered" >s</span>wap(this,i+1,i+2)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;Buffer.prototype.swap64=<span class="fstat-no" title="function not covered" >function swap64(){<span class="cstat-no" title="statement not covered" ></span>var len=this.length;<span class="cstat-no" title="statement not covered" >i</span>f(len%8!==0){<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 64-bits")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;len;i+=8){<span class="cstat-no" title="statement not covered" >swap(this,i,i+7);<span class="cstat-no" title="statement not covered" >s</span>wap(this,i+1,i+6);<span class="cstat-no" title="statement not covered" >s</span>wap(this,i+2,i+5);<span class="cstat-no" title="statement not covered" >s</span>wap(this,i+3,i+4)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;Buffer.prototype.toString=<span class="fstat-no" title="function not covered" >function toString(){<span class="cstat-no" title="statement not covered" ></span>var length=this.length|0;<span class="cstat-no" title="statement not covered" >i</span>f(length===0)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >i</span></span>f(arguments.length===0)<span class="cstat-no" title="statement not covered" >return utf8Slice(this,0,length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn slowToString.apply(this,arguments)}</span>;Buffer.prototype.equals=<span class="fstat-no" title="function not covered" >function equals(b){<span class="cstat-no" title="statement not covered" ></span>if(!Buffer.isBuffer(b))<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument must be a Buffer");<span class="cstat-no" title="statement not covered" >i</span></span>f(this===b)<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Buffer.compare(this,b)===0}</span>;Buffer.prototype.inspect=<span class="fstat-no" title="function not covered" >function inspect(){<span class="cstat-no" title="statement not covered" ></span>var str="";<span class="cstat-no" title="statement not covered" >v</span>ar max=exports.INSPECT_MAX_BYTES;<span class="cstat-no" title="statement not covered" >i</span>f(this.length&gt;0){<span class="cstat-no" title="statement not covered" >str=this.toString("hex",0,max).match(/.{2}/g).join(" ");<span class="cstat-no" title="statement not covered" >i</span>f(this.length&gt;max)<span class="cstat-no" title="statement not covered" >str+=" ... "}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn"&lt;Buffer "+str+"&gt;"}</span>;Buffer.prototype.compare=<span class="fstat-no" title="function not covered" >function compare(target,start,end,thisStart,thisEnd){<span class="cstat-no" title="statement not covered" ></span>if(!Buffer.isBuffer(target)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument must be a Buffer")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(start===undefined){<span class="cstat-no" title="statement not covered" >start=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(end===undefined){<span class="cstat-no" title="statement not covered" >end=target?target.length:0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(thisStart===undefined){<span class="cstat-no" title="statement not covered" >thisStart=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(thisEnd===undefined){<span class="cstat-no" title="statement not covered" >thisEnd=this.length}<span class="cstat-no" title="statement not covered" ></span>i</span>f(start&lt;0||end&gt;target.length||thisStart&lt;0||thisEnd&gt;this.length){<span class="cstat-no" title="statement not covered" >throw new RangeError("out of range index")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(thisStart&gt;=thisEnd&amp;&amp;start&gt;=end){<span class="cstat-no" title="statement not covered" >return 0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(thisStart&gt;=thisEnd){<span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(start&gt;=end){<span class="cstat-no" title="statement not covered" >return 1}<span class="cstat-no" title="statement not covered" ></span>s</span>tart&gt;&gt;&gt;=0;<span class="cstat-no" title="statement not covered" >e</span>nd&gt;&gt;&gt;=0;<span class="cstat-no" title="statement not covered" >t</span>hisStart&gt;&gt;&gt;=0;<span class="cstat-no" title="statement not covered" >t</span>hisEnd&gt;&gt;&gt;=0;<span class="cstat-no" title="statement not covered" >i</span>f(this===target)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >v</span></span>ar x=thisEnd-thisStart;<span class="cstat-no" title="statement not covered" >v</span>ar y=end-start;<span class="cstat-no" title="statement not covered" >v</span>ar len=Math.min(x,y);<span class="cstat-no" title="statement not covered" >v</span>ar thisCopy=this.slice(thisStart,thisEnd);<span class="cstat-no" title="statement not covered" >v</span>ar targetCopy=target.slice(start,end);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;len;++i){<span class="cstat-no" title="statement not covered" >if(thisCopy[i]!==targetCopy[i]){<span class="cstat-no" title="statement not covered" >x=thisCopy[i];<span class="cstat-no" title="statement not covered" >y</span>=targetCopy[i];<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x&lt;y)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(y&lt;x)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0}</span>;<span class="fstat-no" title="function not covered" >function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){<span class="cstat-no" title="statement not covered" ></span>if(buffer.length===0)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof byteOffset==="string"){<span class="cstat-no" title="statement not covered" >encoding=byteOffset;<span class="cstat-no" title="statement not covered" >b</span>yteOffset=0}</span>else <span class="cstat-no" title="statement not covered" >if(byteOffset&gt;2147483647){<span class="cstat-no" title="statement not covered" >byteOffset=2147483647}</span>else <span class="cstat-no" title="statement not covered" >if(byteOffset&lt;-2147483648){<span class="cstat-no" title="statement not covered" >byteOffset=-2147483648}<span class="cstat-no" title="statement not covered" ></span>b</span></span></span>yteOffset=+byteOffset;<span class="cstat-no" title="statement not covered" >i</span>f(isNaN(byteOffset)){<span class="cstat-no" title="statement not covered" >byteOffset=dir?0:buffer.length-1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(byteOffset&lt;0)<span class="cstat-no" title="statement not covered" >byteOffset=buffer.length+byteOffset;<span class="cstat-no" title="statement not covered" >i</span></span>f(byteOffset&gt;=buffer.length){<span class="cstat-no" title="statement not covered" >if(dir)<span class="cstat-no" title="statement not covered" >return-1;e</span>lse <span class="cstat-no" title="statement not covered" >byteOffset=buffer.length-1}</span></span>else <span class="cstat-no" title="statement not covered" >if(byteOffset&lt;0){<span class="cstat-no" title="statement not covered" >if(dir)<span class="cstat-no" title="statement not covered" >byteOffset=0;e</span>lse <span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>f(typeof val==="string"){<span class="cstat-no" title="statement not covered" >val=Buffer.from(val,encoding)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Buffer.isBuffer(val)){<span class="cstat-no" title="statement not covered" >if(val.length===0){<span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arrayIndexOf(buffer,val,byteOffset,encoding,dir)}</span>else <span class="cstat-no" title="statement not covered" >if(typeof val==="number"){<span class="cstat-no" title="statement not covered" >val=val&amp;255;<span class="cstat-no" title="statement not covered" >i</span>f(Buffer.TYPED_ARRAY_SUPPORT&amp;&amp;typeof Uint8Array.prototype.indexOf==="function"){<span class="cstat-no" title="statement not covered" >if(dir){<span class="cstat-no" title="statement not covered" >return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset)}</span>else{<span class="cstat-no" title="statement not covered" >return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arrayIndexOf(buffer,[val],byteOffset,encoding,dir)}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow new TypeError("val must be string, number or Buffer")}<span class="fstat-no" title="function not covered" ></span>function arrayIndexOf(arr,val,byteOffset,encoding,dir){<span class="cstat-no" title="statement not covered" ></span>var indexSize=1;<span class="cstat-no" title="statement not covered" >v</span>ar arrLength=arr.length;<span class="cstat-no" title="statement not covered" >v</span>ar valLength=val.length;<span class="cstat-no" title="statement not covered" >i</span>f(encoding!==undefined){<span class="cstat-no" title="statement not covered" >encoding=String(encoding).toLowerCase();<span class="cstat-no" title="statement not covered" >i</span>f(encoding==="ucs2"||encoding==="ucs-2"||encoding==="utf16le"||encoding==="utf-16le"){<span class="cstat-no" title="statement not covered" >if(arr.length&lt;2||val.length&lt;2){<span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span>i</span>ndexSize=2;<span class="cstat-no" title="statement not covered" >a</span>rrLength/=2;<span class="cstat-no" title="statement not covered" >v</span>alLength/=2;<span class="cstat-no" title="statement not covered" >b</span>yteOffset/=2}</span>}<span class="fstat-no" title="function not covered" ></span>f</span>unction read(buf,i){<span class="cstat-no" title="statement not covered" ></span>if(indexSize===1){<span class="cstat-no" title="statement not covered" >return buf[i]}</span>else{<span class="cstat-no" title="statement not covered" >return buf.readUInt16BE(i*indexSize)}</span>}<span class="cstat-no" title="statement not covered" ></span>var i;<span class="cstat-no" title="statement not covered" >i</span>f(dir){<span class="cstat-no" title="statement not covered" >var foundIndex=-1;<span class="cstat-no" title="statement not covered" >f</span>or(i=byteOffset;i&lt;arrLength;i++){<span class="cstat-no" title="statement not covered" >if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){<span class="cstat-no" title="statement not covered" >if(foundIndex===-1)<span class="cstat-no" title="statement not covered" >foundIndex=i;<span class="cstat-no" title="statement not covered" >i</span></span>f(i-foundIndex+1===valLength)<span class="cstat-no" title="statement not covered" >return foundIndex*indexSize}</span></span>else{<span class="cstat-no" title="statement not covered" >if(foundIndex!==-1)<span class="cstat-no" title="statement not covered" >i-=i-foundIndex;<span class="cstat-no" title="statement not covered" >f</span></span>oundIndex=-1}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(byteOffset+valLength&gt;arrLength)<span class="cstat-no" title="statement not covered" >byteOffset=arrLength-valLength;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=byteOffset;i&gt;=0;i--){<span class="cstat-no" title="statement not covered" >var found=true;<span class="cstat-no" title="statement not covered" >f</span>or(var j=0;j&lt;valLength;j++){<span class="cstat-no" title="statement not covered" >if(read(arr,i+j)!==read(val,j)){<span class="cstat-no" title="statement not covered" >found=false;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found)<span class="cstat-no" title="statement not covered" >return i}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn-1}</span>Buffer.prototype.includes=<span class="fstat-no" title="function not covered" >function includes(val,byteOffset,encoding){<span class="cstat-no" title="statement not covered" ></span>return this.indexOf(val,byteOffset,encoding)!==-1}</span>;Buffer.prototype.indexOf=<span class="fstat-no" title="function not covered" >function indexOf(val,byteOffset,encoding){<span class="cstat-no" title="statement not covered" ></span>return bidirectionalIndexOf(this,val,byteOffset,encoding,true)}</span>;Buffer.prototype.lastIndexOf=<span class="fstat-no" title="function not covered" >function lastIndexOf(val,byteOffset,encoding){<span class="cstat-no" title="statement not covered" ></span>return bidirectionalIndexOf(this,val,byteOffset,encoding,false)}</span>;<span class="fstat-no" title="function not covered" >function hexWrite(buf,string,offset,length){<span class="cstat-no" title="statement not covered" ></span>offset=Number(offset)||0;<span class="cstat-no" title="statement not covered" >v</span>ar remaining=buf.length-offset;<span class="cstat-no" title="statement not covered" >i</span>f(!length){<span class="cstat-no" title="statement not covered" >length=remaining}</span>else{<span class="cstat-no" title="statement not covered" >length=Number(length);<span class="cstat-no" title="statement not covered" >i</span>f(length&gt;remaining){<span class="cstat-no" title="statement not covered" >length=remaining}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar strLen=string.length;<span class="cstat-no" title="statement not covered" >i</span>f(strLen%2!==0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid hex string");<span class="cstat-no" title="statement not covered" >i</span></span>f(length&gt;strLen/2){<span class="cstat-no" title="statement not covered" >length=strLen/2}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;length;++i){<span class="cstat-no" title="statement not covered" >var parsed=parseInt(string.substr(i*2,2),16);<span class="cstat-no" title="statement not covered" >i</span>f(isNaN(parsed))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >b</span></span>uf[offset+i]=parsed}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>function utf8Write(buf,string,offset,length){<span class="cstat-no" title="statement not covered" ></span>return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length)}<span class="fstat-no" title="function not covered" ></span>function asciiWrite(buf,string,offset,length){<span class="cstat-no" title="statement not covered" ></span>return blitBuffer(asciiToBytes(string),buf,offset,length)}<span class="fstat-no" title="function not covered" ></span>function latin1Write(buf,string,offset,length){<span class="cstat-no" title="statement not covered" ></span>return asciiWrite(buf,string,offset,length)}<span class="fstat-no" title="function not covered" ></span>function base64Write(buf,string,offset,length){<span class="cstat-no" title="statement not covered" ></span>return blitBuffer(base64ToBytes(string),buf,offset,length)}<span class="fstat-no" title="function not covered" ></span>function ucs2Write(buf,string,offset,length){<span class="cstat-no" title="statement not covered" ></span>return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length)}</span>Buffer.prototype.write=<span class="fstat-no" title="function not covered" >function write(string,offset,length,encoding){<span class="cstat-no" title="statement not covered" ></span>if(offset===undefined){<span class="cstat-no" title="statement not covered" >encoding="utf8";<span class="cstat-no" title="statement not covered" >l</span>ength=this.length;<span class="cstat-no" title="statement not covered" >o</span>ffset=0}</span>else <span class="cstat-no" title="statement not covered" >if(length===undefined&amp;&amp;typeof offset==="string"){<span class="cstat-no" title="statement not covered" >encoding=offset;<span class="cstat-no" title="statement not covered" >l</span>ength=this.length;<span class="cstat-no" title="statement not covered" >o</span>ffset=0}</span>else <span class="cstat-no" title="statement not covered" >if(isFinite(offset)){<span class="cstat-no" title="statement not covered" >offset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(isFinite(length)){<span class="cstat-no" title="statement not covered" >length=length|0;<span class="cstat-no" title="statement not covered" >i</span>f(encoding===undefined)<span class="cstat-no" title="statement not covered" >encoding="utf8"}</span></span>else{<span class="cstat-no" title="statement not covered" >encoding=length;<span class="cstat-no" title="statement not covered" >l</span>ength=undefined}</span>}</span>else{<span class="cstat-no" title="statement not covered" >throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported")}<span class="cstat-no" title="statement not covered" ></span>v</span></span></span>ar remaining=this.length-offset;<span class="cstat-no" title="statement not covered" >i</span>f(length===undefined||length&gt;remaining)<span class="cstat-no" title="statement not covered" >length=remaining;<span class="cstat-no" title="statement not covered" >i</span></span>f(string.length&gt;0&amp;&amp;(length&lt;0||offset&lt;0)||offset&gt;this.length){<span class="cstat-no" title="statement not covered" >throw new RangeError("Attempt to write outside buffer bounds")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!encoding)<span class="cstat-no" title="statement not covered" >encoding="utf8";<span class="cstat-no" title="statement not covered" >v</span></span>ar loweredCase=false;<span class="cstat-no" title="statement not covered" >f</span>or(;;){<span class="cstat-no" title="statement not covered" >switch(encoding){case"hex":<span class="cstat-no" title="statement not covered" >return hexWrite(this,string,offset,length);c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return utf8Write(this,string,offset,length);c</span>ase"ascii":<span class="cstat-no" title="statement not covered" >return asciiWrite(this,string,offset,length);c</span>ase"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return latin1Write(this,string,offset,length);c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return base64Write(this,string,offset,length);c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return ucs2Write(this,string,offset,length);d</span>efault:<span class="cstat-no" title="statement not covered" >if(loweredCase)<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+encoding);<span class="cstat-no" title="statement not covered" >e</span></span>ncoding=(""+encoding).toLowerCase();<span class="cstat-no" title="statement not covered" >l</span>oweredCase=true}</span>}</span>}</span>;Buffer.prototype.toJSON=<span class="fstat-no" title="function not covered" >function toJSON(){<span class="cstat-no" title="statement not covered" ></span>return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}}</span>;<span class="fstat-no" title="function not covered" >function base64Slice(buf,start,end){<span class="cstat-no" title="statement not covered" ></span>if(start===0&amp;&amp;end===buf.length){<span class="cstat-no" title="statement not covered" >return base64.fromByteArray(buf)}</span>else{<span class="cstat-no" title="statement not covered" >return base64.fromByteArray(buf.slice(start,end))}</span>}<span class="fstat-no" title="function not covered" ></span>function utf8Slice(buf,start,end){<span class="cstat-no" title="statement not covered" ></span>end=Math.min(buf.length,end);<span class="cstat-no" title="statement not covered" >v</span>ar res=[];<span class="cstat-no" title="statement not covered" >v</span>ar i=start;<span class="cstat-no" title="statement not covered" >w</span>hile(i&lt;end){<span class="cstat-no" title="statement not covered" >var firstByte=buf[i];<span class="cstat-no" title="statement not covered" >v</span>ar codePoint=null;<span class="cstat-no" title="statement not covered" >v</span>ar bytesPerSequence=firstByte&gt;239?4:firstByte&gt;223?3:firstByte&gt;191?2:1;<span class="cstat-no" title="statement not covered" >i</span>f(i+bytesPerSequence&lt;=end){<span class="cstat-no" title="statement not covered" >var secondByte,thirdByte,fourthByte,tempCodePoint;<span class="cstat-no" title="statement not covered" >s</span>witch(bytesPerSequence){case 1:<span class="cstat-no" title="statement not covered" >if(firstByte&lt;128){<span class="cstat-no" title="statement not covered" >codePoint=firstByte}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >secondByte=buf[i+1];<span class="cstat-no" title="statement not covered" >i</span>f((secondByte&amp;192)===128){<span class="cstat-no" title="statement not covered" >tempCodePoint=(firstByte&amp;31)&lt;&lt;6|secondByte&amp;63;<span class="cstat-no" title="statement not covered" >i</span>f(tempCodePoint&gt;127){<span class="cstat-no" title="statement not covered" >codePoint=tempCodePoint}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >secondByte=buf[i+1];<span class="cstat-no" title="statement not covered" >t</span>hirdByte=buf[i+2];<span class="cstat-no" title="statement not covered" >i</span>f((secondByte&amp;192)===128&amp;&amp;(thirdByte&amp;192)===128){<span class="cstat-no" title="statement not covered" >tempCodePoint=(firstByte&amp;15)&lt;&lt;12|(secondByte&amp;63)&lt;&lt;6|thirdByte&amp;63;<span class="cstat-no" title="statement not covered" >i</span>f(tempCodePoint&gt;2047&amp;&amp;(tempCodePoint&lt;55296||tempCodePoint&gt;57343)){<span class="cstat-no" title="statement not covered" >codePoint=tempCodePoint}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >secondByte=buf[i+1];<span class="cstat-no" title="statement not covered" >t</span>hirdByte=buf[i+2];<span class="cstat-no" title="statement not covered" >f</span>ourthByte=buf[i+3];<span class="cstat-no" title="statement not covered" >i</span>f((secondByte&amp;192)===128&amp;&amp;(thirdByte&amp;192)===128&amp;&amp;(fourthByte&amp;192)===128){<span class="cstat-no" title="statement not covered" >tempCodePoint=(firstByte&amp;15)&lt;&lt;18|(secondByte&amp;63)&lt;&lt;12|(thirdByte&amp;63)&lt;&lt;6|fourthByte&amp;63;<span class="cstat-no" title="statement not covered" >i</span>f(tempCodePoint&gt;65535&amp;&amp;tempCodePoint&lt;1114112){<span class="cstat-no" title="statement not covered" >codePoint=tempCodePoint}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(codePoint===null){<span class="cstat-no" title="statement not covered" >codePoint=65533;<span class="cstat-no" title="statement not covered" >b</span>ytesPerSequence=1}</span>else <span class="cstat-no" title="statement not covered" >if(codePoint&gt;65535){<span class="cstat-no" title="statement not covered" >codePoint-=65536;<span class="cstat-no" title="statement not covered" >r</span>es.push(codePoint&gt;&gt;&gt;10&amp;1023|55296);<span class="cstat-no" title="statement not covered" >c</span>odePoint=56320|codePoint&amp;1023}<span class="cstat-no" title="statement not covered" ></span>r</span></span>es.push(codePoint);<span class="cstat-no" title="statement not covered" >i</span>+=bytesPerSequence}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn decodeCodePointsArray(res)}</span>var MAX_ARGUMENTS_LENGTH=4096;<span class="fstat-no" title="function not covered" >function decodeCodePointsArray(codePoints){<span class="cstat-no" title="statement not covered" ></span>var len=codePoints.length;<span class="cstat-no" title="statement not covered" >i</span>f(len&lt;=MAX_ARGUMENTS_LENGTH){<span class="cstat-no" title="statement not covered" >return String.fromCharCode.apply(String,codePoints)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar res="";<span class="cstat-no" title="statement not covered" >v</span>ar i=0;<span class="cstat-no" title="statement not covered" >w</span>hile(i&lt;len){<span class="cstat-no" title="statement not covered" >res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res}<span class="fstat-no" title="function not covered" ></span>function asciiSlice(buf,start,end){<span class="cstat-no" title="statement not covered" ></span>var ret="";<span class="cstat-no" title="statement not covered" >e</span>nd=Math.min(buf.length,end);<span class="cstat-no" title="statement not covered" >f</span>or(var i=start;i&lt;end;++i){<span class="cstat-no" title="statement not covered" >ret+=String.fromCharCode(buf[i]&amp;127)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function latin1Slice(buf,start,end){<span class="cstat-no" title="statement not covered" ></span>var ret="";<span class="cstat-no" title="statement not covered" >e</span>nd=Math.min(buf.length,end);<span class="cstat-no" title="statement not covered" >f</span>or(var i=start;i&lt;end;++i){<span class="cstat-no" title="statement not covered" >ret+=String.fromCharCode(buf[i])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function hexSlice(buf,start,end){<span class="cstat-no" title="statement not covered" ></span>var len=buf.length;<span class="cstat-no" title="statement not covered" >i</span>f(!start||start&lt;0)<span class="cstat-no" title="statement not covered" >start=0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!end||end&lt;0||end&gt;len)<span class="cstat-no" title="statement not covered" >end=len;<span class="cstat-no" title="statement not covered" >v</span></span>ar out="";<span class="cstat-no" title="statement not covered" >f</span>or(var i=start;i&lt;end;++i){<span class="cstat-no" title="statement not covered" >out+=toHex(buf[i])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn out}<span class="fstat-no" title="function not covered" ></span>function utf16leSlice(buf,start,end){<span class="cstat-no" title="statement not covered" ></span>var bytes=buf.slice(start,end);<span class="cstat-no" title="statement not covered" >v</span>ar res="";<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;bytes.length;i+=2){<span class="cstat-no" title="statement not covered" >res+=String.fromCharCode(bytes[i]+bytes[i+1]*256)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res}</span>Buffer.prototype.slice=<span class="fstat-no" title="function not covered" >function slice(start,end){<span class="cstat-no" title="statement not covered" ></span>var len=this.length;<span class="cstat-no" title="statement not covered" >s</span>tart=~~start;<span class="cstat-no" title="statement not covered" >e</span>nd=end===undefined?len:~~end;<span class="cstat-no" title="statement not covered" >i</span>f(start&lt;0){<span class="cstat-no" title="statement not covered" >start+=len;<span class="cstat-no" title="statement not covered" >i</span>f(start&lt;0)<span class="cstat-no" title="statement not covered" >start=0}</span></span>else <span class="cstat-no" title="statement not covered" >if(start&gt;len){<span class="cstat-no" title="statement not covered" >start=len}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(end&lt;0){<span class="cstat-no" title="statement not covered" >end+=len;<span class="cstat-no" title="statement not covered" >i</span>f(end&lt;0)<span class="cstat-no" title="statement not covered" >end=0}</span></span>else <span class="cstat-no" title="statement not covered" >if(end&gt;len){<span class="cstat-no" title="statement not covered" >end=len}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(end&lt;start)<span class="cstat-no" title="statement not covered" >end=start;<span class="cstat-no" title="statement not covered" >v</span></span>ar newBuf;<span class="cstat-no" title="statement not covered" >i</span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >newBuf=this.subarray(start,end);<span class="cstat-no" title="statement not covered" >n</span>ewBuf.__proto__=Buffer.prototype}</span>else{<span class="cstat-no" title="statement not covered" >var sliceLen=end-start;<span class="cstat-no" title="statement not covered" >n</span>ewBuf=new Buffer(sliceLen,undefined);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;sliceLen;++i){<span class="cstat-no" title="statement not covered" >newBuf[i]=this[i+start]}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn newBuf}</span>;<span class="fstat-no" title="function not covered" >function checkOffset(offset,ext,length){<span class="cstat-no" title="statement not covered" ></span>if(offset%1!==0||offset&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("offset is not uint");<span class="cstat-no" title="statement not covered" >i</span></span>f(offset+ext&gt;length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Trying to access beyond buffer length")}</span></span>Buffer.prototype.readUIntLE=<span class="fstat-no" title="function not covered" >function readUIntLE(offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>offset=offset|0;<span class="cstat-no" title="statement not covered" >b</span>yteLength=byteLength|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,byteLength,this.length);<span class="cstat-no" title="statement not covered" >v</span></span>ar val=this[offset];<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar i=0;<span class="cstat-no" title="statement not covered" >w</span>hile(++i&lt;byteLength&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >val+=this[offset+i]*mul}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn val}</span>;Buffer.prototype.readUIntBE=<span class="fstat-no" title="function not covered" >function readUIntBE(offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>offset=offset|0;<span class="cstat-no" title="statement not covered" >b</span>yteLength=byteLength|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert){<span class="cstat-no" title="statement not covered" >checkOffset(offset,byteLength,this.length)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar val=this[offset+--byteLength];<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >w</span>hile(byteLength&gt;0&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >val+=this[offset+--byteLength]*mul}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn val}</span>;Buffer.prototype.readUInt8=<span class="fstat-no" title="function not covered" >function readUInt8(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,1,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this[offset]}</span>;Buffer.prototype.readUInt16LE=<span class="fstat-no" title="function not covered" >function readUInt16LE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,2,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this[offset]|this[offset+1]&lt;&lt;8}</span>;Buffer.prototype.readUInt16BE=<span class="fstat-no" title="function not covered" >function readUInt16BE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,2,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this[offset]&lt;&lt;8|this[offset+1]}</span>;Buffer.prototype.readUInt32LE=<span class="fstat-no" title="function not covered" >function readUInt32LE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,4,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn(this[offset]|this[offset+1]&lt;&lt;8|this[offset+2]&lt;&lt;16)+this[offset+3]*16777216}</span>;Buffer.prototype.readUInt32BE=<span class="fstat-no" title="function not covered" >function readUInt32BE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,4,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this[offset]*16777216+(this[offset+1]&lt;&lt;16|this[offset+2]&lt;&lt;8|this[offset+3])}</span>;Buffer.prototype.readIntLE=<span class="fstat-no" title="function not covered" >function readIntLE(offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>offset=offset|0;<span class="cstat-no" title="statement not covered" >b</span>yteLength=byteLength|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,byteLength,this.length);<span class="cstat-no" title="statement not covered" >v</span></span>ar val=this[offset];<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar i=0;<span class="cstat-no" title="statement not covered" >w</span>hile(++i&lt;byteLength&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >val+=this[offset+i]*mul}<span class="cstat-no" title="statement not covered" ></span>m</span>ul*=128;<span class="cstat-no" title="statement not covered" >i</span>f(val&gt;=mul)<span class="cstat-no" title="statement not covered" >val-=Math.pow(2,8*byteLength);<span class="cstat-no" title="statement not covered" >r</span></span>eturn val}</span>;Buffer.prototype.readIntBE=<span class="fstat-no" title="function not covered" >function readIntBE(offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>offset=offset|0;<span class="cstat-no" title="statement not covered" >b</span>yteLength=byteLength|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,byteLength,this.length);<span class="cstat-no" title="statement not covered" >v</span></span>ar i=byteLength;<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar val=this[offset+--i];<span class="cstat-no" title="statement not covered" >w</span>hile(i&gt;0&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >val+=this[offset+--i]*mul}<span class="cstat-no" title="statement not covered" ></span>m</span>ul*=128;<span class="cstat-no" title="statement not covered" >i</span>f(val&gt;=mul)<span class="cstat-no" title="statement not covered" >val-=Math.pow(2,8*byteLength);<span class="cstat-no" title="statement not covered" >r</span></span>eturn val}</span>;Buffer.prototype.readInt8=<span class="fstat-no" title="function not covered" >function readInt8(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,1,this.length);<span class="cstat-no" title="statement not covered" >i</span></span>f(!(this[offset]&amp;128))<span class="cstat-no" title="statement not covered" >return this[offset];<span class="cstat-no" title="statement not covered" >r</span></span>eturn(255-this[offset]+1)*-1}</span>;Buffer.prototype.readInt16LE=<span class="fstat-no" title="function not covered" >function readInt16LE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,2,this.length);<span class="cstat-no" title="statement not covered" >v</span></span>ar val=this[offset]|this[offset+1]&lt;&lt;8;<span class="cstat-no" title="statement not covered" >r</span>eturn val&amp;32768?val|4294901760:val}</span>;Buffer.prototype.readInt16BE=<span class="fstat-no" title="function not covered" >function readInt16BE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,2,this.length);<span class="cstat-no" title="statement not covered" >v</span></span>ar val=this[offset+1]|this[offset]&lt;&lt;8;<span class="cstat-no" title="statement not covered" >r</span>eturn val&amp;32768?val|4294901760:val}</span>;Buffer.prototype.readInt32LE=<span class="fstat-no" title="function not covered" >function readInt32LE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,4,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this[offset]|this[offset+1]&lt;&lt;8|this[offset+2]&lt;&lt;16|this[offset+3]&lt;&lt;24}</span>;Buffer.prototype.readInt32BE=<span class="fstat-no" title="function not covered" >function readInt32BE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,4,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this[offset]&lt;&lt;24|this[offset+1]&lt;&lt;16|this[offset+2]&lt;&lt;8|this[offset+3]}</span>;Buffer.prototype.readFloatLE=<span class="fstat-no" title="function not covered" >function readFloatLE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,4,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn ieee754.read(this,offset,true,23,4)}</span>;Buffer.prototype.readFloatBE=<span class="fstat-no" title="function not covered" >function readFloatBE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,4,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn ieee754.read(this,offset,false,23,4)}</span>;Buffer.prototype.readDoubleLE=<span class="fstat-no" title="function not covered" >function readDoubleLE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,8,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn ieee754.read(this,offset,true,52,8)}</span>;Buffer.prototype.readDoubleBE=<span class="fstat-no" title="function not covered" >function readDoubleBE(offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkOffset(offset,8,this.length);<span class="cstat-no" title="statement not covered" >r</span></span>eturn ieee754.read(this,offset,false,52,8)}</span>;<span class="fstat-no" title="function not covered" >function checkInt(buf,value,offset,ext,max,min){<span class="cstat-no" title="statement not covered" ></span>if(!Buffer.isBuffer(buf))<span class="cstat-no" title="statement not covered" >throw new TypeError('"buffer" argument must be a Buffer instance');<span class="cstat-no" title="statement not covered" >i</span></span>f(value&gt;max||value&lt;min)<span class="cstat-no" title="statement not covered" >throw new RangeError('"value" argument is out of bounds');<span class="cstat-no" title="statement not covered" >i</span></span>f(offset+ext&gt;buf.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range")}</span></span>Buffer.prototype.writeUIntLE=<span class="fstat-no" title="function not covered" >function writeUIntLE(value,offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >b</span>yteLength=byteLength|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert){<span class="cstat-no" title="statement not covered" >var maxBytes=Math.pow(2,8*byteLength)-1;<span class="cstat-no" title="statement not covered" >c</span>heckInt(this,value,offset,byteLength,maxBytes,0)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar i=0;<span class="cstat-no" title="statement not covered" >t</span>his[offset]=value&amp;255;<span class="cstat-no" title="statement not covered" >w</span>hile(++i&lt;byteLength&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >this[offset+i]=value/mul&amp;255}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+byteLength}</span>;Buffer.prototype.writeUIntBE=<span class="fstat-no" title="function not covered" >function writeUIntBE(value,offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >b</span>yteLength=byteLength|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert){<span class="cstat-no" title="statement not covered" >var maxBytes=Math.pow(2,8*byteLength)-1;<span class="cstat-no" title="statement not covered" >c</span>heckInt(this,value,offset,byteLength,maxBytes,0)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar i=byteLength-1;<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >t</span>his[offset+i]=value&amp;255;<span class="cstat-no" title="statement not covered" >w</span>hile(--i&gt;=0&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >this[offset+i]=value/mul&amp;255}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+byteLength}</span>;Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset|0;<span class="missing-if-branch" title="if path not taken" >I</span>if(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,1,255,0);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!Buffer.TYPED_ARRAY_SUPPORT)<span class="cstat-no" title="statement not covered" >value=Math.floor(value);t</span>his[offset]=value&amp;255;return offset+1};<span class="fstat-no" title="function not covered" >function objectWriteUInt16(buf,value,offset,littleEndian){<span class="cstat-no" title="statement not covered" ></span>if(value&lt;0)<span class="cstat-no" title="statement not covered" >value=65535+value+1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0,j=Math.min(buf.length-offset,2);i&lt;j;++i){<span class="cstat-no" title="statement not covered" >buf[offset+i]=(value&amp;255&lt;&lt;8*(littleEndian?i:1-i))&gt;&gt;&gt;(littleEndian?i:1-i)*8}</span>}</span>Buffer.prototype.writeUInt16LE=<span class="fstat-no" title="function not covered" >function writeUInt16LE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,2,65535,0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&amp;255;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&gt;&gt;&gt;8}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt16(this,value,offset,true)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+2}</span>;Buffer.prototype.writeUInt16BE=<span class="fstat-no" title="function not covered" >function writeUInt16BE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,2,65535,0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&amp;255}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt16(this,value,offset,false)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+2}</span>;<span class="fstat-no" title="function not covered" >function objectWriteUInt32(buf,value,offset,littleEndian){<span class="cstat-no" title="statement not covered" ></span>if(value&lt;0)<span class="cstat-no" title="statement not covered" >value=4294967295+value+1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0,j=Math.min(buf.length-offset,4);i&lt;j;++i){<span class="cstat-no" title="statement not covered" >buf[offset+i]=value&gt;&gt;&gt;(littleEndian?i:3-i)*8&amp;255}</span>}</span>Buffer.prototype.writeUInt32LE=<span class="fstat-no" title="function not covered" >function writeUInt32LE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,4,4294967295,0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset+3]=value&gt;&gt;&gt;24;<span class="cstat-no" title="statement not covered" >t</span>his[offset+2]=value&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>his[offset]=value&amp;255}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt32(this,value,offset,true)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+4}</span>;Buffer.prototype.writeUInt32BE=<span class="fstat-no" title="function not covered" >function writeUInt32BE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,4,4294967295,0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&gt;&gt;&gt;24;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>his[offset+2]=value&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>his[offset+3]=value&amp;255}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt32(this,value,offset,false)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+4}</span>;Buffer.prototype.writeIntLE=<span class="fstat-no" title="function not covered" >function writeIntLE(value,offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert){<span class="cstat-no" title="statement not covered" >var limit=Math.pow(2,8*byteLength-1);<span class="cstat-no" title="statement not covered" >c</span>heckInt(this,value,offset,byteLength,limit-1,-limit)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar i=0;<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar sub=0;<span class="cstat-no" title="statement not covered" >t</span>his[offset]=value&amp;255;<span class="cstat-no" title="statement not covered" >w</span>hile(++i&lt;byteLength&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >if(value&lt;0&amp;&amp;sub===0&amp;&amp;this[offset+i-1]!==0){<span class="cstat-no" title="statement not covered" >sub=1}<span class="cstat-no" title="statement not covered" ></span>t</span>his[offset+i]=(value/mul&gt;&gt;0)-sub&amp;255}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+byteLength}</span>;Buffer.prototype.writeIntBE=<span class="fstat-no" title="function not covered" >function writeIntBE(value,offset,byteLength,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert){<span class="cstat-no" title="statement not covered" >var limit=Math.pow(2,8*byteLength-1);<span class="cstat-no" title="statement not covered" >c</span>heckInt(this,value,offset,byteLength,limit-1,-limit)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar i=byteLength-1;<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar sub=0;<span class="cstat-no" title="statement not covered" >t</span>his[offset+i]=value&amp;255;<span class="cstat-no" title="statement not covered" >w</span>hile(--i&gt;=0&amp;&amp;(mul*=256)){<span class="cstat-no" title="statement not covered" >if(value&lt;0&amp;&amp;sub===0&amp;&amp;this[offset+i+1]!==0){<span class="cstat-no" title="statement not covered" >sub=1}<span class="cstat-no" title="statement not covered" ></span>t</span>his[offset+i]=(value/mul&gt;&gt;0)-sub&amp;255}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+byteLength}</span>;Buffer.prototype.writeInt8=<span class="fstat-no" title="function not covered" >function writeInt8(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,1,127,-128);<span class="cstat-no" title="statement not covered" >i</span></span>f(!Buffer.TYPED_ARRAY_SUPPORT)<span class="cstat-no" title="statement not covered" >value=Math.floor(value);<span class="cstat-no" title="statement not covered" >i</span></span>f(value&lt;0)<span class="cstat-no" title="statement not covered" >value=255+value+1;<span class="cstat-no" title="statement not covered" >t</span></span>his[offset]=value&amp;255;<span class="cstat-no" title="statement not covered" >r</span>eturn offset+1}</span>;Buffer.prototype.writeInt16LE=<span class="fstat-no" title="function not covered" >function writeInt16LE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,2,32767,-32768);<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&amp;255;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&gt;&gt;&gt;8}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt16(this,value,offset,true)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+2}</span>;Buffer.prototype.writeInt16BE=<span class="fstat-no" title="function not covered" >function writeInt16BE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,2,32767,-32768);</span></span>
<span class="cstat-no" title="statement not covered" >if(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&amp;255}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt16(this,value,offset,false)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+2}</span>;Buffer.prototype.writeInt32LE=<span class="fstat-no" title="function not covered" >function writeInt32LE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,4,2147483647,-2147483648);<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&amp;255;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>his[offset+2]=value&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>his[offset+3]=value&gt;&gt;&gt;24}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt32(this,value,offset,true)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+4}</span>;Buffer.prototype.writeInt32BE=<span class="fstat-no" title="function not covered" >function writeInt32BE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>value=+value;<span class="cstat-no" title="statement not covered" >o</span>ffset=offset|0;<span class="cstat-no" title="statement not covered" >i</span>f(!noAssert)<span class="cstat-no" title="statement not covered" >checkInt(this,value,offset,4,2147483647,-2147483648);<span class="cstat-no" title="statement not covered" >i</span></span>f(value&lt;0)<span class="cstat-no" title="statement not covered" >value=4294967295+value+1;<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >this[offset]=value&gt;&gt;&gt;24;<span class="cstat-no" title="statement not covered" >t</span>his[offset+1]=value&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>his[offset+2]=value&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>his[offset+3]=value&amp;255}</span>else{<span class="cstat-no" title="statement not covered" >objectWriteUInt32(this,value,offset,false)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn offset+4}</span>;<span class="fstat-no" title="function not covered" >function checkIEEE754(buf,value,offset,ext,max,min){<span class="cstat-no" title="statement not covered" ></span>if(offset+ext&gt;buf.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range");<span class="cstat-no" title="statement not covered" >i</span></span>f(offset&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range")}<span class="fstat-no" title="function not covered" ></span></span>function writeFloat(buf,value,offset,littleEndian,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert){<span class="cstat-no" title="statement not covered" >checkIEEE754(buf,value,offset,4,3.4028234663852886e38,-3.4028234663852886e38)}<span class="cstat-no" title="statement not covered" ></span>i</span>eee754.write(buf,value,offset,littleEndian,23,4);<span class="cstat-no" title="statement not covered" >r</span>eturn offset+4}</span>Buffer.prototype.writeFloatLE=<span class="fstat-no" title="function not covered" >function writeFloatLE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>return writeFloat(this,value,offset,true,noAssert)}</span>;Buffer.prototype.writeFloatBE=<span class="fstat-no" title="function not covered" >function writeFloatBE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>return writeFloat(this,value,offset,false,noAssert)}</span>;<span class="fstat-no" title="function not covered" >function writeDouble(buf,value,offset,littleEndian,noAssert){<span class="cstat-no" title="statement not covered" ></span>if(!noAssert){<span class="cstat-no" title="statement not covered" >checkIEEE754(buf,value,offset,8,1.7976931348623157e308,-1.7976931348623157e308)}<span class="cstat-no" title="statement not covered" ></span>i</span>eee754.write(buf,value,offset,littleEndian,52,8);<span class="cstat-no" title="statement not covered" >r</span>eturn offset+8}</span>Buffer.prototype.writeDoubleLE=<span class="fstat-no" title="function not covered" >function writeDoubleLE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>return writeDouble(this,value,offset,true,noAssert)}</span>;Buffer.prototype.writeDoubleBE=<span class="fstat-no" title="function not covered" >function writeDoubleBE(value,offset,noAssert){<span class="cstat-no" title="statement not covered" ></span>return writeDouble(this,value,offset,false,noAssert)}</span>;Buffer.prototype.copy=<span class="fstat-no" title="function not covered" >function copy(target,targetStart,start,end){<span class="cstat-no" title="statement not covered" ></span>if(!start)<span class="cstat-no" title="statement not covered" >start=0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!end&amp;&amp;end!==0)<span class="cstat-no" title="statement not covered" >end=this.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(targetStart&gt;=target.length)<span class="cstat-no" title="statement not covered" >targetStart=target.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(!targetStart)<span class="cstat-no" title="statement not covered" >targetStart=0;<span class="cstat-no" title="statement not covered" >i</span></span>f(end&gt;0&amp;&amp;end&lt;start)<span class="cstat-no" title="statement not covered" >end=start;<span class="cstat-no" title="statement not covered" >i</span></span>f(end===start)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(target.length===0||this.length===0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(targetStart&lt;0){<span class="cstat-no" title="statement not covered" >throw new RangeError("targetStart out of bounds")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(start&lt;0||start&gt;=this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("sourceStart out of bounds");<span class="cstat-no" title="statement not covered" >i</span></span>f(end&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("sourceEnd out of bounds");<span class="cstat-no" title="statement not covered" >i</span></span>f(end&gt;this.length)<span class="cstat-no" title="statement not covered" >end=this.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(target.length-targetStart&lt;end-start){<span class="cstat-no" title="statement not covered" >end=target.length-targetStart+start}<span class="cstat-no" title="statement not covered" ></span>v</span>ar len=end-start;<span class="cstat-no" title="statement not covered" >v</span>ar i;<span class="cstat-no" title="statement not covered" >i</span>f(this===target&amp;&amp;start&lt;targetStart&amp;&amp;targetStart&lt;end){<span class="cstat-no" title="statement not covered" >for(i=len-1;i&gt;=0;--i){<span class="cstat-no" title="statement not covered" >target[i+targetStart]=this[i+start]}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(len&lt;1e3||!Buffer.TYPED_ARRAY_SUPPORT){<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;len;++i){<span class="cstat-no" title="statement not covered" >target[i+targetStart]=this[i+start]}</span>}</span>else{<span class="cstat-no" title="statement not covered" >Uint8Array.prototype.set.call(target,this.subarray(start,start+len),targetStart)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn len}</span>;Buffer.prototype.fill=<span class="fstat-no" title="function not covered" >function fill(val,start,end,encoding){<span class="cstat-no" title="statement not covered" ></span>if(typeof val==="string"){<span class="cstat-no" title="statement not covered" >if(typeof start==="string"){<span class="cstat-no" title="statement not covered" >encoding=start;<span class="cstat-no" title="statement not covered" >s</span>tart=0;<span class="cstat-no" title="statement not covered" >e</span>nd=this.length}</span>else <span class="cstat-no" title="statement not covered" >if(typeof end==="string"){<span class="cstat-no" title="statement not covered" >encoding=end;<span class="cstat-no" title="statement not covered" >e</span>nd=this.length}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(val.length===1){<span class="cstat-no" title="statement not covered" >var code=val.charCodeAt(0);<span class="cstat-no" title="statement not covered" >i</span>f(code&lt;256){<span class="cstat-no" title="statement not covered" >val=code}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(encoding!==undefined&amp;&amp;typeof encoding!=="string"){<span class="cstat-no" title="statement not covered" >throw new TypeError("encoding must be a string")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof encoding==="string"&amp;&amp;!Buffer.isEncoding(encoding)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+encoding)}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(typeof val==="number"){<span class="cstat-no" title="statement not covered" >val=val&amp;255}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(start&lt;0||this.length&lt;start||this.length&lt;end){<span class="cstat-no" title="statement not covered" >throw new RangeError("Out of range index")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(end&lt;=start){<span class="cstat-no" title="statement not covered" >return this}<span class="cstat-no" title="statement not covered" ></span>s</span>tart=start&gt;&gt;&gt;0;<span class="cstat-no" title="statement not covered" >e</span>nd=end===undefined?this.length:end&gt;&gt;&gt;0;<span class="cstat-no" title="statement not covered" >i</span>f(!val)<span class="cstat-no" title="statement not covered" >val=0;<span class="cstat-no" title="statement not covered" >v</span></span>ar i;<span class="cstat-no" title="statement not covered" >i</span>f(typeof val==="number"){<span class="cstat-no" title="statement not covered" >for(i=start;i&lt;end;++i){<span class="cstat-no" title="statement not covered" >this[i]=val}</span>}</span>else{<span class="cstat-no" title="statement not covered" >var bytes=Buffer.isBuffer(val)?val:utf8ToBytes(new Buffer(val,encoding).toString());<span class="cstat-no" title="statement not covered" >v</span>ar len=bytes.length;<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;end-start;++i){<span class="cstat-no" title="statement not covered" >this[i+start]=bytes[i%len]}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;var INVALID_BASE64_RE=/[^+\/0-9A-Za-z-_]/g;<span class="fstat-no" title="function not covered" >function base64clean(str){<span class="cstat-no" title="statement not covered" ></span>str=stringtrim(str).replace(INVALID_BASE64_RE,"");<span class="cstat-no" title="statement not covered" >i</span>f(str.length&lt;2)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >w</span></span>hile(str.length%4!==0){<span class="cstat-no" title="statement not covered" >str=str+"="}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn str}<span class="fstat-no" title="function not covered" ></span>function stringtrim(str){<span class="cstat-no" title="statement not covered" ></span>if(str.trim)<span class="cstat-no" title="statement not covered" >return str.trim();<span class="cstat-no" title="statement not covered" >r</span></span>eturn str.replace(/^\s+|\s+$/g,"")}<span class="fstat-no" title="function not covered" ></span>function toHex(n){<span class="cstat-no" title="statement not covered" ></span>if(n&lt;16)<span class="cstat-no" title="statement not covered" >return"0"+n.toString(16);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.toString(16)}<span class="fstat-no" title="function not covered" ></span>function utf8ToBytes(string,units){<span class="cstat-no" title="statement not covered" ></span>units=units||Infinity;<span class="cstat-no" title="statement not covered" >v</span>ar codePoint;<span class="cstat-no" title="statement not covered" >v</span>ar length=string.length;<span class="cstat-no" title="statement not covered" >v</span>ar leadSurrogate=null;<span class="cstat-no" title="statement not covered" >v</span>ar bytes=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;length;++i){<span class="cstat-no" title="statement not covered" >codePoint=string.charCodeAt(i);<span class="cstat-no" title="statement not covered" >i</span>f(codePoint&gt;55295&amp;&amp;codePoint&lt;57344){<span class="cstat-no" title="statement not covered" >if(!leadSurrogate){<span class="cstat-no" title="statement not covered" >if(codePoint&gt;56319){<span class="cstat-no" title="statement not covered" >if((units-=3)&gt;-1)<span class="cstat-no" title="statement not covered" >bytes.push(239,191,189);<span class="cstat-no" title="statement not covered" >c</span></span>ontinue}</span>else <span class="cstat-no" title="statement not covered" >if(i+1===length){<span class="cstat-no" title="statement not covered" >if((units-=3)&gt;-1)<span class="cstat-no" title="statement not covered" >bytes.push(239,191,189);<span class="cstat-no" title="statement not covered" >c</span></span>ontinue}<span class="cstat-no" title="statement not covered" ></span>l</span></span>eadSurrogate=codePoint;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(codePoint&lt;56320){<span class="cstat-no" title="statement not covered" >if((units-=3)&gt;-1)<span class="cstat-no" title="statement not covered" >bytes.push(239,191,189);<span class="cstat-no" title="statement not covered" >l</span></span>eadSurrogate=codePoint;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>c</span>odePoint=(leadSurrogate-55296&lt;&lt;10|codePoint-56320)+65536}</span>else <span class="cstat-no" title="statement not covered" >if(leadSurrogate){<span class="cstat-no" title="statement not covered" >if((units-=3)&gt;-1)<span class="cstat-no" title="statement not covered" >bytes.push(239,191,189)}<span class="cstat-no" title="statement not covered" ></span></span>l</span></span>eadSurrogate=null;<span class="cstat-no" title="statement not covered" >i</span>f(codePoint&lt;128){<span class="cstat-no" title="statement not covered" >if((units-=1)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >b</span></span>ytes.push(codePoint)}</span>else <span class="cstat-no" title="statement not covered" >if(codePoint&lt;2048){<span class="cstat-no" title="statement not covered" >if((units-=2)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >b</span></span>ytes.push(codePoint&gt;&gt;6|192,codePoint&amp;63|128)}</span>else <span class="cstat-no" title="statement not covered" >if(codePoint&lt;65536){<span class="cstat-no" title="statement not covered" >if((units-=3)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >b</span></span>ytes.push(codePoint&gt;&gt;12|224,codePoint&gt;&gt;6&amp;63|128,codePoint&amp;63|128)}</span>else <span class="cstat-no" title="statement not covered" >if(codePoint&lt;1114112){<span class="cstat-no" title="statement not covered" >if((units-=4)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >b</span></span>ytes.push(codePoint&gt;&gt;18|240,codePoint&gt;&gt;12&amp;63|128,codePoint&gt;&gt;6&amp;63|128,codePoint&amp;63|128)}</span>else{<span class="cstat-no" title="statement not covered" >throw new Error("Invalid code point")}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span></span>r</span>eturn bytes}<span class="fstat-no" title="function not covered" ></span>function asciiToBytes(str){<span class="cstat-no" title="statement not covered" ></span>var byteArray=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;str.length;++i){<span class="cstat-no" title="statement not covered" >byteArray.push(str.charCodeAt(i)&amp;255)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn byteArray}<span class="fstat-no" title="function not covered" ></span>function utf16leToBytes(str,units){<span class="cstat-no" title="statement not covered" ></span>var c,hi,lo;<span class="cstat-no" title="statement not covered" >v</span>ar byteArray=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;str.length;++i){<span class="cstat-no" title="statement not covered" >if((units-=2)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >c</span></span>=str.charCodeAt(i);<span class="cstat-no" title="statement not covered" >h</span>i=c&gt;&gt;8;<span class="cstat-no" title="statement not covered" >l</span>o=c%256;<span class="cstat-no" title="statement not covered" >b</span>yteArray.push(lo);<span class="cstat-no" title="statement not covered" >b</span>yteArray.push(hi)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn byteArray}<span class="fstat-no" title="function not covered" ></span>function base64ToBytes(str){<span class="cstat-no" title="statement not covered" ></span>return base64.toByteArray(base64clean(str))}<span class="fstat-no" title="function not covered" ></span>function blitBuffer(src,dst,offset,length){<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;length;++i){<span class="cstat-no" title="statement not covered" >if(i+offset&gt;=dst.length||i&gt;=src.length)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >d</span></span>st[i+offset]=src[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function isnan(val){return val!==val}}).call(this,typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})</span>},{"base64-js":1,ieee754:21,isarray:5}],5:[function(require,module,exports){var toString={}.toString;module.exports=Array.isArray||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(arr){<span class="cstat-no" title="statement not covered" ></span>return toString.call(arr)=="[object Array]"}</span>}</span>,{}],6:[function(require,module,exports){(function(Buffer){<span class="fstat-no" title="function not covered" >function isArray(arg){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray){<span class="cstat-no" title="statement not covered" >return Array.isArray(arg)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objectToString(arg)==="[object Array]"}</span>exports.isArray=isArray;<span class="fstat-no" title="function not covered" >function isBoolean(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="boolean"}</span>exports.isBoolean=isBoolean;<span class="fstat-no" title="function not covered" >function isNull(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===null}</span>exports.isNull=isNull;<span class="fstat-no" title="function not covered" >function isNullOrUndefined(arg){<span class="cstat-no" title="statement not covered" ></span>return arg==null}</span>exports.isNullOrUndefined=isNullOrUndefined;<span class="fstat-no" title="function not covered" >function isNumber(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="number"}</span>exports.isNumber=isNumber;<span class="fstat-no" title="function not covered" >function isString(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="string"}</span>exports.isString=isString;<span class="fstat-no" title="function not covered" >function isSymbol(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="symbol"}</span>exports.isSymbol=isSymbol;<span class="fstat-no" title="function not covered" >function isUndefined(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===void 0}</span>exports.isUndefined=isUndefined;<span class="fstat-no" title="function not covered" >function isRegExp(re){<span class="cstat-no" title="statement not covered" ></span>return objectToString(re)==="[object RegExp]"}</span>exports.isRegExp=isRegExp;<span class="fstat-no" title="function not covered" >function isObject(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="object"&amp;&amp;arg!==null}</span>exports.isObject=isObject;<span class="fstat-no" title="function not covered" >function isDate(d){<span class="cstat-no" title="statement not covered" ></span>return objectToString(d)==="[object Date]"}</span>exports.isDate=isDate;<span class="fstat-no" title="function not covered" >function isError(e){<span class="cstat-no" title="statement not covered" ></span>return objectToString(e)==="[object Error]"||e instanceof Error}</span>exports.isError=isError;<span class="fstat-no" title="function not covered" >function isFunction(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="function"}</span>exports.isFunction=isFunction;<span class="fstat-no" title="function not covered" >function isPrimitive(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===null||typeof arg==="boolean"||typeof arg==="number"||typeof arg==="string"||typeof arg==="symbol"||typeof arg==="undefined"}</span>exports.isPrimitive=isPrimitive;exports.isBuffer=Buffer.isBuffer;<span class="fstat-no" title="function not covered" >function objectToString(o){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.toString.call(o)}</span>}).call(this,{isBuffer:require("../../is-buffer/index.js")})},{"../../is-buffer/index.js":23}],7:[function(require,module,exports){(function(process,Buffer){var stream=require("readable-stream");var eos=require("end-of-stream");var inherits=require("inherits");var shift=require("stream-shift");var SIGNAL_FLUSH=new Buffer([0]);var onuncork=<span class="fstat-no" title="function not covered" >function(self,fn){<span class="cstat-no" title="statement not covered" ></span>if(self._corked)<span class="cstat-no" title="statement not covered" >self.once("uncork",fn);e</span>lse <span class="cstat-no" title="statement not covered" >fn()}</span></span>;var destroyer=<span class="fstat-no" title="function not covered" >function(self,end){<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>if(err)<span class="cstat-no" title="statement not covered" >self.destroy(err.message==="premature close"?null:err);e</span>lse <span class="cstat-no" title="statement not covered" >if(end&amp;&amp;!self._ended)<span class="cstat-no" title="statement not covered" >self.end()}</span></span></span>}</span>;var end=<span class="fstat-no" title="function not covered" >function(ws,fn){<span class="cstat-no" title="statement not covered" ></span>if(!ws)<span class="cstat-no" title="statement not covered" >return fn();<span class="cstat-no" title="statement not covered" >i</span></span>f(ws._writableState&amp;&amp;ws._writableState.finished)<span class="cstat-no" title="statement not covered" >return fn();<span class="cstat-no" title="statement not covered" >i</span></span>f(ws._writableState)<span class="cstat-no" title="statement not covered" >return ws.end(fn);<span class="cstat-no" title="statement not covered" >w</span></span>s.end();<span class="cstat-no" title="statement not covered" >f</span>n()}</span>;var toStreams2=<span class="fstat-no" title="function not covered" >function(rs){<span class="cstat-no" title="statement not covered" ></span>return new stream.Readable({objectMode:true,highWaterMark:16}).wrap(rs)}</span>;var Duplexify=<span class="fstat-no" title="function not covered" >function(writable,readable,opts){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof Duplexify))<span class="cstat-no" title="statement not covered" >return new Duplexify(writable,readable,opts);<span class="cstat-no" title="statement not covered" >s</span></span>tream.Duplex.call(this,opts);<span class="cstat-no" title="statement not covered" >t</span>his._writable=null;<span class="cstat-no" title="statement not covered" >t</span>his._readable=null;<span class="cstat-no" title="statement not covered" >t</span>his._readable2=null;<span class="cstat-no" title="statement not covered" >t</span>his._forwardDestroy=!opts||opts.destroy!==false;<span class="cstat-no" title="statement not covered" >t</span>his._forwardEnd=!opts||opts.end!==false;<span class="cstat-no" title="statement not covered" >t</span>his._corked=1;<span class="cstat-no" title="statement not covered" >t</span>his._ondrain=null;<span class="cstat-no" title="statement not covered" >t</span>his._drained=false;<span class="cstat-no" title="statement not covered" >t</span>his._forwarding=false;<span class="cstat-no" title="statement not covered" >t</span>his._unwrite=null;<span class="cstat-no" title="statement not covered" >t</span>his._unread=null;<span class="cstat-no" title="statement not covered" >t</span>his._ended=false;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=false;<span class="cstat-no" title="statement not covered" >i</span>f(writable)<span class="cstat-no" title="statement not covered" >this.setWritable(writable);<span class="cstat-no" title="statement not covered" >i</span></span>f(readable)<span class="cstat-no" title="statement not covered" >this.setReadable(readable)}</span></span>;inherits(Duplexify,stream.Duplex);Duplexify.obj=<span class="fstat-no" title="function not covered" >function(writable,readable,opts){<span class="cstat-no" title="statement not covered" ></span>if(!opts)<span class="cstat-no" title="statement not covered" >opts={};<span class="cstat-no" title="statement not covered" >o</span></span>pts.objectMode=true;<span class="cstat-no" title="statement not covered" >o</span>pts.highWaterMark=16;<span class="cstat-no" title="statement not covered" >r</span>eturn new Duplexify(writable,readable,opts)}</span>;Duplexify.prototype.cork=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(++this._corked===1)<span class="cstat-no" title="statement not covered" >this.emit("cork")}</span></span>;Duplexify.prototype.uncork=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this._corked&amp;&amp;--this._corked===0)<span class="cstat-no" title="statement not covered" >this.emit("uncork")}</span></span>;Duplexify.prototype.setWritable=<span class="fstat-no" title="function not covered" >function(writable){<span class="cstat-no" title="statement not covered" ></span>if(this._unwrite)<span class="cstat-no" title="statement not covered" >this._unwrite();<span class="cstat-no" title="statement not covered" >i</span></span>f(this.destroyed){<span class="cstat-no" title="statement not covered" >if(writable&amp;&amp;writable.destroy)<span class="cstat-no" title="statement not covered" >writable.destroy();<span class="cstat-no" title="statement not covered" >r</span></span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(writable===null||writable===false){<span class="cstat-no" title="statement not covered" >this.end();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>v</span>ar self=this;<span class="cstat-no" title="statement not covered" >v</span>ar unend=eos(writable,{writable:true,readable:false},destroyer(this,this._forwardEnd));<span class="cstat-no" title="statement not covered" >v</span>ar ondrain=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var ondrain=self._ondrain;<span class="cstat-no" title="statement not covered" >s</span>elf._ondrain=null;<span class="cstat-no" title="statement not covered" >i</span>f(ondrain)<span class="cstat-no" title="statement not covered" >ondrain()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar clear=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>self._writable.removeListener("drain",ondrain);<span class="cstat-no" title="statement not covered" >u</span>nend()}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(this._unwrite)<span class="cstat-no" title="statement not covered" >process.nextTick(ondrain);<span class="cstat-no" title="statement not covered" >t</span></span>his._writable=writable;<span class="cstat-no" title="statement not covered" >t</span>his._writable.on("drain",ondrain);<span class="cstat-no" title="statement not covered" >t</span>his._unwrite=clear;<span class="cstat-no" title="statement not covered" >t</span>his.uncork()}</span>;Duplexify.prototype.setReadable=<span class="fstat-no" title="function not covered" >function(readable){<span class="cstat-no" title="statement not covered" ></span>if(this._unread)<span class="cstat-no" title="statement not covered" >this._unread();<span class="cstat-no" title="statement not covered" >i</span></span>f(this.destroyed){<span class="cstat-no" title="statement not covered" >if(readable&amp;&amp;readable.destroy)<span class="cstat-no" title="statement not covered" >readable.destroy();<span class="cstat-no" title="statement not covered" >r</span></span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(readable===null||readable===false){<span class="cstat-no" title="statement not covered" >this.push(null);<span class="cstat-no" title="statement not covered" >t</span>his.resume();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>v</span>ar self=this;<span class="cstat-no" title="statement not covered" >v</span>ar unend=eos(readable,{writable:false,readable:true},destroyer(this));<span class="cstat-no" title="statement not covered" >v</span>ar onreadable=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>self._forward()}</span>;<span class="cstat-no" title="statement not covered" >v</span>ar onend=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>self.push(null)}</span>;<span class="cstat-no" title="statement not covered" >v</span>ar clear=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>self._readable2.removeListener("readable",onreadable);<span class="cstat-no" title="statement not covered" >s</span>elf._readable2.removeListener("end",onend);<span class="cstat-no" title="statement not covered" >u</span>nend()}</span>;<span class="cstat-no" title="statement not covered" >t</span>his._drained=true;<span class="cstat-no" title="statement not covered" >t</span>his._readable=readable;<span class="cstat-no" title="statement not covered" >t</span>his._readable2=readable._readableState?readable:toStreams2(readable);<span class="cstat-no" title="statement not covered" >t</span>his._readable2.on("readable",onreadable);<span class="cstat-no" title="statement not covered" >t</span>his._readable2.on("end",onend);<span class="cstat-no" title="statement not covered" >t</span>his._unread=clear;<span class="cstat-no" title="statement not covered" >t</span>his._forward()}</span>;Duplexify.prototype._read=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._drained=true;<span class="cstat-no" title="statement not covered" >t</span>his._forward()}</span>;Duplexify.prototype._forward=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this._forwarding||!this._readable2||!this._drained)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._forwarding=true;<span class="cstat-no" title="statement not covered" >v</span>ar data;<span class="cstat-no" title="statement not covered" >w</span>hile(this._drained&amp;&amp;(data=shift(this._readable2))!==null){<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span></span>his._drained=this.push(data)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._forwarding=false}</span>;Duplexify.prototype.destroy=<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>if(this.destroyed)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.destroyed=true;<span class="cstat-no" title="statement not covered" >v</span>ar self=this;<span class="cstat-no" title="statement not covered" >p</span>rocess.nextTick(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>self._destroy(err)}</span>)}</span>;Duplexify.prototype._destroy=<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>if(err){<span class="cstat-no" title="statement not covered" >var ondrain=this._ondrain;<span class="cstat-no" title="statement not covered" >t</span>his._ondrain=null;<span class="cstat-no" title="statement not covered" >i</span>f(ondrain)<span class="cstat-no" title="statement not covered" >ondrain(err);e</span>lse <span class="cstat-no" title="statement not covered" >this.emit("error",err)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(this._forwardDestroy){<span class="cstat-no" title="statement not covered" >if(this._readable&amp;&amp;this._readable.destroy)<span class="cstat-no" title="statement not covered" >this._readable.destroy();<span class="cstat-no" title="statement not covered" >i</span></span>f(this._writable&amp;&amp;this._writable.destroy)<span class="cstat-no" title="statement not covered" >this._writable.destroy()}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.emit("close")}</span>;Duplexify.prototype._write=<span class="fstat-no" title="function not covered" >function(data,enc,cb){<span class="cstat-no" title="statement not covered" ></span>if(this.destroyed)<span class="cstat-no" title="statement not covered" >return cb();<span class="cstat-no" title="statement not covered" >i</span></span>f(this._corked)<span class="cstat-no" title="statement not covered" >return onuncork(this,this._write.bind(this,data,enc,cb));<span class="cstat-no" title="statement not covered" >i</span></span>f(data===SIGNAL_FLUSH)<span class="cstat-no" title="statement not covered" >return this._finish(cb);<span class="cstat-no" title="statement not covered" >i</span></span>f(!this._writable)<span class="cstat-no" title="statement not covered" >return cb();<span class="cstat-no" title="statement not covered" >i</span></span>f(this._writable.write(data)===false)<span class="cstat-no" title="statement not covered" >this._ondrain=cb;e</span>lse <span class="cstat-no" title="statement not covered" >cb()}</span></span>;Duplexify.prototype._finish=<span class="fstat-no" title="function not covered" >function(cb){<span class="cstat-no" title="statement not covered" ></span>var self=this;<span class="cstat-no" title="statement not covered" >t</span>his.emit("preend");<span class="cstat-no" title="statement not covered" >o</span>nuncork(this,<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>end(self._forwardEnd&amp;&amp;self._writable,<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(self._writableState.prefinished===false)<span class="cstat-no" title="statement not covered" >self._writableState.prefinished=true;<span class="cstat-no" title="statement not covered" >s</span></span>elf.emit("prefinish");<span class="cstat-no" title="statement not covered" >o</span>nuncork(self,cb)}</span>)}</span>)}</span>;Duplexify.prototype.end=<span class="fstat-no" title="function not covered" >function(data,enc,cb){<span class="cstat-no" title="statement not covered" ></span>if(typeof data==="function")<span class="cstat-no" title="statement not covered" >return this.end(null,null,data);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof enc==="function")<span class="cstat-no" title="statement not covered" >return this.end(data,null,enc);<span class="cstat-no" title="statement not covered" >t</span></span>his._ended=true;<span class="cstat-no" title="statement not covered" >i</span>f(data)<span class="cstat-no" title="statement not covered" >this.write(data);<span class="cstat-no" title="statement not covered" >i</span></span>f(!this._writableState.ending)<span class="cstat-no" title="statement not covered" >this.write(SIGNAL_FLUSH);<span class="cstat-no" title="statement not covered" >r</span></span>eturn stream.Writable.prototype.end.call(this,cb)}</span>;module.exports=Duplexify}).call(this,require("_process"),require("buffer").Buffer)},{_process:48,buffer:4,"end-of-stream":8,inherits:22,"readable-stream":17,"stream-shift":54}],8:[function(require,module,exports){var once=require("once");var noop=<span class="fstat-no" title="function not covered" >function(){</span>};var isRequest=<span class="fstat-no" title="function not covered" >function(stream){<span class="cstat-no" title="statement not covered" ></span>return stream.setHeader&amp;&amp;typeof stream.abort==="function"}</span>;var eos=<span class="fstat-no" title="function not covered" >function(stream,opts,callback){<span class="cstat-no" title="statement not covered" ></span>if(typeof opts==="function")<span class="cstat-no" title="statement not covered" >return eos(stream,null,opts);<span class="cstat-no" title="statement not covered" >i</span></span>f(!opts)<span class="cstat-no" title="statement not covered" >opts={};<span class="cstat-no" title="statement not covered" >c</span></span>allback=once(callback||noop);<span class="cstat-no" title="statement not covered" >v</span>ar ws=stream._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar rs=stream._readableState;<span class="cstat-no" title="statement not covered" >v</span>ar readable=opts.readable||opts.readable!==false&amp;&amp;stream.readable;<span class="cstat-no" title="statement not covered" >v</span>ar writable=opts.writable||opts.writable!==false&amp;&amp;stream.writable;<span class="cstat-no" title="statement not covered" >v</span>ar onlegacyfinish=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!stream.writable)<span class="cstat-no" title="statement not covered" >onfinish()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onfinish=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>writable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!readable)<span class="cstat-no" title="statement not covered" >callback()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onend=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>readable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!writable)<span class="cstat-no" title="statement not covered" >callback()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onclose=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(readable&amp;&amp;!(rs&amp;&amp;rs.ended))<span class="cstat-no" title="statement not covered" >return callback(new Error("premature close"));<span class="cstat-no" title="statement not covered" >i</span></span>f(writable&amp;&amp;!(ws&amp;&amp;ws.ended))<span class="cstat-no" title="statement not covered" >return callback(new Error("premature close"))}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onrequest=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>stream.req.on("finish",onfinish)}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(isRequest(stream)){<span class="cstat-no" title="statement not covered" >stream.on("complete",onfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.on("abort",onclose);<span class="cstat-no" title="statement not covered" >i</span>f(stream.req)<span class="cstat-no" title="statement not covered" >onrequest();e</span>lse <span class="cstat-no" title="statement not covered" >stream.on("request",onrequest)}</span></span>else <span class="cstat-no" title="statement not covered" >if(writable&amp;&amp;!ws){<span class="cstat-no" title="statement not covered" >stream.on("end",onlegacyfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.on("close",onlegacyfinish)}<span class="cstat-no" title="statement not covered" ></span>s</span></span>tream.on("end",onend);<span class="cstat-no" title="statement not covered" >s</span>tream.on("finish",onfinish);<span class="cstat-no" title="statement not covered" >i</span>f(opts.error!==false)<span class="cstat-no" title="statement not covered" >stream.on("error",callback);<span class="cstat-no" title="statement not covered" >s</span></span>tream.on("close",onclose);<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>stream.removeListener("complete",onfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("abort",onclose);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("request",onrequest);<span class="cstat-no" title="statement not covered" >i</span>f(stream.req)<span class="cstat-no" title="statement not covered" >stream.req.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >s</span></span>tream.removeListener("end",onlegacyfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("close",onlegacyfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("end",onend);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("error",callback);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("close",onclose)}</span>}</span>;module.exports=eos},{once:10}],9:[function(require,module,exports){arguments[4][5][0].apply(exports,arguments)},{dup:5}],10:[function(require,module,exports){var wrappy=require("wrappy");module.exports=wrappy(once);once.proto=once(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(Function.prototype,"once",{value:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return once(this)}</span>,configurable:true})}</span>);function once(fn){var f=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(f.called)<span class="cstat-no" title="statement not covered" >return f.value;<span class="cstat-no" title="statement not covered" >f</span></span>.called=true;<span class="cstat-no" title="statement not covered" >r</span>eturn f.value=fn.apply(this,arguments)}</span>;f.called=false;return f}},{wrappy:71}],11:[function(require,module,exports){"use strict";var objectKeys=Object.keys||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>var keys=[];<span class="cstat-no" title="statement not covered" >f</span>or(var key in obj){<span class="cstat-no" title="statement not covered" >keys.push(key)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn keys}</span>;</span>module.exports=Duplex;var processNextTick=require("process-nextick-args");var util=require("core-util-is");util.inherits=require("inherits");var Readable=require("./_stream_readable");var Writable=require("./_stream_writable");util.inherits(Duplex,Readable);var keys=objectKeys(Writable.prototype);for(var v=0;v&lt;keys.length;v++){var method=keys[v];if(!Duplex.prototype[method])Duplex.prototype[method]=Writable.prototype[method]}<span class="fstat-no" title="function not covered" >function Duplex(options){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof Duplex))<span class="cstat-no" title="statement not covered" >return new Duplex(options);<span class="cstat-no" title="statement not covered" >R</span></span>eadable.call(this,options);<span class="cstat-no" title="statement not covered" >W</span>ritable.call(this,options);<span class="cstat-no" title="statement not covered" >i</span>f(options&amp;&amp;options.readable===false)<span class="cstat-no" title="statement not covered" >this.readable=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(options&amp;&amp;options.writable===false)<span class="cstat-no" title="statement not covered" >this.writable=false;<span class="cstat-no" title="statement not covered" >t</span></span>his.allowHalfOpen=true;<span class="cstat-no" title="statement not covered" >i</span>f(options&amp;&amp;options.allowHalfOpen===false)<span class="cstat-no" title="statement not covered" >this.allowHalfOpen=false;<span class="cstat-no" title="statement not covered" >t</span></span>his.once("end",onend)}<span class="fstat-no" title="function not covered" ></span>function onend(){<span class="cstat-no" title="statement not covered" ></span>if(this.allowHalfOpen||this._writableState.ended)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >p</span></span>rocessNextTick(onEndNT,this)}<span class="fstat-no" title="function not covered" ></span>function onEndNT(self){<span class="cstat-no" title="statement not covered" ></span>self.end()}<span class="fstat-no" title="function not covered" ></span>function forEach(xs,f){<span class="cstat-no" title="statement not covered" ></span>for(var i=0,l=xs.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >f(xs[i],i)}</span>}</span>},{"./_stream_readable":13,"./_stream_writable":15,"core-util-is":6,inherits:22,"process-nextick-args":47}],12:[function(require,module,exports){"use strict";module.exports=PassThrough;var Transform=require("./_stream_transform");var util=require("core-util-is");util.inherits=require("inherits");util.inherits(PassThrough,Transform);<span class="fstat-no" title="function not covered" >function PassThrough(options){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof PassThrough))<span class="cstat-no" title="statement not covered" >return new PassThrough(options);<span class="cstat-no" title="statement not covered" >T</span></span>ransform.call(this,options)}</span>PassThrough.prototype._transform=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>cb(null,chunk)}</span>},{"./_stream_transform":14,"core-util-is":6,inherits:22}],13:[function(require,module,exports){(function(process){"use strict";module.exports=Readable;var processNextTick=require("process-nextick-args");var isArray=require("isarray");var Duplex;Readable.ReadableState=ReadableState;var EE=require("events").EventEmitter;var EElistenerCount=<span class="fstat-no" title="function not covered" >function(emitter,type){<span class="cstat-no" title="statement not covered" ></span>return emitter.listeners(type).length}</span>;var Stream;(function(){try{Stream=require("st"+"ream")}catch(_){}finally{<span class="missing-if-branch" title="if path not taken" >I</span>if(!Stream)<span class="cstat-no" title="statement not covered" >Stream=require("events").EventEmitter}</span>})();var Buffer=require("buffer").Buffer;var bufferShim=require("buffer-shims");var util=require("core-util-is");util.inherits=require("inherits");var debugUtil=require("util");var debug=void 0;<span class="missing-if-branch" title="if path not taken" >I</span>if(debugUtil&amp;&amp;debugUtil.debuglog){<span class="cstat-no" title="statement not covered" >debug=debugUtil.debuglog("stream")}</span>else{debug=<span class="fstat-no" title="function not covered" >function(){</span>}}var BufferList=require("./internal/streams/BufferList");var StringDecoder;util.inherits(Readable,Stream);<span class="fstat-no" title="function not covered" >function prependListener(emitter,event,fn){<span class="cstat-no" title="statement not covered" ></span>if(typeof emitter.prependListener==="function"){<span class="cstat-no" title="statement not covered" >return emitter.prependListener(event,fn)}</span>else{<span class="cstat-no" title="statement not covered" >if(!emitter._events||!emitter._events[event])<span class="cstat-no" title="statement not covered" >emitter.on(event,fn);e</span>lse <span class="cstat-no" title="statement not covered" >if(isArray(emitter._events[event]))<span class="cstat-no" title="statement not covered" >emitter._events[event].unshift(fn);e</span>lse <span class="cstat-no" title="statement not covered" >emitter._events[event]=[fn,emitter._events[event]]}</span></span></span>}<span class="fstat-no" title="function not covered" ></span>function ReadableState(options,stream){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >o</span>ptions=options||{};<span class="cstat-no" title="statement not covered" >t</span>his.objectMode=!!options.objectMode;<span class="cstat-no" title="statement not covered" >i</span>f(stream instanceof Duplex)<span class="cstat-no" title="statement not covered" >this.objectMode=this.objectMode||!!options.readableObjectMode;<span class="cstat-no" title="statement not covered" >v</span></span>ar hwm=options.highWaterMark;<span class="cstat-no" title="statement not covered" >v</span>ar defaultHwm=this.objectMode?16:16*1024;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=hwm||hwm===0?hwm:defaultHwm;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=~~this.highWaterMark;<span class="cstat-no" title="statement not covered" >t</span>his.buffer=new BufferList;<span class="cstat-no" title="statement not covered" >t</span>his.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.pipes=null;<span class="cstat-no" title="statement not covered" >t</span>his.pipesCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.flowing=null;<span class="cstat-no" title="statement not covered" >t</span>his.ended=false;<span class="cstat-no" title="statement not covered" >t</span>his.endEmitted=false;<span class="cstat-no" title="statement not covered" >t</span>his.reading=false;<span class="cstat-no" title="statement not covered" >t</span>his.sync=true;<span class="cstat-no" title="statement not covered" >t</span>his.needReadable=false;<span class="cstat-no" title="statement not covered" >t</span>his.emittedReadable=false;<span class="cstat-no" title="statement not covered" >t</span>his.readableListening=false;<span class="cstat-no" title="statement not covered" >t</span>his.resumeScheduled=false;<span class="cstat-no" title="statement not covered" >t</span>his.defaultEncoding=options.defaultEncoding||"utf8";<span class="cstat-no" title="statement not covered" >t</span>his.ranOut=false;<span class="cstat-no" title="statement not covered" >t</span>his.awaitDrain=0;<span class="cstat-no" title="statement not covered" >t</span>his.readingMore=false;<span class="cstat-no" title="statement not covered" >t</span>his.decoder=null;<span class="cstat-no" title="statement not covered" >t</span>his.encoding=null;<span class="cstat-no" title="statement not covered" >i</span>f(options.encoding){<span class="cstat-no" title="statement not covered" >if(!StringDecoder)<span class="cstat-no" title="statement not covered" >StringDecoder=require("string_decoder/").StringDecoder;<span class="cstat-no" title="statement not covered" >t</span></span>his.decoder=new StringDecoder(options.encoding);<span class="cstat-no" title="statement not covered" >t</span>his.encoding=options.encoding}</span>}<span class="fstat-no" title="function not covered" ></span>function Readable(options){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >i</span>f(!(this instanceof Readable))<span class="cstat-no" title="statement not covered" >return new Readable(options);<span class="cstat-no" title="statement not covered" >t</span></span>his._readableState=new ReadableState(options,this);<span class="cstat-no" title="statement not covered" >t</span>his.readable=true;<span class="cstat-no" title="statement not covered" >i</span>f(options&amp;&amp;typeof options.read==="function")<span class="cstat-no" title="statement not covered" >this._read=options.read;<span class="cstat-no" title="statement not covered" >S</span></span>tream.call(this)}</span>Readable.prototype.push=<span class="fstat-no" title="function not covered" >function(chunk,encoding){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!state.objectMode&amp;&amp;typeof chunk==="string"){<span class="cstat-no" title="statement not covered" >encoding=encoding||state.defaultEncoding;<span class="cstat-no" title="statement not covered" >i</span>f(encoding!==state.encoding){<span class="cstat-no" title="statement not covered" >chunk=bufferShim.from(chunk,encoding);<span class="cstat-no" title="statement not covered" >e</span>ncoding=""}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn readableAddChunk(this,state,chunk,encoding,false)}</span>;Readable.prototype.unshift=<span class="fstat-no" title="function not covered" >function(chunk){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >r</span>eturn readableAddChunk(this,state,chunk,"",true)}</span>;Readable.prototype.isPaused=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._readableState.flowing===false}</span>;<span class="fstat-no" title="function not covered" >function readableAddChunk(stream,state,chunk,encoding,addToFront){<span class="cstat-no" title="statement not covered" ></span>var er=chunkInvalid(state,chunk);<span class="cstat-no" title="statement not covered" >i</span>f(er){<span class="cstat-no" title="statement not covered" >stream.emit("error",er)}</span>else <span class="cstat-no" title="statement not covered" >if(chunk===null){<span class="cstat-no" title="statement not covered" >state.reading=false;<span class="cstat-no" title="statement not covered" >o</span>nEofChunk(stream,state)}</span>else <span class="cstat-no" title="statement not covered" >if(state.objectMode||chunk&amp;&amp;chunk.length&gt;0){<span class="cstat-no" title="statement not covered" >if(state.ended&amp;&amp;!addToFront){<span class="cstat-no" title="statement not covered" >var e=new Error("stream.push() after EOF");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",e)}</span>else <span class="cstat-no" title="statement not covered" >if(state.endEmitted&amp;&amp;addToFront){<span class="cstat-no" title="statement not covered" >var _e=new Error("stream.unshift() after end event");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",_e)}</span>else{<span class="cstat-no" title="statement not covered" >var skipAdd;<span class="cstat-no" title="statement not covered" >i</span>f(state.decoder&amp;&amp;!addToFront&amp;&amp;!encoding){<span class="cstat-no" title="statement not covered" >chunk=state.decoder.write(chunk);<span class="cstat-no" title="statement not covered" >s</span>kipAdd=!state.objectMode&amp;&amp;chunk.length===0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!addToFront)<span class="cstat-no" title="statement not covered" >state.reading=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(!skipAdd){<span class="cstat-no" title="statement not covered" >if(state.flowing&amp;&amp;state.length===0&amp;&amp;!state.sync){<span class="cstat-no" title="statement not covered" >stream.emit("data",chunk);<span class="cstat-no" title="statement not covered" >s</span>tream.read(0)}</span>else{<span class="cstat-no" title="statement not covered" >state.length+=state.objectMode?1:chunk.length;<span class="cstat-no" title="statement not covered" >i</span>f(addToFront)<span class="cstat-no" title="statement not covered" >state.buffer.unshift(chunk);e</span>lse <span class="cstat-no" title="statement not covered" >state.buffer.push(chunk);<span class="cstat-no" title="statement not covered" >i</span></span>f(state.needReadable)<span class="cstat-no" title="statement not covered" >emitReadable(stream)}</span></span>}<span class="cstat-no" title="statement not covered" ></span>m</span>aybeReadMore(stream,state)}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >if(!addToFront){<span class="cstat-no" title="statement not covered" >state.reading=false}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn needMoreData(state)}<span class="fstat-no" title="function not covered" ></span>function needMoreData(state){<span class="cstat-no" title="statement not covered" ></span>return!state.ended&amp;&amp;(state.needReadable||state.length&lt;state.highWaterMark||state.length===0)}</span>Readable.prototype.setEncoding=<span class="fstat-no" title="function not covered" >function(enc){<span class="cstat-no" title="statement not covered" ></span>if(!StringDecoder)<span class="cstat-no" title="statement not covered" >StringDecoder=require("string_decoder/").StringDecoder;<span class="cstat-no" title="statement not covered" >t</span></span>his._readableState.decoder=new StringDecoder(enc);<span class="cstat-no" title="statement not covered" >t</span>his._readableState.encoding=enc;<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;var MAX_HWM=8388608;<span class="fstat-no" title="function not covered" >function computeNewHighWaterMark(n){<span class="cstat-no" title="statement not covered" ></span>if(n&gt;=MAX_HWM){<span class="cstat-no" title="statement not covered" >n=MAX_HWM}</span>else{<span class="cstat-no" title="statement not covered" >n--;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;2;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;4;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >n</span>++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>function howMuchToRead(n,state){<span class="cstat-no" title="statement not covered" ></span>if(n&lt;=0||state.length===0&amp;&amp;state.ended)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.objectMode)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n!==n){<span class="cstat-no" title="statement not covered" >if(state.flowing&amp;&amp;state.length)<span class="cstat-no" title="statement not covered" >return state.buffer.head.data.length;e</span>lse <span class="cstat-no" title="statement not covered" >return state.length}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(n&gt;state.highWaterMark)<span class="cstat-no" title="statement not covered" >state.highWaterMark=computeNewHighWaterMark(n);<span class="cstat-no" title="statement not covered" >i</span></span>f(n&lt;=state.length)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f(!state.ended){<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >r</span>eturn 0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn state.length}</span>Readable.prototype.read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>debug("read",n);<span class="cstat-no" title="statement not covered" >n</span>=parseInt(n,10);<span class="cstat-no" title="statement not covered" >v</span>ar state=this._readableState;<span class="cstat-no" title="statement not covered" >v</span>ar nOrig=n;<span class="cstat-no" title="statement not covered" >i</span>f(n!==0)<span class="cstat-no" title="statement not covered" >state.emittedReadable=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(n===0&amp;&amp;state.needReadable&amp;&amp;(state.length&gt;=state.highWaterMark||state.ended)){<span class="cstat-no" title="statement not covered" >debug("read: emitReadable",state.length,state.ended);<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0&amp;&amp;state.ended)<span class="cstat-no" title="statement not covered" >endReadable(this);e</span>lse <span class="cstat-no" title="statement not covered" >emitReadable(this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn null}<span class="cstat-no" title="statement not covered" ></span>n</span>=howMuchToRead(n,state);<span class="cstat-no" title="statement not covered" >i</span>f(n===0&amp;&amp;state.ended){<span class="cstat-no" title="statement not covered" >if(state.length===0)<span class="cstat-no" title="statement not covered" >endReadable(this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn null}<span class="cstat-no" title="statement not covered" ></span>v</span>ar doRead=state.needReadable;<span class="cstat-no" title="statement not covered" >d</span>ebug("need readable",doRead);<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0||state.length-n&lt;state.highWaterMark){<span class="cstat-no" title="statement not covered" >doRead=true;<span class="cstat-no" title="statement not covered" >d</span>ebug("length less than watermark",doRead)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(state.ended||state.reading){<span class="cstat-no" title="statement not covered" >doRead=false;<span class="cstat-no" title="statement not covered" >d</span>ebug("reading or ended",doRead)}</span>else <span class="cstat-no" title="statement not covered" >if(doRead){<span class="cstat-no" title="statement not covered" >debug("do read");<span class="cstat-no" title="statement not covered" >s</span>tate.reading=true;<span class="cstat-no" title="statement not covered" >s</span>tate.sync=true;<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0)<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >t</span></span>his._read(state.highWaterMark);<span class="cstat-no" title="statement not covered" >s</span>tate.sync=false;<span class="cstat-no" title="statement not covered" >i</span>f(!state.reading)<span class="cstat-no" title="statement not covered" >n=howMuchToRead(nOrig,state)}<span class="cstat-no" title="statement not covered" ></span></span>v</span></span>ar ret;<span class="cstat-no" title="statement not covered" >i</span>f(n&gt;0)<span class="cstat-no" title="statement not covered" >ret=fromList(n,state);e</span>lse <span class="cstat-no" title="statement not covered" >ret=null;<span class="cstat-no" title="statement not covered" >i</span></span>f(ret===null){<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >n</span>=0}</span>else{<span class="cstat-no" title="statement not covered" >state.length-=n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(state.length===0){<span class="cstat-no" title="statement not covered" >if(!state.ended)<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(nOrig!==n&amp;&amp;state.ended)<span class="cstat-no" title="statement not covered" >endReadable(this)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(ret!==null)<span class="cstat-no" title="statement not covered" >this.emit("data",ret);<span class="cstat-no" title="statement not covered" >r</span></span>eturn ret}</span>;<span class="fstat-no" title="function not covered" >function chunkInvalid(state,chunk){<span class="cstat-no" title="statement not covered" ></span>var er=null;<span class="cstat-no" title="statement not covered" >i</span>f(!Buffer.isBuffer(chunk)&amp;&amp;typeof chunk!=="string"&amp;&amp;chunk!==null&amp;&amp;chunk!==undefined&amp;&amp;!state.objectMode){<span class="cstat-no" title="statement not covered" >er=new TypeError("Invalid non-string/buffer chunk")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn er}<span class="fstat-no" title="function not covered" ></span>function onEofChunk(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(state.ended)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.decoder){<span class="cstat-no" title="statement not covered" >var chunk=state.decoder.end();<span class="cstat-no" title="statement not covered" >i</span>f(chunk&amp;&amp;chunk.length){<span class="cstat-no" title="statement not covered" >state.buffer.push(chunk);<span class="cstat-no" title="statement not covered" >s</span>tate.length+=state.objectMode?1:chunk.length}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.ended=true;<span class="cstat-no" title="statement not covered" >e</span>mitReadable(stream)}<span class="fstat-no" title="function not covered" ></span>function emitReadable(stream){<span class="cstat-no" title="statement not covered" ></span>var state=stream._readableState;<span class="cstat-no" title="statement not covered" >s</span>tate.needReadable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!state.emittedReadable){<span class="cstat-no" title="statement not covered" >debug("emitReadable",state.flowing);<span class="cstat-no" title="statement not covered" >s</span>tate.emittedReadable=true;<span class="cstat-no" title="statement not covered" >i</span>f(state.sync)<span class="cstat-no" title="statement not covered" >processNextTick(emitReadable_,stream);e</span>lse <span class="cstat-no" title="statement not covered" >emitReadable_(stream)}</span></span>}<span class="fstat-no" title="function not covered" ></span>function emitReadable_(stream){<span class="cstat-no" title="statement not covered" ></span>debug("emit readable");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("readable");<span class="cstat-no" title="statement not covered" >f</span>low(stream)}<span class="fstat-no" title="function not covered" ></span>function maybeReadMore(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.readingMore){<span class="cstat-no" title="statement not covered" >state.readingMore=true;<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(maybeReadMore_,stream,state)}</span>}<span class="fstat-no" title="function not covered" ></span>function maybeReadMore_(stream,state){<span class="cstat-no" title="statement not covered" ></span>var len=state.length;<span class="cstat-no" title="statement not covered" >w</span>hile(!state.reading&amp;&amp;!state.flowing&amp;&amp;!state.ended&amp;&amp;state.length&lt;state.highWaterMark){<span class="cstat-no" title="statement not covered" >debug("maybeReadMore read 0");<span class="cstat-no" title="statement not covered" >s</span>tream.read(0);<span class="cstat-no" title="statement not covered" >i</span>f(len===state.length)<span class="cstat-no" title="statement not covered" >break;e</span>lse <span class="cstat-no" title="statement not covered" >len=state.length}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tate.readingMore=false}</span>Readable.prototype._read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>this.emit("error",new Error("_read() is not implemented"))}</span>;Readable.prototype.pipe=<span class="fstat-no" title="function not covered" >function(dest,pipeOpts){<span class="cstat-no" title="statement not covered" ></span>var src=this;<span class="cstat-no" title="statement not covered" >v</span>ar state=this._readableState;<span class="cstat-no" title="statement not covered" >s</span>witch(state.pipesCount){case 0:<span class="cstat-no" title="statement not covered" >state.pipes=dest;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >state.pipes=[state.pipes,dest];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >state.pipes.push(dest);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.pipesCount+=1;<span class="cstat-no" title="statement not covered" >d</span>ebug("pipe count=%d opts=%j",state.pipesCount,pipeOpts);<span class="cstat-no" title="statement not covered" >v</span>ar doEnd=(!pipeOpts||pipeOpts.end!==false)&amp;&amp;dest!==process.stdout&amp;&amp;dest!==process.stderr;<span class="cstat-no" title="statement not covered" >v</span>ar endFn=doEnd?onend:cleanup;<span class="cstat-no" title="statement not covered" >i</span>f(state.endEmitted)<span class="cstat-no" title="statement not covered" >processNextTick(endFn);e</span>lse <span class="cstat-no" title="statement not covered" >src.once("end",endFn);<span class="cstat-no" title="statement not covered" >d</span></span>est.on("unpipe",onunpipe);<span class="fstat-no" title="function not covered" >f</span>unction onunpipe(readable){<span class="cstat-no" title="statement not covered" ></span>debug("onunpipe");<span class="cstat-no" title="statement not covered" >i</span>f(readable===src){<span class="cstat-no" title="statement not covered" >cleanup()}</span>}<span class="fstat-no" title="function not covered" ></span>function onend(){<span class="cstat-no" title="statement not covered" ></span>debug("onend");<span class="cstat-no" title="statement not covered" >d</span>est.end()}<span class="cstat-no" title="statement not covered" ></span>var ondrain=pipeOnDrain(src);<span class="cstat-no" title="statement not covered" >d</span>est.on("drain",ondrain);<span class="cstat-no" title="statement not covered" >v</span>ar cleanedUp=false;<span class="fstat-no" title="function not covered" >f</span>unction cleanup(){<span class="cstat-no" title="statement not covered" ></span>debug("cleanup");<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("close",onclose);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("drain",ondrain);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("error",onerror);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("unpipe",onunpipe);<span class="cstat-no" title="statement not covered" >s</span>rc.removeListener("end",onend);<span class="cstat-no" title="statement not covered" >s</span>rc.removeListener("end",cleanup);<span class="cstat-no" title="statement not covered" >s</span>rc.removeListener("data",ondata);<span class="cstat-no" title="statement not covered" >c</span>leanedUp=true;<span class="cstat-no" title="statement not covered" >i</span>f(state.awaitDrain&amp;&amp;(!dest._writableState||dest._writableState.needDrain))<span class="cstat-no" title="statement not covered" >ondrain()}<span class="cstat-no" title="statement not covered" ></span></span>var increasedAwaitDrain=false;<span class="cstat-no" title="statement not covered" >s</span>rc.on("data",ondata);<span class="fstat-no" title="function not covered" >f</span>unction ondata(chunk){<span class="cstat-no" title="statement not covered" ></span>debug("ondata");<span class="cstat-no" title="statement not covered" >i</span>ncreasedAwaitDrain=false;<span class="cstat-no" title="statement not covered" >v</span>ar ret=dest.write(chunk);<span class="cstat-no" title="statement not covered" >i</span>f(false===ret&amp;&amp;!increasedAwaitDrain){<span class="cstat-no" title="statement not covered" >if((state.pipesCount===1&amp;&amp;state.pipes===dest||state.pipesCount&gt;1&amp;&amp;indexOf(state.pipes,dest)!==-1)&amp;&amp;!cleanedUp){<span class="cstat-no" title="statement not covered" >debug("false write response, pause",src._readableState.awaitDrain);<span class="cstat-no" title="statement not covered" >s</span>rc._readableState.awaitDrain++;<span class="cstat-no" title="statement not covered" >i</span>ncreasedAwaitDrain=true}<span class="cstat-no" title="statement not covered" ></span>s</span>rc.pause()}</span>}<span class="fstat-no" title="function not covered" ></span>function onerror(er){<span class="cstat-no" title="statement not covered" ></span>debug("onerror",er);<span class="cstat-no" title="statement not covered" >u</span>npipe();<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("error",onerror);<span class="cstat-no" title="statement not covered" >i</span>f(EElistenerCount(dest,"error")===0)<span class="cstat-no" title="statement not covered" >dest.emit("error",er)}<span class="cstat-no" title="statement not covered" ></span></span>prependListener(dest,"error",onerror);<span class="fstat-no" title="function not covered" >f</span>unction onclose(){<span class="cstat-no" title="statement not covered" ></span>dest.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >u</span>npipe()}<span class="cstat-no" title="statement not covered" ></span>dest.once("close",onclose);<span class="fstat-no" title="function not covered" >f</span>unction onfinish(){<span class="cstat-no" title="statement not covered" ></span>debug("onfinish");<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("close",onclose);<span class="cstat-no" title="statement not covered" >u</span>npipe()}<span class="cstat-no" title="statement not covered" ></span>dest.once("finish",onfinish);<span class="fstat-no" title="function not covered" >f</span>unction unpipe(){<span class="cstat-no" title="statement not covered" ></span>debug("unpipe");<span class="cstat-no" title="statement not covered" >s</span>rc.unpipe(dest)}<span class="cstat-no" title="statement not covered" ></span>dest.emit("pipe",src);<span class="cstat-no" title="statement not covered" >i</span>f(!state.flowing){<span class="cstat-no" title="statement not covered" >debug("pipe resume");<span class="cstat-no" title="statement not covered" >s</span>rc.resume()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn dest}</span>;<span class="fstat-no" title="function not covered" >function pipeOnDrain(src){<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=src._readableState;<span class="cstat-no" title="statement not covered" >d</span>ebug("pipeOnDrain",state.awaitDrain);<span class="cstat-no" title="statement not covered" >i</span>f(state.awaitDrain)<span class="cstat-no" title="statement not covered" >state.awaitDrain--;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.awaitDrain===0&amp;&amp;EElistenerCount(src,"data")){<span class="cstat-no" title="statement not covered" >state.flowing=true;<span class="cstat-no" title="statement not covered" >f</span>low(src)}</span>}</span>}</span>Readable.prototype.unpipe=<span class="fstat-no" title="function not covered" >function(dest){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(state.pipesCount===0)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.pipesCount===1){<span class="cstat-no" title="statement not covered" >if(dest&amp;&amp;dest!==state.pipes)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(!dest)<span class="cstat-no" title="statement not covered" >dest=state.pipes;<span class="cstat-no" title="statement not covered" >s</span></span>tate.pipes=null;<span class="cstat-no" title="statement not covered" >s</span>tate.pipesCount=0;<span class="cstat-no" title="statement not covered" >s</span>tate.flowing=false;<span class="cstat-no" title="statement not covered" >i</span>f(dest)<span class="cstat-no" title="statement not covered" >dest.emit("unpipe",this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!dest){<span class="cstat-no" title="statement not covered" >var dests=state.pipes;<span class="cstat-no" title="statement not covered" >v</span>ar len=state.pipesCount;<span class="cstat-no" title="statement not covered" >s</span>tate.pipes=null;<span class="cstat-no" title="statement not covered" >s</span>tate.pipesCount=0;<span class="cstat-no" title="statement not covered" >s</span>tate.flowing=false;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;len;i++){<span class="cstat-no" title="statement not covered" >dests[i].emit("unpipe",this)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}<span class="cstat-no" title="statement not covered" ></span>v</span>ar index=indexOf(state.pipes,dest);<span class="cstat-no" title="statement not covered" >i</span>f(index===-1)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >s</span></span>tate.pipes.splice(index,1);<span class="cstat-no" title="statement not covered" >s</span>tate.pipesCount-=1;<span class="cstat-no" title="statement not covered" >i</span>f(state.pipesCount===1)<span class="cstat-no" title="statement not covered" >state.pipes=state.pipes[0];<span class="cstat-no" title="statement not covered" >d</span></span>est.emit("unpipe",this);<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;Readable.prototype.on=<span class="fstat-no" title="function not covered" >function(ev,fn){<span class="cstat-no" title="statement not covered" ></span>var res=Stream.prototype.on.call(this,ev,fn);<span class="cstat-no" title="statement not covered" >i</span>f(ev==="data"){<span class="cstat-no" title="statement not covered" >if(this._readableState.flowing!==false)<span class="cstat-no" title="statement not covered" >this.resume()}</span></span>else <span class="cstat-no" title="statement not covered" >if(ev==="readable"){<span class="cstat-no" title="statement not covered" >var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!state.endEmitted&amp;&amp;!state.readableListening){<span class="cstat-no" title="statement not covered" >state.readableListening=state.needReadable=true;<span class="cstat-no" title="statement not covered" >s</span>tate.emittedReadable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!state.reading){<span class="cstat-no" title="statement not covered" >processNextTick(nReadingNextTick,this)}</span>else <span class="cstat-no" title="statement not covered" >if(state.length){<span class="cstat-no" title="statement not covered" >emitReadable(this,state)}</span>}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn res}</span>;Readable.prototype.addListener=Readable.prototype.on;<span class="fstat-no" title="function not covered" >function nReadingNextTick(self){<span class="cstat-no" title="statement not covered" ></span>debug("readable nexttick read 0");<span class="cstat-no" title="statement not covered" >s</span>elf.read(0)}</span>Readable.prototype.resume=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!state.flowing){<span class="cstat-no" title="statement not covered" >debug("resume");<span class="cstat-no" title="statement not covered" >s</span>tate.flowing=true;<span class="cstat-no" title="statement not covered" >r</span>esume(this,state)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;<span class="fstat-no" title="function not covered" >function resume(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.resumeScheduled){<span class="cstat-no" title="statement not covered" >state.resumeScheduled=true;<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(resume_,stream,state)}</span>}<span class="fstat-no" title="function not covered" ></span>function resume_(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.reading){<span class="cstat-no" title="statement not covered" >debug("resume read 0");<span class="cstat-no" title="statement not covered" >s</span>tream.read(0)}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.resumeScheduled=false;<span class="cstat-no" title="statement not covered" >s</span>tate.awaitDrain=0;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("resume");<span class="cstat-no" title="statement not covered" >f</span>low(stream);<span class="cstat-no" title="statement not covered" >i</span>f(state.flowing&amp;&amp;!state.reading)<span class="cstat-no" title="statement not covered" >stream.read(0)}</span></span>Readable.prototype.pause=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>debug("call pause flowing=%j",this._readableState.flowing);<span class="cstat-no" title="statement not covered" >i</span>f(false!==this._readableState.flowing){<span class="cstat-no" title="statement not covered" >debug("pause");<span class="cstat-no" title="statement not covered" >t</span>his._readableState.flowing=false;<span class="cstat-no" title="statement not covered" >t</span>his.emit("pause")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;<span class="fstat-no" title="function not covered" >function flow(stream){<span class="cstat-no" title="statement not covered" ></span>var state=stream._readableState;<span class="cstat-no" title="statement not covered" >d</span>ebug("flow",state.flowing);<span class="cstat-no" title="statement not covered" >w</span>hile(state.flowing&amp;&amp;stream.read()!==null){}}</span>Readable.prototype.wrap=<span class="fstat-no" title="function not covered" >function(stream){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >v</span>ar paused=false;<span class="cstat-no" title="statement not covered" >v</span>ar self=this;<span class="cstat-no" title="statement not covered" >s</span>tream.on("end",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>debug("wrapped end");<span class="cstat-no" title="statement not covered" >i</span>f(state.decoder&amp;&amp;!state.ended){<span class="cstat-no" title="statement not covered" >var chunk=state.decoder.end();<span class="cstat-no" title="statement not covered" >i</span>f(chunk&amp;&amp;chunk.length)<span class="cstat-no" title="statement not covered" >self.push(chunk)}<span class="cstat-no" title="statement not covered" ></span></span>s</span>elf.push(null)}</span>);<span class="cstat-no" title="statement not covered" >s</span>tream.on("data",<span class="fstat-no" title="function not covered" >function(chunk){<span class="cstat-no" title="statement not covered" ></span>debug("wrapped data");<span class="cstat-no" title="statement not covered" >i</span>f(state.decoder)<span class="cstat-no" title="statement not covered" >chunk=state.decoder.write(chunk);<span class="cstat-no" title="statement not covered" >i</span></span>f(state.objectMode&amp;&amp;(chunk===null||chunk===undefined))<span class="cstat-no" title="statement not covered" >return;e</span>lse <span class="cstat-no" title="statement not covered" >if(!state.objectMode&amp;&amp;(!chunk||!chunk.length))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span></span>ar ret=self.push(chunk);<span class="cstat-no" title="statement not covered" >i</span>f(!ret){<span class="cstat-no" title="statement not covered" >paused=true;<span class="cstat-no" title="statement not covered" >s</span>tream.pause()}</span>}</span>);<span class="cstat-no" title="statement not covered" >f</span>or(var i in stream){<span class="cstat-no" title="statement not covered" >if(this[i]===undefined&amp;&amp;typeof stream[i]==="function"){<span class="cstat-no" title="statement not covered" >this[i]=<span class="fstat-no" title="function not covered" >function(method){<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return stream[method].apply(stream,arguments)}</span>}</span>(i)}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar events=["error","close","destroy","pause","resume"];<span class="cstat-no" title="statement not covered" >f</span>orEach(events,<span class="fstat-no" title="function not covered" >function(ev){<span class="cstat-no" title="statement not covered" ></span>stream.on(ev,self.emit.bind(self,ev))}</span>);<span class="cstat-no" title="statement not covered" >s</span>elf._read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>debug("wrapped _read",n);<span class="cstat-no" title="statement not covered" >i</span>f(paused){<span class="cstat-no" title="statement not covered" >paused=false;<span class="cstat-no" title="statement not covered" >s</span>tream.resume()}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn self}</span>;Readable._fromList=fromList;<span class="fstat-no" title="function not covered" >function fromList(n,state){<span class="cstat-no" title="statement not covered" ></span>if(state.length===0)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >v</span></span>ar ret;<span class="cstat-no" title="statement not covered" >i</span>f(state.objectMode)<span class="cstat-no" title="statement not covered" >ret=state.buffer.shift();e</span>lse <span class="cstat-no" title="statement not covered" >if(!n||n&gt;=state.length){<span class="cstat-no" title="statement not covered" >if(state.decoder)<span class="cstat-no" title="statement not covered" >ret=state.buffer.join("");e</span>lse <span class="cstat-no" title="statement not covered" >if(state.buffer.length===1)<span class="cstat-no" title="statement not covered" >ret=state.buffer.head.data;e</span>lse <span class="cstat-no" title="statement not covered" >ret=state.buffer.concat(state.length);<span class="cstat-no" title="statement not covered" >s</span></span></span>tate.buffer.clear()}</span>else{<span class="cstat-no" title="statement not covered" >ret=fromListPartial(n,state.buffer,state.decoder)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function fromListPartial(n,list,hasStrings){<span class="cstat-no" title="statement not covered" ></span>var ret;<span class="cstat-no" title="statement not covered" >i</span>f(n&lt;list.head.data.length){<span class="cstat-no" title="statement not covered" >ret=list.head.data.slice(0,n);<span class="cstat-no" title="statement not covered" >l</span>ist.head.data=list.head.data.slice(n)}</span>else <span class="cstat-no" title="statement not covered" >if(n===list.head.data.length){<span class="cstat-no" title="statement not covered" >ret=list.shift()}</span>else{<span class="cstat-no" title="statement not covered" >ret=hasStrings?copyFromBufferString(n,list):copyFromBuffer(n,list)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function copyFromBufferString(n,list){<span class="cstat-no" title="statement not covered" ></span>var p=list.head;<span class="cstat-no" title="statement not covered" >v</span>ar c=1;<span class="cstat-no" title="statement not covered" >v</span>ar ret=p.data;<span class="cstat-no" title="statement not covered" >n</span>-=ret.length;<span class="cstat-no" title="statement not covered" >w</span>hile(p=p.next){<span class="cstat-no" title="statement not covered" >var str=p.data;<span class="cstat-no" title="statement not covered" >v</span>ar nb=n&gt;str.length?str.length:n;<span class="cstat-no" title="statement not covered" >i</span>f(nb===str.length)<span class="cstat-no" title="statement not covered" >ret+=str;e</span>lse <span class="cstat-no" title="statement not covered" >ret+=str.slice(0,n);<span class="cstat-no" title="statement not covered" >n</span></span>-=nb;<span class="cstat-no" title="statement not covered" >i</span>f(n===0){<span class="cstat-no" title="statement not covered" >if(nb===str.length){<span class="cstat-no" title="statement not covered" >++c;<span class="cstat-no" title="statement not covered" >i</span>f(p.next)<span class="cstat-no" title="statement not covered" >list.head=p.next;e</span>lse <span class="cstat-no" title="statement not covered" >list.head=list.tail=null}</span></span>else{<span class="cstat-no" title="statement not covered" >list.head=p;<span class="cstat-no" title="statement not covered" >p</span>.data=str.slice(nb)}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>+</span>+c}<span class="cstat-no" title="statement not covered" ></span>l</span>ist.length-=c;<span class="cstat-no" title="statement not covered" >r</span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function copyFromBuffer(n,list){<span class="cstat-no" title="statement not covered" ></span>var ret=bufferShim.allocUnsafe(n);<span class="cstat-no" title="statement not covered" >v</span>ar p=list.head;<span class="cstat-no" title="statement not covered" >v</span>ar c=1;<span class="cstat-no" title="statement not covered" >p</span>.data.copy(ret);<span class="cstat-no" title="statement not covered" >n</span>-=p.data.length;<span class="cstat-no" title="statement not covered" >w</span>hile(p=p.next){<span class="cstat-no" title="statement not covered" >var buf=p.data;<span class="cstat-no" title="statement not covered" >v</span>ar nb=n&gt;buf.length?buf.length:n;<span class="cstat-no" title="statement not covered" >b</span>uf.copy(ret,ret.length-n,0,nb);<span class="cstat-no" title="statement not covered" >n</span>-=nb;<span class="cstat-no" title="statement not covered" >i</span>f(n===0){<span class="cstat-no" title="statement not covered" >if(nb===buf.length){<span class="cstat-no" title="statement not covered" >++c;<span class="cstat-no" title="statement not covered" >i</span>f(p.next)<span class="cstat-no" title="statement not covered" >list.head=p.next;e</span>lse <span class="cstat-no" title="statement not covered" >list.head=list.tail=null}</span></span>else{<span class="cstat-no" title="statement not covered" >list.head=p;<span class="cstat-no" title="statement not covered" >p</span>.data=buf.slice(nb)}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>+</span>+c}<span class="cstat-no" title="statement not covered" ></span>l</span>ist.length-=c;<span class="cstat-no" title="statement not covered" >r</span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function endReadable(stream){<span class="cstat-no" title="statement not covered" ></span>var state=stream._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(state.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new Error('"endReadable()" called on non-empty stream');<span class="cstat-no" title="statement not covered" >i</span></span>f(!state.endEmitted){<span class="cstat-no" title="statement not covered" >state.ended=true;<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(endReadableNT,state,stream)}</span>}<span class="fstat-no" title="function not covered" ></span>function endReadableNT(state,stream){<span class="cstat-no" title="statement not covered" ></span>if(!state.endEmitted&amp;&amp;state.length===0){<span class="cstat-no" title="statement not covered" >state.endEmitted=true;<span class="cstat-no" title="statement not covered" >s</span>tream.readable=false;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("end")}</span>}<span class="fstat-no" title="function not covered" ></span>function forEach(xs,f){<span class="cstat-no" title="statement not covered" ></span>for(var i=0,l=xs.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >f(xs[i],i)}</span>}<span class="fstat-no" title="function not covered" ></span>function indexOf(xs,x){<span class="cstat-no" title="statement not covered" ></span>for(var i=0,l=xs.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >if(xs[i]===x)<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn-1}</span>}).call(this,require("_process"))},{"./_stream_duplex":11,"./internal/streams/BufferList":16,_process:48,buffer:4,"buffer-shims":3,"core-util-is":6,events:20,inherits:22,isarray:9,"process-nextick-args":47,"string_decoder/":55,util:2}],14:[function(require,module,exports){"use strict";module.exports=Transform;var Duplex=require("./_stream_duplex");var util=require("core-util-is");util.inherits=require("inherits");util.inherits(Transform,Duplex);<span class="fstat-no" title="function not covered" >function TransformState(stream){<span class="cstat-no" title="statement not covered" ></span>this.afterTransform=<span class="fstat-no" title="function not covered" >function(er,data){</span></span>
<span class="cstat-no" title="statement not covered" >return afterTransform(stream,er,data)}</span>;<span class="cstat-no" title="statement not covered" >this.needTransform=false;<span class="cstat-no" title="statement not covered" >t</span>his.transforming=false;<span class="cstat-no" title="statement not covered" >t</span>his.writecb=null;<span class="cstat-no" title="statement not covered" >t</span>his.writechunk=null;<span class="cstat-no" title="statement not covered" >t</span>his.writeencoding=null}<span class="fstat-no" title="function not covered" ></span>function afterTransform(stream,er,data){<span class="cstat-no" title="statement not covered" ></span>var ts=stream._transformState;<span class="cstat-no" title="statement not covered" >t</span>s.transforming=false;<span class="cstat-no" title="statement not covered" >v</span>ar cb=ts.writecb;<span class="cstat-no" title="statement not covered" >i</span>f(!cb)<span class="cstat-no" title="statement not covered" >return stream.emit("error",new Error("no writecb in Transform class"));<span class="cstat-no" title="statement not covered" >t</span></span>s.writechunk=null;<span class="cstat-no" title="statement not covered" >t</span>s.writecb=null;<span class="cstat-no" title="statement not covered" >i</span>f(data!==null&amp;&amp;data!==undefined)<span class="cstat-no" title="statement not covered" >stream.push(data);<span class="cstat-no" title="statement not covered" >c</span></span>b(er);<span class="cstat-no" title="statement not covered" >v</span>ar rs=stream._readableState;<span class="cstat-no" title="statement not covered" >r</span>s.reading=false;<span class="cstat-no" title="statement not covered" >i</span>f(rs.needReadable||rs.length&lt;rs.highWaterMark){<span class="cstat-no" title="statement not covered" >stream._read(rs.highWaterMark)}</span>}<span class="fstat-no" title="function not covered" ></span>function Transform(options){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof Transform))<span class="cstat-no" title="statement not covered" >return new Transform(options);<span class="cstat-no" title="statement not covered" >D</span></span>uplex.call(this,options);<span class="cstat-no" title="statement not covered" >t</span>his._transformState=new TransformState(this);<span class="cstat-no" title="statement not covered" >v</span>ar stream=this;<span class="cstat-no" title="statement not covered" >t</span>his._readableState.needReadable=true;<span class="cstat-no" title="statement not covered" >t</span>his._readableState.sync=false;<span class="cstat-no" title="statement not covered" >i</span>f(options){<span class="cstat-no" title="statement not covered" >if(typeof options.transform==="function")<span class="cstat-no" title="statement not covered" >this._transform=options.transform;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof options.flush==="function")<span class="cstat-no" title="statement not covered" >this._flush=options.flush}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.once("prefinish",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(typeof this._flush==="function")<span class="cstat-no" title="statement not covered" >this._flush(<span class="fstat-no" title="function not covered" >function(er,data){<span class="cstat-no" title="statement not covered" ></span>done(stream,er,data)}</span>);e</span>lse <span class="cstat-no" title="statement not covered" >done(stream)}</span></span>)}</span>Transform.prototype.push=<span class="fstat-no" title="function not covered" >function(chunk,encoding){<span class="cstat-no" title="statement not covered" ></span>this._transformState.needTransform=false;<span class="cstat-no" title="statement not covered" >r</span>eturn Duplex.prototype.push.call(this,chunk,encoding)}</span>;Transform.prototype._transform=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>throw new Error("_transform() is not implemented")}</span>;Transform.prototype._write=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>var ts=this._transformState;<span class="cstat-no" title="statement not covered" >t</span>s.writecb=cb;<span class="cstat-no" title="statement not covered" >t</span>s.writechunk=chunk;<span class="cstat-no" title="statement not covered" >t</span>s.writeencoding=encoding;<span class="cstat-no" title="statement not covered" >i</span>f(!ts.transforming){<span class="cstat-no" title="statement not covered" >var rs=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(ts.needTransform||rs.needReadable||rs.length&lt;rs.highWaterMark)<span class="cstat-no" title="statement not covered" >this._read(rs.highWaterMark)}</span></span>}</span>;Transform.prototype._read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>var ts=this._transformState;<span class="cstat-no" title="statement not covered" >i</span>f(ts.writechunk!==null&amp;&amp;ts.writecb&amp;&amp;!ts.transforming){<span class="cstat-no" title="statement not covered" >ts.transforming=true;<span class="cstat-no" title="statement not covered" >t</span>his._transform(ts.writechunk,ts.writeencoding,ts.afterTransform)}</span>else{<span class="cstat-no" title="statement not covered" >ts.needTransform=true}</span>}</span>;<span class="fstat-no" title="function not covered" >function done(stream,er,data){<span class="cstat-no" title="statement not covered" ></span>if(er)<span class="cstat-no" title="statement not covered" >return stream.emit("error",er);<span class="cstat-no" title="statement not covered" >i</span></span>f(data!==null&amp;&amp;data!==undefined)<span class="cstat-no" title="statement not covered" >stream.push(data);<span class="cstat-no" title="statement not covered" >v</span></span>ar ws=stream._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar ts=stream._transformState;<span class="cstat-no" title="statement not covered" >i</span>f(ws.length)<span class="cstat-no" title="statement not covered" >throw new Error("Calling transform done when ws.length != 0");<span class="cstat-no" title="statement not covered" >i</span></span>f(ts.transforming)<span class="cstat-no" title="statement not covered" >throw new Error("Calling transform done when still transforming");<span class="cstat-no" title="statement not covered" >r</span></span>eturn stream.push(null)}</span>},{"./_stream_duplex":11,"core-util-is":6,inherits:22}],15:[function(require,module,exports){(function(process){"use strict";module.exports=Writable;var processNextTick=require("process-nextick-args");var asyncWrite=!process.browser&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >["v0.10","v0.9."].indexOf(process.version.slice(0,5))&gt;-1?<span class="branch-0 cbranch-no" title="branch not covered" ></span>setImmediate:</span>processNextTick;var Duplex;Writable.WritableState=WritableState;var util=require("core-util-is");util.inherits=require("inherits");var internalUtil={deprecate:require("util-deprecate")};var Stream;(function(){try{Stream=require("st"+"ream")}catch(_){}finally{<span class="missing-if-branch" title="if path not taken" >I</span>if(!Stream)<span class="cstat-no" title="statement not covered" >Stream=require("events").EventEmitter}</span>})();var Buffer=require("buffer").Buffer;var bufferShim=require("buffer-shims");util.inherits(Writable,Stream);<span class="fstat-no" title="function not covered" >function nop(){</span>}<span class="fstat-no" title="function not covered" >function WriteReq(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>this.chunk=chunk;<span class="cstat-no" title="statement not covered" >t</span>his.encoding=encoding;<span class="cstat-no" title="statement not covered" >t</span>his.callback=cb;<span class="cstat-no" title="statement not covered" >t</span>his.next=null}<span class="fstat-no" title="function not covered" ></span>function WritableState(options,stream){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >o</span>ptions=options||{};<span class="cstat-no" title="statement not covered" >t</span>his.objectMode=!!options.objectMode;<span class="cstat-no" title="statement not covered" >i</span>f(stream instanceof Duplex)<span class="cstat-no" title="statement not covered" >this.objectMode=this.objectMode||!!options.writableObjectMode;<span class="cstat-no" title="statement not covered" >v</span></span>ar hwm=options.highWaterMark;<span class="cstat-no" title="statement not covered" >v</span>ar defaultHwm=this.objectMode?16:16*1024;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=hwm||hwm===0?hwm:defaultHwm;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=~~this.highWaterMark;<span class="cstat-no" title="statement not covered" >t</span>his.needDrain=false;<span class="cstat-no" title="statement not covered" >t</span>his.ending=false;<span class="cstat-no" title="statement not covered" >t</span>his.ended=false;<span class="cstat-no" title="statement not covered" >t</span>his.finished=false;<span class="cstat-no" title="statement not covered" >v</span>ar noDecode=options.decodeStrings===false;<span class="cstat-no" title="statement not covered" >t</span>his.decodeStrings=!noDecode;<span class="cstat-no" title="statement not covered" >t</span>his.defaultEncoding=options.defaultEncoding||"utf8";<span class="cstat-no" title="statement not covered" >t</span>his.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.writing=false;<span class="cstat-no" title="statement not covered" >t</span>his.corked=0;<span class="cstat-no" title="statement not covered" >t</span>his.sync=true;<span class="cstat-no" title="statement not covered" >t</span>his.bufferProcessing=false;<span class="cstat-no" title="statement not covered" >t</span>his.onwrite=<span class="fstat-no" title="function not covered" >function(er){<span class="cstat-no" title="statement not covered" ></span>onwrite(stream,er)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.writecb=null;<span class="cstat-no" title="statement not covered" >t</span>his.writelen=0;<span class="cstat-no" title="statement not covered" >t</span>his.bufferedRequest=null;<span class="cstat-no" title="statement not covered" >t</span>his.lastBufferedRequest=null;<span class="cstat-no" title="statement not covered" >t</span>his.pendingcb=0;<span class="cstat-no" title="statement not covered" >t</span>his.prefinished=false;<span class="cstat-no" title="statement not covered" >t</span>his.errorEmitted=false;<span class="cstat-no" title="statement not covered" >t</span>his.bufferedRequestCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.corkedRequestsFree=new CorkedRequest(this)}</span>WritableState.prototype.getBuffer=<span class="fstat-no" title="function not covered" >function getBuffer(){<span class="cstat-no" title="statement not covered" ></span>var current=this.bufferedRequest;<span class="cstat-no" title="statement not covered" >v</span>ar out=[];<span class="cstat-no" title="statement not covered" >w</span>hile(current){<span class="cstat-no" title="statement not covered" >out.push(current);<span class="cstat-no" title="statement not covered" >c</span>urrent=current.next}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn out}</span>;(function(){try{Object.defineProperty(WritableState.prototype,"buffer",{get:internalUtil.deprecate(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this.getBuffer()}</span>,"_writableState.buffer is deprecated. Use _writableState.getBuffer "+"instead.")})}catch(_){}})();var realHasInstance;<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof Symbol==="function"&amp;&amp;Symbol.hasInstance&amp;&amp;typeof Function.prototype[Symbol.hasInstance]==="function"){realHasInstance=Function.prototype[Symbol.hasInstance];Object.defineProperty(Writable,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function(object){<span class="cstat-no" title="statement not covered" ></span>if(realHasInstance.call(this,object))<span class="cstat-no" title="statement not covered" >return true;<span class="cstat-no" title="statement not covered" >r</span></span>eturn object&amp;&amp;object._writableState instanceof WritableState}</span>})}else{<span class="cstat-no" title="statement not covered" >realHasInstance=<span class="fstat-no" title="function not covered" >function(object){<span class="cstat-no" title="statement not covered" ></span>return object instanceof this}</span>}<span class="fstat-no" title="function not covered" ></span>function Writable(options){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >i</span>f(!realHasInstance.call(Writable,this)&amp;&amp;!(this instanceof Duplex)){<span class="cstat-no" title="statement not covered" >return new Writable(options)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._writableState=new WritableState(options,this);<span class="cstat-no" title="statement not covered" >t</span>his.writable=true;<span class="cstat-no" title="statement not covered" >i</span>f(options){<span class="cstat-no" title="statement not covered" >if(typeof options.write==="function")<span class="cstat-no" title="statement not covered" >this._write=options.write;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof options.writev==="function")<span class="cstat-no" title="statement not covered" >this._writev=options.writev}<span class="cstat-no" title="statement not covered" ></span></span>S</span>tream.call(this)}</span>Writable.prototype.pipe=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.emit("error",new Error("Cannot pipe, not readable"))}</span>;<span class="fstat-no" title="function not covered" >function writeAfterEnd(stream,cb){<span class="cstat-no" title="statement not covered" ></span>var er=new Error("write after end");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",er);<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(cb,er)}<span class="fstat-no" title="function not covered" ></span>function validChunk(stream,state,chunk,cb){<span class="cstat-no" title="statement not covered" ></span>var valid=true;<span class="cstat-no" title="statement not covered" >v</span>ar er=false;<span class="cstat-no" title="statement not covered" >i</span>f(chunk===null){<span class="cstat-no" title="statement not covered" >er=new TypeError("May not write null values to stream")}</span>else <span class="cstat-no" title="statement not covered" >if(!Buffer.isBuffer(chunk)&amp;&amp;typeof chunk!=="string"&amp;&amp;chunk!==undefined&amp;&amp;!state.objectMode){<span class="cstat-no" title="statement not covered" >er=new TypeError("Invalid non-string/buffer chunk")}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(er){<span class="cstat-no" title="statement not covered" >stream.emit("error",er);<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(cb,er);<span class="cstat-no" title="statement not covered" >v</span>alid=false}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn valid}</span>Writable.prototype.write=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar ret=false;<span class="cstat-no" title="statement not covered" >i</span>f(typeof encoding==="function"){<span class="cstat-no" title="statement not covered" >cb=encoding;<span class="cstat-no" title="statement not covered" >e</span>ncoding=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Buffer.isBuffer(chunk))<span class="cstat-no" title="statement not covered" >encoding="buffer";e</span>lse <span class="cstat-no" title="statement not covered" >if(!encoding)<span class="cstat-no" title="statement not covered" >encoding=state.defaultEncoding;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(typeof cb!=="function")<span class="cstat-no" title="statement not covered" >cb=nop;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.ended)<span class="cstat-no" title="statement not covered" >writeAfterEnd(this,cb);e</span>lse <span class="cstat-no" title="statement not covered" >if(validChunk(this,state,chunk,cb)){<span class="cstat-no" title="statement not covered" >state.pendingcb++;<span class="cstat-no" title="statement not covered" >r</span>et=writeOrBuffer(this,state,chunk,encoding,cb)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn ret}</span>;Writable.prototype.cork=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >s</span>tate.corked++}</span>;Writable.prototype.uncork=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >i</span>f(state.corked){<span class="cstat-no" title="statement not covered" >state.corked--;<span class="cstat-no" title="statement not covered" >i</span>f(!state.writing&amp;&amp;!state.corked&amp;&amp;!state.finished&amp;&amp;!state.bufferProcessing&amp;&amp;state.bufferedRequest)<span class="cstat-no" title="statement not covered" >clearBuffer(this,state)}</span></span>}</span>;Writable.prototype.setDefaultEncoding=<span class="fstat-no" title="function not covered" >function setDefaultEncoding(encoding){<span class="cstat-no" title="statement not covered" ></span>if(typeof encoding==="string")<span class="cstat-no" title="statement not covered" >encoding=encoding.toLowerCase();<span class="cstat-no" title="statement not covered" >i</span></span>f(!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((encoding+"").toLowerCase())&gt;-1))<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+encoding);<span class="cstat-no" title="statement not covered" >t</span></span>his._writableState.defaultEncoding=encoding;<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;<span class="fstat-no" title="function not covered" >function decodeChunk(state,chunk,encoding){<span class="cstat-no" title="statement not covered" ></span>if(!state.objectMode&amp;&amp;state.decodeStrings!==false&amp;&amp;typeof chunk==="string"){<span class="cstat-no" title="statement not covered" >chunk=bufferShim.from(chunk,encoding)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn chunk}<span class="fstat-no" title="function not covered" ></span>function writeOrBuffer(stream,state,chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>chunk=decodeChunk(state,chunk,encoding);<span class="cstat-no" title="statement not covered" >i</span>f(Buffer.isBuffer(chunk))<span class="cstat-no" title="statement not covered" >encoding="buffer";<span class="cstat-no" title="statement not covered" >v</span></span>ar len=state.objectMode?1:chunk.length;<span class="cstat-no" title="statement not covered" >s</span>tate.length+=len;<span class="cstat-no" title="statement not covered" >v</span>ar ret=state.length&lt;state.highWaterMark;<span class="cstat-no" title="statement not covered" >i</span>f(!ret)<span class="cstat-no" title="statement not covered" >state.needDrain=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.writing||state.corked){<span class="cstat-no" title="statement not covered" >var last=state.lastBufferedRequest;<span class="cstat-no" title="statement not covered" >s</span>tate.lastBufferedRequest=new WriteReq(chunk,encoding,cb);<span class="cstat-no" title="statement not covered" >i</span>f(last){<span class="cstat-no" title="statement not covered" >last.next=state.lastBufferedRequest}</span>else{<span class="cstat-no" title="statement not covered" >state.bufferedRequest=state.lastBufferedRequest}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.bufferedRequestCount+=1}</span>else{<span class="cstat-no" title="statement not covered" >doWrite(stream,state,false,len,chunk,encoding,cb)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function doWrite(stream,state,writev,len,chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>state.writelen=len;<span class="cstat-no" title="statement not covered" >s</span>tate.writecb=cb;<span class="cstat-no" title="statement not covered" >s</span>tate.writing=true;<span class="cstat-no" title="statement not covered" >s</span>tate.sync=true;<span class="cstat-no" title="statement not covered" >i</span>f(writev)<span class="cstat-no" title="statement not covered" >stream._writev(chunk,state.onwrite);e</span>lse <span class="cstat-no" title="statement not covered" >stream._write(chunk,encoding,state.onwrite);<span class="cstat-no" title="statement not covered" >s</span></span>tate.sync=false}<span class="fstat-no" title="function not covered" ></span>function onwriteError(stream,state,sync,er,cb){<span class="cstat-no" title="statement not covered" ></span>--state.pendingcb;<span class="cstat-no" title="statement not covered" >i</span>f(sync)<span class="cstat-no" title="statement not covered" >processNextTick(cb,er);e</span>lse <span class="cstat-no" title="statement not covered" >cb(er);<span class="cstat-no" title="statement not covered" >s</span></span>tream._writableState.errorEmitted=true;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",er)}<span class="fstat-no" title="function not covered" ></span>function onwriteStateUpdate(state){<span class="cstat-no" title="statement not covered" ></span>state.writing=false;<span class="cstat-no" title="statement not covered" >s</span>tate.writecb=null;<span class="cstat-no" title="statement not covered" >s</span>tate.length-=state.writelen;<span class="cstat-no" title="statement not covered" >s</span>tate.writelen=0}<span class="fstat-no" title="function not covered" ></span>function onwrite(stream,er){<span class="cstat-no" title="statement not covered" ></span>var state=stream._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar sync=state.sync;<span class="cstat-no" title="statement not covered" >v</span>ar cb=state.writecb;<span class="cstat-no" title="statement not covered" >o</span>nwriteStateUpdate(state);<span class="cstat-no" title="statement not covered" >i</span>f(er)<span class="cstat-no" title="statement not covered" >onwriteError(stream,state,sync,er,cb);e</span>lse{<span class="cstat-no" title="statement not covered" >var finished=needFinish(state);<span class="cstat-no" title="statement not covered" >i</span>f(!finished&amp;&amp;!state.corked&amp;&amp;!state.bufferProcessing&amp;&amp;state.bufferedRequest){<span class="cstat-no" title="statement not covered" >clearBuffer(stream,state)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(sync){<span class="cstat-no" title="statement not covered" >asyncWrite(afterWrite,stream,state,finished,cb)}</span>else{<span class="cstat-no" title="statement not covered" >afterWrite(stream,state,finished,cb)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function afterWrite(stream,state,finished,cb){<span class="cstat-no" title="statement not covered" ></span>if(!finished)<span class="cstat-no" title="statement not covered" >onwriteDrain(stream,state);<span class="cstat-no" title="statement not covered" >s</span></span>tate.pendingcb--;<span class="cstat-no" title="statement not covered" >c</span>b();<span class="cstat-no" title="statement not covered" >f</span>inishMaybe(stream,state)}<span class="fstat-no" title="function not covered" ></span>function onwriteDrain(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(state.length===0&amp;&amp;state.needDrain){<span class="cstat-no" title="statement not covered" >state.needDrain=false;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("drain")}</span>}<span class="fstat-no" title="function not covered" ></span>function clearBuffer(stream,state){<span class="cstat-no" title="statement not covered" ></span>state.bufferProcessing=true;<span class="cstat-no" title="statement not covered" >v</span>ar entry=state.bufferedRequest;<span class="cstat-no" title="statement not covered" >i</span>f(stream._writev&amp;&amp;entry&amp;&amp;entry.next){<span class="cstat-no" title="statement not covered" >var l=state.bufferedRequestCount;<span class="cstat-no" title="statement not covered" >v</span>ar buffer=new Array(l);<span class="cstat-no" title="statement not covered" >v</span>ar holder=state.corkedRequestsFree;<span class="cstat-no" title="statement not covered" >h</span>older.entry=entry;<span class="cstat-no" title="statement not covered" >v</span>ar count=0;<span class="cstat-no" title="statement not covered" >w</span>hile(entry){<span class="cstat-no" title="statement not covered" >buffer[count]=entry;<span class="cstat-no" title="statement not covered" >e</span>ntry=entry.next;<span class="cstat-no" title="statement not covered" >c</span>ount+=1}<span class="cstat-no" title="statement not covered" ></span>d</span>oWrite(stream,state,true,state.length,buffer,"",holder.finish);<span class="cstat-no" title="statement not covered" >s</span>tate.pendingcb++;<span class="cstat-no" title="statement not covered" >s</span>tate.lastBufferedRequest=null;<span class="cstat-no" title="statement not covered" >i</span>f(holder.next){<span class="cstat-no" title="statement not covered" >state.corkedRequestsFree=holder.next;<span class="cstat-no" title="statement not covered" >h</span>older.next=null}</span>else{<span class="cstat-no" title="statement not covered" >state.corkedRequestsFree=new CorkedRequest(state)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >while(entry){<span class="cstat-no" title="statement not covered" >var chunk=entry.chunk;<span class="cstat-no" title="statement not covered" >v</span>ar encoding=entry.encoding;<span class="cstat-no" title="statement not covered" >v</span>ar cb=entry.callback;<span class="cstat-no" title="statement not covered" >v</span>ar len=state.objectMode?1:chunk.length;<span class="cstat-no" title="statement not covered" >d</span>oWrite(stream,state,false,len,chunk,encoding,cb);<span class="cstat-no" title="statement not covered" >e</span>ntry=entry.next;<span class="cstat-no" title="statement not covered" >i</span>f(state.writing){<span class="cstat-no" title="statement not covered" >break}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(entry===null)<span class="cstat-no" title="statement not covered" >state.lastBufferedRequest=null}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tate.bufferedRequestCount=0;<span class="cstat-no" title="statement not covered" >s</span>tate.bufferedRequest=entry;<span class="cstat-no" title="statement not covered" >s</span>tate.bufferProcessing=false}</span>Writable.prototype._write=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>cb(new Error("_write() is not implemented"))}</span>;Writable.prototype._writev=null;Writable.prototype.end=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >i</span>f(typeof chunk==="function"){<span class="cstat-no" title="statement not covered" >cb=chunk;<span class="cstat-no" title="statement not covered" >c</span>hunk=null;<span class="cstat-no" title="statement not covered" >e</span>ncoding=null}</span>else <span class="cstat-no" title="statement not covered" >if(typeof encoding==="function"){<span class="cstat-no" title="statement not covered" >cb=encoding;<span class="cstat-no" title="statement not covered" >e</span>ncoding=null}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(chunk!==null&amp;&amp;chunk!==undefined)<span class="cstat-no" title="statement not covered" >this.write(chunk,encoding);<span class="cstat-no" title="statement not covered" >i</span></span>f(state.corked){<span class="cstat-no" title="statement not covered" >state.corked=1;<span class="cstat-no" title="statement not covered" >t</span>his.uncork()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!state.ending&amp;&amp;!state.finished)<span class="cstat-no" title="statement not covered" >endWritable(this,state,cb)}</span></span>;<span class="fstat-no" title="function not covered" >function needFinish(state){<span class="cstat-no" title="statement not covered" ></span>return state.ending&amp;&amp;state.length===0&amp;&amp;state.bufferedRequest===null&amp;&amp;!state.finished&amp;&amp;!state.writing}<span class="fstat-no" title="function not covered" ></span>function prefinish(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.prefinished){<span class="cstat-no" title="statement not covered" >state.prefinished=true;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("prefinish")}</span>}<span class="fstat-no" title="function not covered" ></span>function finishMaybe(stream,state){<span class="cstat-no" title="statement not covered" ></span>var need=needFinish(state);<span class="cstat-no" title="statement not covered" >i</span>f(need){<span class="cstat-no" title="statement not covered" >if(state.pendingcb===0){<span class="cstat-no" title="statement not covered" >prefinish(stream,state);<span class="cstat-no" title="statement not covered" >s</span>tate.finished=true;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("finish")}</span>else{<span class="cstat-no" title="statement not covered" >prefinish(stream,state)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn need}<span class="fstat-no" title="function not covered" ></span>function endWritable(stream,state,cb){<span class="cstat-no" title="statement not covered" ></span>state.ending=true;<span class="cstat-no" title="statement not covered" >f</span>inishMaybe(stream,state);<span class="cstat-no" title="statement not covered" >i</span>f(cb){<span class="cstat-no" title="statement not covered" >if(state.finished)<span class="cstat-no" title="statement not covered" >processNextTick(cb);e</span>lse <span class="cstat-no" title="statement not covered" >stream.once("finish",cb)}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tate.ended=true;<span class="cstat-no" title="statement not covered" >s</span>tream.writable=false}<span class="fstat-no" title="function not covered" ></span>function CorkedRequest(state){<span class="cstat-no" title="statement not covered" ></span>var _this=this;<span class="cstat-no" title="statement not covered" >t</span>his.next=null;<span class="cstat-no" title="statement not covered" >t</span>his.entry=null;<span class="cstat-no" title="statement not covered" >t</span>his.finish=<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>var entry=_this.entry;<span class="cstat-no" title="statement not covered" >_</span>this.entry=null;<span class="cstat-no" title="statement not covered" >w</span>hile(entry){<span class="cstat-no" title="statement not covered" >var cb=entry.callback;<span class="cstat-no" title="statement not covered" >s</span>tate.pendingcb--;<span class="cstat-no" title="statement not covered" >c</span>b(err);<span class="cstat-no" title="statement not covered" >e</span>ntry=entry.next}<span class="cstat-no" title="statement not covered" ></span>i</span>f(state.corkedRequestsFree){<span class="cstat-no" title="statement not covered" >state.corkedRequestsFree.next=_this}</span>else{<span class="cstat-no" title="statement not covered" >state.corkedRequestsFree=_this}</span>}</span>}</span>}).call(this,require("_process"))},{"./_stream_duplex":11,_process:48,buffer:4,"buffer-shims":3,"core-util-is":6,events:20,inherits:22,"process-nextick-args":47,"util-deprecate":65}],16:[function(require,module,exports){"use strict";var Buffer=require("buffer").Buffer;var bufferShim=require("buffer-shims");module.exports=BufferList;<span class="fstat-no" title="function not covered" >function BufferList(){<span class="cstat-no" title="statement not covered" ></span>this.head=null;<span class="cstat-no" title="statement not covered" >t</span>his.tail=null;<span class="cstat-no" title="statement not covered" >t</span>his.length=0}</span>BufferList.prototype.push=<span class="fstat-no" title="function not covered" >function(v){<span class="cstat-no" title="statement not covered" ></span>var entry={data:v,next:null};<span class="cstat-no" title="statement not covered" >i</span>f(this.length&gt;0)<span class="cstat-no" title="statement not covered" >this.tail.next=entry;e</span>lse <span class="cstat-no" title="statement not covered" >this.head=entry;<span class="cstat-no" title="statement not covered" >t</span></span>his.tail=entry;<span class="cstat-no" title="statement not covered" >+</span>+this.length}</span>;BufferList.prototype.unshift=<span class="fstat-no" title="function not covered" >function(v){<span class="cstat-no" title="statement not covered" ></span>var entry={data:v,next:this.head};<span class="cstat-no" title="statement not covered" >i</span>f(this.length===0)<span class="cstat-no" title="statement not covered" >this.tail=entry;<span class="cstat-no" title="statement not covered" >t</span></span>his.head=entry;<span class="cstat-no" title="statement not covered" >+</span>+this.length}</span>;BufferList.prototype.shift=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.length===0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>ar ret=this.head.data;<span class="cstat-no" title="statement not covered" >i</span>f(this.length===1)<span class="cstat-no" title="statement not covered" >this.head=this.tail=null;e</span>lse <span class="cstat-no" title="statement not covered" >this.head=this.head.next;<span class="cstat-no" title="statement not covered" >-</span></span>-this.length;<span class="cstat-no" title="statement not covered" >r</span>eturn ret}</span>;BufferList.prototype.clear=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.head=this.tail=null;<span class="cstat-no" title="statement not covered" >t</span>his.length=0}</span>;BufferList.prototype.join=<span class="fstat-no" title="function not covered" >function(s){<span class="cstat-no" title="statement not covered" ></span>if(this.length===0)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >v</span></span>ar p=this.head;<span class="cstat-no" title="statement not covered" >v</span>ar ret=""+p.data;<span class="cstat-no" title="statement not covered" >w</span>hile(p=p.next){<span class="cstat-no" title="statement not covered" >ret+=s+p.data}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}</span>;BufferList.prototype.concat=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>if(this.length===0)<span class="cstat-no" title="statement not covered" >return bufferShim.alloc(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.length===1)<span class="cstat-no" title="statement not covered" >return this.head.data;<span class="cstat-no" title="statement not covered" >v</span></span>ar ret=bufferShim.allocUnsafe(n&gt;&gt;&gt;0);<span class="cstat-no" title="statement not covered" >v</span>ar p=this.head;<span class="cstat-no" title="statement not covered" >v</span>ar i=0;<span class="cstat-no" title="statement not covered" >w</span>hile(p){<span class="cstat-no" title="statement not covered" >p.data.copy(ret,i);<span class="cstat-no" title="statement not covered" >i</span>+=p.data.length;<span class="cstat-no" title="statement not covered" >p</span>=p.next}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}</span>},{buffer:4,"buffer-shims":3}],17:[function(require,module,exports){(function(process){var Stream=function(){try{return require("st"+"ream")}catch(_){}}();exports=module.exports=require("./lib/_stream_readable.js");exports.Stream=Stream||<span class="branch-1 cbranch-no" title="branch not covered" >exports;</span>exports.Readable=exports;exports.Writable=require("./lib/_stream_writable.js");exports.Duplex=require("./lib/_stream_duplex.js");exports.Transform=require("./lib/_stream_transform.js");exports.PassThrough=require("./lib/_stream_passthrough.js");<span class="missing-if-branch" title="if path not taken" >I</span>if(!process.browser&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >process.env.READABLE_STREAM==="disable"&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >Stream)</span>{<span class="cstat-no" title="statement not covered" >module.exports=Stream}</span>}).call(this,require("_process"))},{"./lib/_stream_duplex.js":11,"./lib/_stream_passthrough.js":12,"./lib/_stream_readable.js":13,"./lib/_stream_transform.js":14,"./lib/_stream_writable.js":15,_process:48}],18:[function(require,module,exports){var once=require("once");var noop=<span class="fstat-no" title="function not covered" >function(){</span>};var isRequest=<span class="fstat-no" title="function not covered" >function(stream){<span class="cstat-no" title="statement not covered" ></span>return stream.setHeader&amp;&amp;typeof stream.abort==="function"}</span>;var isChildProcess=<span class="fstat-no" title="function not covered" >function(stream){<span class="cstat-no" title="statement not covered" ></span>return stream.stdio&amp;&amp;Array.isArray(stream.stdio)&amp;&amp;stream.stdio.length===3}</span>;var eos=<span class="fstat-no" title="function not covered" >function(stream,opts,callback){<span class="cstat-no" title="statement not covered" ></span>if(typeof opts==="function")<span class="cstat-no" title="statement not covered" >return eos(stream,null,opts);<span class="cstat-no" title="statement not covered" >i</span></span>f(!opts)<span class="cstat-no" title="statement not covered" >opts={};<span class="cstat-no" title="statement not covered" >c</span></span>allback=once(callback||noop);<span class="cstat-no" title="statement not covered" >v</span>ar ws=stream._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar rs=stream._readableState;<span class="cstat-no" title="statement not covered" >v</span>ar readable=opts.readable||opts.readable!==false&amp;&amp;stream.readable;<span class="cstat-no" title="statement not covered" >v</span>ar writable=opts.writable||opts.writable!==false&amp;&amp;stream.writable;<span class="cstat-no" title="statement not covered" >v</span>ar onlegacyfinish=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!stream.writable)<span class="cstat-no" title="statement not covered" >onfinish()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onfinish=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>writable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!readable)<span class="cstat-no" title="statement not covered" >callback()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onend=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>readable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!writable)<span class="cstat-no" title="statement not covered" >callback()}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onexit=<span class="fstat-no" title="function not covered" >function(exitCode){<span class="cstat-no" title="statement not covered" ></span>callback(exitCode?new Error("exited with error code: "+exitCode):null)}</span>;<span class="cstat-no" title="statement not covered" >v</span>ar onclose=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(readable&amp;&amp;!(rs&amp;&amp;rs.ended))<span class="cstat-no" title="statement not covered" >return callback(new Error("premature close"));<span class="cstat-no" title="statement not covered" >i</span></span>f(writable&amp;&amp;!(ws&amp;&amp;ws.ended))<span class="cstat-no" title="statement not covered" >return callback(new Error("premature close"))}</span></span>;<span class="cstat-no" title="statement not covered" >v</span>ar onrequest=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>stream.req.on("finish",onfinish)}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(isRequest(stream)){<span class="cstat-no" title="statement not covered" >stream.on("complete",onfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.on("abort",onclose);<span class="cstat-no" title="statement not covered" >i</span>f(stream.req)<span class="cstat-no" title="statement not covered" >onrequest();e</span>lse <span class="cstat-no" title="statement not covered" >stream.on("request",onrequest)}</span></span>else <span class="cstat-no" title="statement not covered" >if(writable&amp;&amp;!ws){<span class="cstat-no" title="statement not covered" >stream.on("end",onlegacyfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.on("close",onlegacyfinish)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(isChildProcess(stream))<span class="cstat-no" title="statement not covered" >stream.on("exit",onexit);<span class="cstat-no" title="statement not covered" >s</span></span>tream.on("end",onend);<span class="cstat-no" title="statement not covered" >s</span>tream.on("finish",onfinish);<span class="cstat-no" title="statement not covered" >i</span>f(opts.error!==false)<span class="cstat-no" title="statement not covered" >stream.on("error",callback);<span class="cstat-no" title="statement not covered" >s</span></span>tream.on("close",onclose);<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>stream.removeListener("complete",onfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("abort",onclose);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("request",onrequest);<span class="cstat-no" title="statement not covered" >i</span>f(stream.req)<span class="cstat-no" title="statement not covered" >stream.req.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >s</span></span>tream.removeListener("end",onlegacyfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("close",onlegacyfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("exit",onexit);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("end",onend);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("error",callback);<span class="cstat-no" title="statement not covered" >s</span>tream.removeListener("close",onclose)}</span>}</span>;module.exports=eos},{once:19}],19:[function(require,module,exports){arguments[4][10][0].apply(exports,arguments)},{dup:10,wrappy:71}],20:[function(require,module,exports){<span class="fstat-no" title="function not covered" >function EventEmitter(){<span class="cstat-no" title="statement not covered" ></span>this._events=this._events||{};<span class="cstat-no" title="statement not covered" >t</span>his._maxListeners=this._maxListeners||undefined}</span>module.exports=EventEmitter;EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;EventEmitter.defaultMaxListeners=10;EventEmitter.prototype.setMaxListeners=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>if(!isNumber(n)||n&lt;0||isNaN(n))<span class="cstat-no" title="statement not covered" >throw TypeError("n must be a positive number");<span class="cstat-no" title="statement not covered" >t</span></span>his._maxListeners=n;<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;EventEmitter.prototype.emit=<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>var er,handler,len,args,i,listeners;<span class="cstat-no" title="statement not covered" >i</span>f(!this._events)<span class="cstat-no" title="statement not covered" >this._events={};<span class="cstat-no" title="statement not covered" >i</span></span>f(type==="error"){<span class="cstat-no" title="statement not covered" >if(!this._events.error||isObject(this._events.error)&amp;&amp;!this._events.error.length){<span class="cstat-no" title="statement not covered" >er=arguments[1];<span class="cstat-no" title="statement not covered" >i</span>f(er instanceof Error){<span class="cstat-no" title="statement not covered" >throw er}</span>else{<span class="cstat-no" title="statement not covered" >var err=new Error('Uncaught, unspecified "error" event. ('+er+")");<span class="cstat-no" title="statement not covered" >e</span>rr.context=er;<span class="cstat-no" title="statement not covered" >t</span>hrow err}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>h</span>andler=this._events[type];<span class="cstat-no" title="statement not covered" >i</span>f(isUndefined(handler))<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >i</span></span>f(isFunction(handler)){<span class="cstat-no" title="statement not covered" >switch(arguments.length){case 1:<span class="cstat-no" title="statement not covered" >handler.call(this);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >handler.call(this,arguments[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >handler.call(this,arguments[1],arguments[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >args=Array.prototype.slice.call(arguments,1);<span class="cstat-no" title="statement not covered" >h</span>andler.apply(this,args)}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(isObject(handler)){<span class="cstat-no" title="statement not covered" >args=Array.prototype.slice.call(arguments,1);<span class="cstat-no" title="statement not covered" >l</span>isteners=handler.slice();<span class="cstat-no" title="statement not covered" >l</span>en=listeners.length;<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;len;i++)<span class="cstat-no" title="statement not covered" >listeners[i].apply(this,args)}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn true}</span>;EventEmitter.prototype.addListener=<span class="fstat-no" title="function not covered" >function(type,listener){<span class="cstat-no" title="statement not covered" ></span>var m;<span class="cstat-no" title="statement not covered" >i</span>f(!isFunction(listener))<span class="cstat-no" title="statement not covered" >throw TypeError("listener must be a function");<span class="cstat-no" title="statement not covered" >i</span></span>f(!this._events)<span class="cstat-no" title="statement not covered" >this._events={};<span class="cstat-no" title="statement not covered" >i</span></span>f(this._events.newListener)<span class="cstat-no" title="statement not covered" >this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener);<span class="cstat-no" title="statement not covered" >i</span></span>f(!this._events[type])<span class="cstat-no" title="statement not covered" >this._events[type]=listener;e</span>lse <span class="cstat-no" title="statement not covered" >if(isObject(this._events[type]))<span class="cstat-no" title="statement not covered" >this._events[type].push(listener);e</span>lse <span class="cstat-no" title="statement not covered" >this._events[type]=[this._events[type],listener];<span class="cstat-no" title="statement not covered" >i</span></span></span>f(isObject(this._events[type])&amp;&amp;!this._events[type].warned){<span class="cstat-no" title="statement not covered" >if(!isUndefined(this._maxListeners)){<span class="cstat-no" title="statement not covered" >m=this._maxListeners}</span>else{<span class="cstat-no" title="statement not covered" >m=EventEmitter.defaultMaxListeners}<span class="cstat-no" title="statement not covered" ></span>i</span>f(m&amp;&amp;m&gt;0&amp;&amp;this._events[type].length&gt;m){<span class="cstat-no" title="statement not covered" >this._events[type].warned=true;<span class="cstat-no" title="statement not covered" >c</span>onsole.error("(node) warning: possible EventEmitter memory "+"leak detected. %d listeners added. "+"Use emitter.setMaxListeners() to increase limit.",this._events[type].length);<span class="cstat-no" title="statement not covered" >i</span>f(typeof console.trace==="function"){<span class="cstat-no" title="statement not covered" >console.trace()}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=<span class="fstat-no" title="function not covered" >function(type,listener){<span class="cstat-no" title="statement not covered" ></span>if(!isFunction(listener))<span class="cstat-no" title="statement not covered" >throw TypeError("listener must be a function");<span class="cstat-no" title="statement not covered" >v</span></span>ar fired=false;<span class="fstat-no" title="function not covered" >f</span>unction g(){<span class="cstat-no" title="statement not covered" ></span>this.removeListener(type,g);<span class="cstat-no" title="statement not covered" >i</span>f(!fired){<span class="cstat-no" title="statement not covered" >fired=true;<span class="cstat-no" title="statement not covered" >l</span>istener.apply(this,arguments)}</span>}<span class="cstat-no" title="statement not covered" ></span>g.listener=listener;<span class="cstat-no" title="statement not covered" >t</span>his.on(type,g);<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;EventEmitter.prototype.removeListener=<span class="fstat-no" title="function not covered" >function(type,listener){<span class="cstat-no" title="statement not covered" ></span>var list,position,length,i;<span class="cstat-no" title="statement not covered" >i</span>f(!isFunction(listener))<span class="cstat-no" title="statement not covered" >throw TypeError("listener must be a function");<span class="cstat-no" title="statement not covered" >i</span></span>f(!this._events||!this._events[type])<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >l</span></span>ist=this._events[type];<span class="cstat-no" title="statement not covered" >l</span>ength=list.length;<span class="cstat-no" title="statement not covered" >p</span>osition=-1;<span class="cstat-no" title="statement not covered" >i</span>f(list===listener||isFunction(list.listener)&amp;&amp;list.listener===listener){<span class="cstat-no" title="statement not covered" >delete this._events[type];<span class="cstat-no" title="statement not covered" >i</span>f(this._events.removeListener)<span class="cstat-no" title="statement not covered" >this.emit("removeListener",type,listener)}</span></span>else <span class="cstat-no" title="statement not covered" >if(isObject(list)){<span class="cstat-no" title="statement not covered" >for(i=length;i-- &gt;0;){<span class="cstat-no" title="statement not covered" >if(list[i]===listener||list[i].listener&amp;&amp;list[i].listener===listener){<span class="cstat-no" title="statement not covered" >position=i;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(position&lt;0)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(list.length===1){<span class="cstat-no" title="statement not covered" >list.length=0;<span class="cstat-no" title="statement not covered" >d</span>elete this._events[type]}</span>else{<span class="cstat-no" title="statement not covered" >list.splice(position,1)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._events.removeListener)<span class="cstat-no" title="statement not covered" >this.emit("removeListener",type,listener)}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn this}</span>;EventEmitter.prototype.removeAllListeners=<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>var key,listeners;<span class="cstat-no" title="statement not covered" >i</span>f(!this._events)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this._events.removeListener){<span class="cstat-no" title="statement not covered" >if(arguments.length===0)<span class="cstat-no" title="statement not covered" >this._events={};e</span>lse <span class="cstat-no" title="statement not covered" >if(this._events[type])<span class="cstat-no" title="statement not covered" >delete this._events[type];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}<span class="cstat-no" title="statement not covered" ></span>i</span>f(arguments.length===0){<span class="cstat-no" title="statement not covered" >for(key in this._events){<span class="cstat-no" title="statement not covered" >if(key==="removeListener")<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span></span>his.removeAllListeners(key)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.removeAllListeners("removeListener");<span class="cstat-no" title="statement not covered" >t</span>his._events={};<span class="cstat-no" title="statement not covered" >r</span>eturn this}<span class="cstat-no" title="statement not covered" ></span>l</span>isteners=this._events[type];<span class="cstat-no" title="statement not covered" >i</span>f(isFunction(listeners)){<span class="cstat-no" title="statement not covered" >this.removeListener(type,listeners)}</span>else <span class="cstat-no" title="statement not covered" >if(listeners){<span class="cstat-no" title="statement not covered" >while(listeners.length)<span class="cstat-no" title="statement not covered" >this.removeListener(type,listeners[listeners.length-1])}<span class="cstat-no" title="statement not covered" ></span></span>d</span></span>elete this._events[type];<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;EventEmitter.prototype.listeners=<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>var ret;<span class="cstat-no" title="statement not covered" >i</span>f(!this._events||!this._events[type])<span class="cstat-no" title="statement not covered" >ret=[];e</span>lse <span class="cstat-no" title="statement not covered" >if(isFunction(this._events[type]))<span class="cstat-no" title="statement not covered" >ret=[this._events[type]];e</span>lse <span class="cstat-no" title="statement not covered" >ret=this._events[type].slice();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn ret}</span>;EventEmitter.prototype.listenerCount=<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>if(this._events){<span class="cstat-no" title="statement not covered" >var evlistener=this._events[type];<span class="cstat-no" title="statement not covered" >i</span>f(isFunction(evlistener))<span class="cstat-no" title="statement not covered" >return 1;e</span>lse <span class="cstat-no" title="statement not covered" >if(evlistener)<span class="cstat-no" title="statement not covered" >return evlistener.length}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn 0}</span>;EventEmitter.listenerCount=<span class="fstat-no" title="function not covered" >function(emitter,type){<span class="cstat-no" title="statement not covered" ></span>return emitter.listenerCount(type)}</span>;<span class="fstat-no" title="function not covered" >function isFunction(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="function"}<span class="fstat-no" title="function not covered" ></span>function isNumber(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="number"}<span class="fstat-no" title="function not covered" ></span>function isObject(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="object"&amp;&amp;arg!==null}<span class="fstat-no" title="function not covered" ></span>function isUndefined(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===void 0}</span>},{}],21:[function(require,module,exports){exports.read=<span class="fstat-no" title="function not covered" >function(buffer,offset,isLE,mLen,nBytes){<span class="cstat-no" title="statement not covered" ></span>var e,m;<span class="cstat-no" title="statement not covered" >v</span>ar eLen=nBytes*8-mLen-1;<span class="cstat-no" title="statement not covered" >v</span>ar eMax=(1&lt;&lt;eLen)-1;<span class="cstat-no" title="statement not covered" >v</span>ar eBias=eMax&gt;&gt;1;<span class="cstat-no" title="statement not covered" >v</span>ar nBits=-7;<span class="cstat-no" title="statement not covered" >v</span>ar i=isLE?nBytes-1:0;<span class="cstat-no" title="statement not covered" >v</span>ar d=isLE?-1:1;<span class="cstat-no" title="statement not covered" >v</span>ar s=buffer[offset+i];<span class="cstat-no" title="statement not covered" >i</span>+=d;<span class="cstat-no" title="statement not covered" >e</span>=s&amp;(1&lt;&lt;-nBits)-1;<span class="cstat-no" title="statement not covered" >s</span>&gt;&gt;=-nBits;<span class="cstat-no" title="statement not covered" >n</span>Bits+=eLen;<span class="cstat-no" title="statement not covered" >f</span>or(;nBits&gt;0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}<span class="cstat-no" title="statement not covered" >m</span>=e&amp;(1&lt;&lt;-nBits)-1;<span class="cstat-no" title="statement not covered" >e</span>&gt;&gt;=-nBits;<span class="cstat-no" title="statement not covered" >n</span>Bits+=mLen;<span class="cstat-no" title="statement not covered" >f</span>or(;nBits&gt;0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}<span class="cstat-no" title="statement not covered" >i</span>f(e===0){<span class="cstat-no" title="statement not covered" >e=1-eBias}</span>else <span class="cstat-no" title="statement not covered" >if(e===eMax){<span class="cstat-no" title="statement not covered" >return m?NaN:(s?-1:1)*Infinity}</span>else{<span class="cstat-no" title="statement not covered" >m=m+Math.pow(2,mLen);<span class="cstat-no" title="statement not covered" >e</span>=e-eBias}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn(s?-1:1)*m*Math.pow(2,e-mLen)}</span>;exports.write=<span class="fstat-no" title="function not covered" >function(buffer,value,offset,isLE,mLen,nBytes){<span class="cstat-no" title="statement not covered" ></span>var e,m,c;<span class="cstat-no" title="statement not covered" >v</span>ar eLen=nBytes*8-mLen-1;<span class="cstat-no" title="statement not covered" >v</span>ar eMax=(1&lt;&lt;eLen)-1;<span class="cstat-no" title="statement not covered" >v</span>ar eBias=eMax&gt;&gt;1;<span class="cstat-no" title="statement not covered" >v</span>ar rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;<span class="cstat-no" title="statement not covered" >v</span>ar i=isLE?0:nBytes-1;<span class="cstat-no" title="statement not covered" >v</span>ar d=isLE?1:-1;<span class="cstat-no" title="statement not covered" >v</span>ar s=value&lt;0||value===0&amp;&amp;1/value&lt;0?1:0;<span class="cstat-no" title="statement not covered" >v</span>alue=Math.abs(value);<span class="cstat-no" title="statement not covered" >i</span>f(isNaN(value)||value===Infinity){<span class="cstat-no" title="statement not covered" >m=isNaN(value)?1:0;<span class="cstat-no" title="statement not covered" >e</span>=eMax}</span>else{<span class="cstat-no" title="statement not covered" >e=Math.floor(Math.log(value)/Math.LN2);<span class="cstat-no" title="statement not covered" >i</span>f(value*(c=Math.pow(2,-e))&lt;1){<span class="cstat-no" title="statement not covered" >e--;<span class="cstat-no" title="statement not covered" >c</span>*=2}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e+eBias&gt;=1){<span class="cstat-no" title="statement not covered" >value+=rt/c}</span>else{<span class="cstat-no" title="statement not covered" >value+=rt*Math.pow(2,1-eBias)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(value*c&gt;=2){<span class="cstat-no" title="statement not covered" >e++;<span class="cstat-no" title="statement not covered" >c</span>/=2}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e+eBias&gt;=eMax){<span class="cstat-no" title="statement not covered" >m=0;<span class="cstat-no" title="statement not covered" >e</span>=eMax}</span>else <span class="cstat-no" title="statement not covered" >if(e+eBias&gt;=1){<span class="cstat-no" title="statement not covered" >m=(value*c-1)*Math.pow(2,mLen);<span class="cstat-no" title="statement not covered" >e</span>=e+eBias}</span>else{<span class="cstat-no" title="statement not covered" >m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);<span class="cstat-no" title="statement not covered" >e</span>=0}</span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(;mLen&gt;=8;buffer[offset+i]=m&amp;255,i+=d,m/=256,mLen-=8){}<span class="cstat-no" title="statement not covered" >e</span>=e&lt;&lt;mLen|m;<span class="cstat-no" title="statement not covered" >e</span>Len+=mLen;<span class="cstat-no" title="statement not covered" >f</span>or(;eLen&gt;0;buffer[offset+i]=e&amp;255,i+=d,e/=256,eLen-=8){}<span class="cstat-no" title="statement not covered" >b</span>uffer[offset+i-d]|=s*128}</span>},{}],22:[function(require,module,exports){<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}else{<span class="cstat-no" title="statement not covered" >module.exports=<span class="fstat-no" title="function not covered" >function inherits(ctor,superCtor){<span class="cstat-no" title="statement not covered" ></span>ctor.super_=superCtor;<span class="cstat-no" title="statement not covered" >v</span>ar TempCtor=<span class="fstat-no" title="function not covered" >function(){</span>};<span class="cstat-no" title="statement not covered" >T</span>empCtor.prototype=superCtor.prototype;<span class="cstat-no" title="statement not covered" >c</span>tor.prototype=new TempCtor;<span class="cstat-no" title="statement not covered" >c</span>tor.prototype.constructor=ctor}</span>}</span>},{}],23:[function(require,module,exports){module.exports=<span class="fstat-no" title="function not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>return obj!=null&amp;&amp;(isBuffer(obj)||isSlowBuffer(obj)||!!obj._isBuffer)}</span>;<span class="fstat-no" title="function not covered" >function isBuffer(obj){<span class="cstat-no" title="statement not covered" ></span>return!!obj.constructor&amp;&amp;typeof obj.constructor.isBuffer==="function"&amp;&amp;obj.constructor.isBuffer(obj)}<span class="fstat-no" title="function not covered" ></span>function isSlowBuffer(obj){<span class="cstat-no" title="statement not covered" ></span>return typeof obj.readFloatLE==="function"&amp;&amp;typeof obj.slice==="function"&amp;&amp;isBuffer(obj.slice(0,0))}</span>},{}],24:[function(require,module,exports){(function(process,global){"use strict";var events=require("events");var Store=require("./store");var eos=require("end-of-stream");var mqttPacket=require("mqtt-packet");var Writable=require("readable-stream").Writable;var inherits=require("inherits");var reInterval=require("reinterval");var validations=require("./validations");var setImmediate=global.setImmediate||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(callback){<span class="cstat-no" title="statement not covered" ></span>process.nextTick(callback)}</span>;</span>var defaultConnectOptions={keepalive:60,reschedulePings:true,protocolId:"MQTT",protocolVersion:4,reconnectPeriod:1e3,connectTimeout:30*1e3,clean:true};<span class="fstat-no" title="function not covered" >function defaultId(){<span class="cstat-no" title="statement not covered" ></span>return"mqttjs_"+Math.random().toString(16).substr(2,8)}<span class="fstat-no" title="function not covered" ></span>function sendPacket(client,packet,cb){<span class="cstat-no" title="statement not covered" ></span>client.emit("packetsend",packet);<span class="cstat-no" title="statement not covered" >v</span>ar result=mqttPacket.writeToStream(packet,client.stream);<span class="cstat-no" title="statement not covered" >i</span>f(!result&amp;&amp;cb){<span class="cstat-no" title="statement not covered" >client.stream.once("drain",cb)}</span>else <span class="cstat-no" title="statement not covered" >if(cb){<span class="cstat-no" title="statement not covered" >cb()}</span>}<span class="fstat-no" title="function not covered" ></span></span>function storeAndSend(client,packet,cb){<span class="cstat-no" title="statement not covered" ></span>client.outgoingStore.put(packet,<span class="fstat-no" title="function not covered" >function storedPacket(err){<span class="cstat-no" title="statement not covered" ></span>if(err){<span class="cstat-no" title="statement not covered" >return cb&amp;&amp;cb(err)}<span class="cstat-no" title="statement not covered" ></span>s</span>endPacket(client,packet,cb)}</span>)}<span class="fstat-no" title="function not covered" ></span>function nop(){</span>}<span class="fstat-no" title="function not covered" >function MqttClient(streamBuilder,options){<span class="cstat-no" title="statement not covered" ></span>var k;<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >i</span>f(!(this instanceof MqttClient)){<span class="cstat-no" title="statement not covered" >return new MqttClient(streamBuilder,options)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.options=options||{};<span class="cstat-no" title="statement not covered" >f</span>or(k in defaultConnectOptions){<span class="cstat-no" title="statement not covered" >if(typeof this.options[k]==="undefined"){<span class="cstat-no" title="statement not covered" >this.options[k]=defaultConnectOptions[k]}</span>else{<span class="cstat-no" title="statement not covered" >this.options[k]=options[k]}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.options.clientId=this.options.clientId||defaultId();<span class="cstat-no" title="statement not covered" >t</span>his.streamBuilder=streamBuilder;<span class="cstat-no" title="statement not covered" >t</span>his.outgoingStore=this.options.outgoingStore||new Store;<span class="cstat-no" title="statement not covered" >t</span>his.incomingStore=this.options.incomingStore||new Store;<span class="cstat-no" title="statement not covered" >t</span>his.queueQoSZero=this.options.queueQoSZero===undefined?true:this.options.queueQoSZero;<span class="cstat-no" title="statement not covered" >t</span>his._subscribedTopics={};<span class="cstat-no" title="statement not covered" >t</span>his.pingTimer=null;<span class="cstat-no" title="statement not covered" >t</span>his.connected=false;<span class="cstat-no" title="statement not covered" >t</span>his.disconnecting=false;<span class="cstat-no" title="statement not covered" >t</span>his.queue=[];<span class="cstat-no" title="statement not covered" >t</span>his.connackTimer=null;<span class="cstat-no" title="statement not covered" >t</span>his.reconnectTimer=null;<span class="cstat-no" title="statement not covered" >t</span>his.nextId=Math.floor(Math.random()*65535);<span class="cstat-no" title="statement not covered" >t</span>his.outgoing={};<span class="cstat-no" title="statement not covered" >t</span>his.on("connect",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.disconnected){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>t</span>his.connected=true;<span class="cstat-no" title="statement not covered" >v</span>ar outStore=null;<span class="cstat-no" title="statement not covered" >o</span>utStore=this.outgoingStore.createStream();<span class="cstat-no" title="statement not covered" >o</span>utStore.once("readable",<span class="fstat-no" title="function not covered" >function(){<span class="fstat-no" title="function not covered" ></span>function storeDeliver(){<span class="cstat-no" title="statement not covered" ></span>var packet=outStore.read(1);<span class="cstat-no" title="statement not covered" >v</span>ar cb;<span class="cstat-no" title="statement not covered" >i</span>f(!packet){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!that.disconnecting&amp;&amp;!that.reconnectTimer&amp;&amp;that.options.reconnectPeriod&gt;0){<span class="cstat-no" title="statement not covered" >outStore.read(0);<span class="cstat-no" title="statement not covered" >c</span>b=that.outgoing[packet.messageId];<span class="cstat-no" title="statement not covered" >t</span>hat.outgoing[packet.messageId]=<span class="fstat-no" title="function not covered" >function(err,status){<span class="cstat-no" title="statement not covered" ></span>if(cb){<span class="cstat-no" title="statement not covered" >cb(err,status)}<span class="cstat-no" title="statement not covered" ></span>s</span>toreDeliver()}</span>;<span class="cstat-no" title="statement not covered" >t</span>hat._sendPacket(packet)}</span>else <span class="cstat-no" title="statement not covered" >if(outStore.destroy){<span class="cstat-no" title="statement not covered" >outStore.destroy()}</span>}<span class="cstat-no" title="statement not covered" ></span></span>storeDeliver()}</span>).on("error",this.emit.bind(this,"error"))}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.on("close",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.connected=false;<span class="cstat-no" title="statement not covered" >c</span>learTimeout(this.connackTimer)}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.on("connect",this._setupPingTimer);<span class="cstat-no" title="statement not covered" >t</span>his.on("connect",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var queue=this.queue;<span class="fstat-no" title="function not covered" >f</span>unction deliver(){<span class="cstat-no" title="statement not covered" ></span>var entry=queue.shift();<span class="cstat-no" title="statement not covered" >v</span>ar packet=null;<span class="cstat-no" title="statement not covered" >i</span>f(!entry){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>p</span>acket=entry.packet;<span class="cstat-no" title="statement not covered" >t</span>hat._sendPacket(packet,<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>if(entry.cb){<span class="cstat-no" title="statement not covered" >entry.cb(err)}<span class="cstat-no" title="statement not covered" ></span>d</span>eliver()}</span>)}<span class="cstat-no" title="statement not covered" ></span>deliver()}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.on("connect",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.options.clean&amp;&amp;Object.keys(this._subscribedTopics).length&gt;0){<span class="cstat-no" title="statement not covered" >this.subscribe(this._subscribedTopics)}</span>}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.on("close",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(that.pingTimer!==null){<span class="cstat-no" title="statement not covered" >that.pingTimer.clear();<span class="cstat-no" title="statement not covered" >t</span>hat.pingTimer=null}</span>}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.on("close",this._setupReconnect);<span class="cstat-no" title="statement not covered" >e</span>vents.EventEmitter.call(this);<span class="cstat-no" title="statement not covered" >t</span>his._setupStream()}</span>inherits(MqttClient,events.EventEmitter);MqttClient.prototype._setupStream=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var connectPacket;<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >v</span>ar writable=new Writable;<span class="cstat-no" title="statement not covered" >v</span>ar parser=mqttPacket.parser(this.options);<span class="cstat-no" title="statement not covered" >v</span>ar completeParse=null;<span class="cstat-no" title="statement not covered" >v</span>ar packets=[];<span class="cstat-no" title="statement not covered" >t</span>his._clearReconnect();<span class="cstat-no" title="statement not covered" >t</span>his.stream=this.streamBuilder(this);<span class="cstat-no" title="statement not covered" >p</span>arser.on("packet",<span class="fstat-no" title="function not covered" >function(packet){<span class="cstat-no" title="statement not covered" ></span>packets.push(packet)}</span>);<span class="fstat-no" title="function not covered" >f</span>unction process(){<span class="cstat-no" title="statement not covered" ></span>var packet=packets.shift();<span class="cstat-no" title="statement not covered" >v</span>ar done=completeParse;<span class="cstat-no" title="statement not covered" >i</span>f(packet){<span class="cstat-no" title="statement not covered" >that._handlePacket(packet,process)}</span>else{<span class="cstat-no" title="statement not covered" >completeParse=null;<span class="cstat-no" title="statement not covered" >d</span>one()}</span>}<span class="cstat-no" title="statement not covered" ></span>writable._write=<span class="fstat-no" title="function not covered" >function(buf,enc,done){<span class="cstat-no" title="statement not covered" ></span>completeParse=done;<span class="cstat-no" title="statement not covered" >p</span>arser.parse(buf);<span class="cstat-no" title="statement not covered" >p</span>rocess()}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.stream.pipe(writable);<span class="cstat-no" title="statement not covered" >t</span>his.stream.on("error",nop);<span class="cstat-no" title="statement not covered" >e</span>os(this.stream,this.emit.bind(this,"close"));<span class="cstat-no" title="statement not covered" >c</span>onnectPacket=Object.create(this.options);<span class="cstat-no" title="statement not covered" >c</span>onnectPacket.cmd="connect";<span class="cstat-no" title="statement not covered" >s</span>endPacket(this,connectPacket);<span class="cstat-no" title="statement not covered" >p</span>arser.on("error",this.emit.bind(this,"error"));<span class="cstat-no" title="statement not covered" >t</span>his.stream.setMaxListeners(1e3);<span class="cstat-no" title="statement not covered" >c</span>learTimeout(this.connackTimer);<span class="cstat-no" title="statement not covered" >t</span>his.connackTimer=setTimeout(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>that._cleanUp(true)}</span>,this.options.connectTimeout)}</span>;MqttClient.prototype._handlePacket=<span class="fstat-no" title="function not covered" >function(packet,done){<span class="cstat-no" title="statement not covered" ></span>this.emit("packetreceive",packet);<span class="cstat-no" title="statement not covered" >s</span>witch(packet.cmd){case"publish":<span class="cstat-no" title="statement not covered" >this._handlePublish(packet,done);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"puback":case"pubrec":case"pubcomp":case"suback":case"unsuback":<span class="cstat-no" title="statement not covered" >this._handleAck(packet);<span class="cstat-no" title="statement not covered" >d</span>one();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"pubrel":<span class="cstat-no" title="statement not covered" >this._handlePubrel(packet,done);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"connack":<span class="cstat-no" title="statement not covered" >this._handleConnack(packet);<span class="cstat-no" title="statement not covered" >d</span>one();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"pingresp":<span class="cstat-no" title="statement not covered" >this._handlePingresp(packet);<span class="cstat-no" title="statement not covered" >d</span>one();<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >break}</span>}</span>;MqttClient.prototype._checkDisconnecting=<span class="fstat-no" title="function not covered" >function(callback){<span class="cstat-no" title="statement not covered" ></span>if(this.disconnecting){<span class="cstat-no" title="statement not covered" >if(callback){<span class="cstat-no" title="statement not covered" >callback(new Error("client disconnecting"))}</span>else{<span class="cstat-no" title="statement not covered" >this.emit("error",new Error("client disconnecting"))}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.disconnecting}</span>;MqttClient.prototype.publish=<span class="fstat-no" title="function not covered" >function(topic,message,opts,callback){<span class="cstat-no" title="statement not covered" ></span>var packet;<span class="cstat-no" title="statement not covered" >i</span>f(typeof opts==="function"){<span class="cstat-no" title="statement not covered" >callback=opts;<span class="cstat-no" title="statement not covered" >o</span>pts=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts){<span class="cstat-no" title="statement not covered" >opts={qos:0,retain:false}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._checkDisconnecting(callback)){<span class="cstat-no" title="statement not covered" >return this}<span class="cstat-no" title="statement not covered" ></span>p</span>acket={cmd:"publish",topic:topic,payload:message,qos:opts.qos,retain:opts.retain,messageId:this._nextId()};<span class="cstat-no" title="statement not covered" >s</span>witch(opts.qos){case 1:case 2:<span class="cstat-no" title="statement not covered" >this.outgoing[packet.messageId]=callback||nop;<span class="cstat-no" title="statement not covered" >t</span>his._sendPacket(packet);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this._sendPacket(packet,callback);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;MqttClient.prototype.subscribe=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var packet;<span class="cstat-no" title="statement not covered" >v</span>ar args=Array.prototype.slice.call(arguments);<span class="cstat-no" title="statement not covered" >v</span>ar subs=[];<span class="cstat-no" title="statement not covered" >v</span>ar obj=args.shift();<span class="cstat-no" title="statement not covered" >v</span>ar callback=args.pop()||nop;<span class="cstat-no" title="statement not covered" >v</span>ar opts=args.pop();<span class="cstat-no" title="statement not covered" >v</span>ar invalidTopic;<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >i</span>f(typeof obj==="string"){<span class="cstat-no" title="statement not covered" >obj=[obj]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof callback!=="function"){<span class="cstat-no" title="statement not covered" >opts=callback;<span class="cstat-no" title="statement not covered" >c</span>allback=nop}<span class="cstat-no" title="statement not covered" ></span>i</span>nvalidTopic=validations.validateTopics(obj);<span class="cstat-no" title="statement not covered" >i</span>f(invalidTopic!==null){<span class="cstat-no" title="statement not covered" >setImmediate(callback,new Error("Invalid topic "+invalidTopic));<span class="cstat-no" title="statement not covered" >r</span>eturn this}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._checkDisconnecting(callback)){<span class="cstat-no" title="statement not covered" >return this}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts){<span class="cstat-no" title="statement not covered" >opts={qos:0}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Array.isArray(obj)){<span class="cstat-no" title="statement not covered" >obj.forEach(<span class="fstat-no" title="function not covered" >function(topic){<span class="cstat-no" title="statement not covered" ></span>subs.push({topic:topic,qos:opts.qos})}</span>)}</span>else{<span class="cstat-no" title="statement not covered" >Object.keys(obj).forEach(<span class="fstat-no" title="function not covered" >function(k){<span class="cstat-no" title="statement not covered" ></span>subs.push({topic:k,qos:obj[k]})}</span>)}<span class="cstat-no" title="statement not covered" ></span>p</span>acket={cmd:"subscribe",subscriptions:subs,qos:1,retain:false,dup:false,messageId:this._nextId()};<span class="cstat-no" title="statement not covered" >t</span>his.outgoing[packet.messageId]=<span class="fstat-no" title="function not covered" >function(err,packet){<span class="cstat-no" title="statement not covered" ></span>if(!err){<span class="cstat-no" title="statement not covered" >subs.forEach(<span class="fstat-no" title="function not covered" >function(sub){<span class="cstat-no" title="statement not covered" ></span>that._subscribedTopics[sub.topic]=sub.qos}</span>);<span class="cstat-no" title="statement not covered" >v</span>ar granted=packet.granted;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;granted.length;i+=1){<span class="cstat-no" title="statement not covered" >subs[i].qos=granted[i]}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>allback(err,subs)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his._sendPacket(packet);<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;MqttClient.prototype.unsubscribe=<span class="fstat-no" title="function not covered" >function(topic,callback){<span class="cstat-no" title="statement not covered" ></span>var packet={cmd:"unsubscribe",qos:1,messageId:this._nextId()};<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >c</span>allback=callback||nop;<span class="cstat-no" title="statement not covered" >i</span>f(this._checkDisconnecting(callback)){<span class="cstat-no" title="statement not covered" >return this}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof topic==="string"){<span class="cstat-no" title="statement not covered" >packet.unsubscriptions=[topic]}</span>else <span class="cstat-no" title="statement not covered" >if(typeof topic==="object"&amp;&amp;topic.length){<span class="cstat-no" title="statement not covered" >packet.unsubscriptions=topic}<span class="cstat-no" title="statement not covered" ></span>p</span></span>acket.unsubscriptions.forEach(<span class="fstat-no" title="function not covered" >function(topic){<span class="cstat-no" title="statement not covered" ></span>delete that._subscribedTopics[topic]}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.outgoing[packet.messageId]=callback;<span class="cstat-no" title="statement not covered" >t</span>his._sendPacket(packet);<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;MqttClient.prototype.end=<span class="fstat-no" title="function not covered" >function(force,cb){<span class="cstat-no" title="statement not covered" ></span>var that=this;<span class="cstat-no" title="statement not covered" >i</span>f(typeof force==="function"){<span class="cstat-no" title="statement not covered" >cb=force;<span class="cstat-no" title="statement not covered" >f</span>orce=false}<span class="fstat-no" title="function not covered" ></span>f</span>unction closeStores(){<span class="cstat-no" title="statement not covered" ></span>that.disconnected=true;<span class="cstat-no" title="statement not covered" >t</span>hat.incomingStore.close(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>that.outgoingStore.close(cb)}</span>)}<span class="fstat-no" title="function not covered" ></span>function finish(){<span class="cstat-no" title="statement not covered" ></span>that._cleanUp(force,setImmediate.bind(null,closeStores))}<span class="cstat-no" title="statement not covered" ></span>if(this.disconnecting){<span class="cstat-no" title="statement not covered" >return this}<span class="cstat-no" title="statement not covered" ></span>t</span>his._clearReconnect();<span class="cstat-no" title="statement not covered" >t</span>his.disconnecting=true;<span class="cstat-no" title="statement not covered" >i</span>f(!force&amp;&amp;Object.keys(this.outgoing).length&gt;0){<span class="cstat-no" title="statement not covered" >this.once("outgoingEmpty",setTimeout.bind(null,finish,10))}</span>else{<span class="cstat-no" title="statement not covered" >finish()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;MqttClient.prototype._reconnect=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.emit("reconnect");<span class="cstat-no" title="statement not covered" >t</span>his._setupStream()}</span>;MqttClient.prototype._setupReconnect=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var that=this;<span class="cstat-no" title="statement not covered" >i</span>f(!that.disconnecting&amp;&amp;!that.reconnectTimer&amp;&amp;that.options.reconnectPeriod&gt;0){<span class="cstat-no" title="statement not covered" >if(!this.reconnecting){<span class="cstat-no" title="statement not covered" >this.emit("offline");<span class="cstat-no" title="statement not covered" >t</span>his.reconnecting=true}<span class="cstat-no" title="statement not covered" ></span>t</span>hat.reconnectTimer=setInterval(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>that._reconnect()}</span>,that.options.reconnectPeriod)}</span>}</span>;MqttClient.prototype._clearReconnect=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.reconnectTimer){<span class="cstat-no" title="statement not covered" >clearInterval(this.reconnectTimer);<span class="cstat-no" title="statement not covered" >t</span>his.reconnectTimer=null}</span>}</span>;MqttClient.prototype._cleanUp=<span class="fstat-no" title="function not covered" >function(forced,done){<span class="cstat-no" title="statement not covered" ></span>if(done){<span class="cstat-no" title="statement not covered" >this.stream.on("close",done)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(forced){<span class="cstat-no" title="statement not covered" >this.stream.destroy()}</span>else{<span class="cstat-no" title="statement not covered" >this._sendPacket({cmd:"disconnect"},setImmediate.bind(null,this.stream.end.bind(this.stream)))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.disconnecting){<span class="cstat-no" title="statement not covered" >this._clearReconnect();<span class="cstat-no" title="statement not covered" >t</span>his._setupReconnect()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.pingTimer!==null){<span class="cstat-no" title="statement not covered" >this.pingTimer.clear();<span class="cstat-no" title="statement not covered" >t</span>his.pingTimer=null}</span>}</span>;MqttClient.prototype._sendPacket=<span class="fstat-no" title="function not covered" >function(packet,cb){<span class="cstat-no" title="statement not covered" ></span>if(!this.connected){<span class="cstat-no" title="statement not covered" >if(packet.qos&gt;0||packet.cmd!=="publish"||this.queueQoSZero){<span class="cstat-no" title="statement not covered" >this.queue.push({packet:packet,cb:cb})}</span>else <span class="cstat-no" title="statement not covered" >if(cb){<span class="cstat-no" title="statement not covered" >cb(new Error("No connection to broker"))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his._shiftPingInterval();<span class="cstat-no" title="statement not covered" >i</span>f(packet.cmd!=="publish"){<span class="cstat-no" title="statement not covered" >sendPacket(this,packet,cb);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(packet.qos){case 2:case 1:<span class="cstat-no" title="statement not covered" >storeAndSend(this,packet,cb);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 0:default:<span class="cstat-no" title="statement not covered" >sendPacket(this,packet,cb);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>;MqttClient.prototype._setupPingTimer=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var that=this;<span class="cstat-no" title="statement not covered" >i</span>f(!this.pingTimer&amp;&amp;this.options.keepalive){<span class="cstat-no" title="statement not covered" >this.pingResp=true;<span class="cstat-no" title="statement not covered" >t</span>his.pingTimer=reInterval(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>that._checkPing()}</span>,this.options.keepalive*1e3)}</span>}</span>;MqttClient.prototype._shiftPingInterval=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.pingTimer&amp;&amp;this.options.keepalive&amp;&amp;this.options.reschedulePings){<span class="cstat-no" title="statement not covered" >this.pingTimer.reschedule(this.options.keepalive*1e3)}</span>}</span>;MqttClient.prototype._checkPing=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.pingResp){<span class="cstat-no" title="statement not covered" >this.pingResp=false;<span class="cstat-no" title="statement not covered" >t</span>his._sendPacket({cmd:"pingreq"})}</span>else{<span class="cstat-no" title="statement not covered" >this._cleanUp(true)}</span>}</span>;MqttClient.prototype._handlePingresp=<span class="fstat-no" title="function not covered" >function(){</span>
<span class="cstat-no" title="statement not covered" >this.pingResp=true}</span>;MqttClient.prototype._handleConnack=<span class="fstat-no" title="function not covered" >function(packet){<span class="cstat-no" title="statement not covered" ></span>var rc=packet.returnCode;<span class="cstat-no" title="statement not covered" >v</span>ar errors=["","Unacceptable protocol version","Identifier rejected","Server unavailable","Bad username or password","Not authorized"];<span class="cstat-no" title="statement not covered" >c</span>learTimeout(this.connackTimer);<span class="cstat-no" title="statement not covered" >i</span>f(rc===0){<span class="cstat-no" title="statement not covered" >this.reconnecting=false;<span class="cstat-no" title="statement not covered" >t</span>his.emit("connect",packet)}</span>else <span class="cstat-no" title="statement not covered" >if(rc&gt;0){<span class="cstat-no" title="statement not covered" >this.emit("error",new Error("Connection refused: "+errors[rc]))}</span>}</span></span>;MqttClient.prototype._handlePublish=<span class="fstat-no" title="function not covered" >function(packet,done){<span class="cstat-no" title="statement not covered" ></span>var topic=packet.topic.toString();<span class="cstat-no" title="statement not covered" >v</span>ar message=packet.payload;<span class="cstat-no" title="statement not covered" >v</span>ar qos=packet.qos;<span class="cstat-no" title="statement not covered" >v</span>ar mid=packet.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >s</span>witch(qos){case 2:<span class="cstat-no" title="statement not covered" >this.incomingStore.put(packet,<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>that._sendPacket({cmd:"pubrec",messageId:mid},done)}</span>);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >this._sendPacket({cmd:"puback",messageId:mid});c</span>ase 0:<span class="cstat-no" title="statement not covered" >this.emit("message",topic,message,packet);<span class="cstat-no" title="statement not covered" >t</span>his.handleMessage(packet,done);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >break}</span>}</span>;MqttClient.prototype.handleMessage=<span class="fstat-no" title="function not covered" >function(packet,callback){<span class="cstat-no" title="statement not covered" ></span>callback()}</span>;MqttClient.prototype._handleAck=<span class="fstat-no" title="function not covered" >function(packet){<span class="cstat-no" title="statement not covered" ></span>var mid=packet.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar type=packet.cmd;<span class="cstat-no" title="statement not covered" >v</span>ar response=null;<span class="cstat-no" title="statement not covered" >v</span>ar cb=this.outgoing[mid];<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >i</span>f(!cb){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(type){case"pubcomp":case"puback":<span class="cstat-no" title="statement not covered" >delete this.outgoing[mid];<span class="cstat-no" title="statement not covered" >t</span>his.outgoingStore.del(packet,cb);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"pubrec":<span class="cstat-no" title="statement not covered" >response={cmd:"pubrel",qos:2,messageId:mid};<span class="cstat-no" title="statement not covered" >t</span>his._sendPacket(response);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"suback":<span class="cstat-no" title="statement not covered" >delete this.outgoing[mid];<span class="cstat-no" title="statement not covered" >c</span>b(null,packet);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"unsuback":<span class="cstat-no" title="statement not covered" >delete this.outgoing[mid];<span class="cstat-no" title="statement not covered" >c</span>b(null);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >that.emit("error",new Error("unrecognized packet type"))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.disconnecting&amp;&amp;Object.keys(this.outgoing).length===0){<span class="cstat-no" title="statement not covered" >this.emit("outgoingEmpty")}</span>}</span>;MqttClient.prototype._handlePubrel=<span class="fstat-no" title="function not covered" >function(packet,callback){<span class="cstat-no" title="statement not covered" ></span>var mid=packet.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar that=this;<span class="cstat-no" title="statement not covered" >t</span>hat.incomingStore.get(packet,<span class="fstat-no" title="function not covered" >function(err,pub){<span class="cstat-no" title="statement not covered" ></span>if(err){<span class="cstat-no" title="statement not covered" >return that.emit("error",err)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(pub.cmd!=="pubrel"){<span class="cstat-no" title="statement not covered" >that.emit("message",pub.topic,pub.payload,pub);<span class="cstat-no" title="statement not covered" >t</span>hat.incomingStore.put(packet)}<span class="cstat-no" title="statement not covered" ></span>t</span>hat._sendPacket({cmd:"pubcomp",messageId:mid},callback)}</span>)}</span>;MqttClient.prototype._nextId=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var id=this.nextId++;<span class="cstat-no" title="statement not covered" >i</span>f(id===65535){<span class="cstat-no" title="statement not covered" >this.nextId=1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn id}</span>;module.exports=MqttClient}).call(this,require("_process"),typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})</span>},{"./store":28,"./validations":29,_process:48,"end-of-stream":18,events:20,inherits:22,"mqtt-packet":34,"readable-stream":46,reinterval:53}],25:[<span class="fstat-no" title="function not covered" >function(require,module,exports){</span>"use strict";<span class="cstat-no" title="statement not covered" >var net=require("net");<span class="fstat-no" title="function not covered" >f</span>unction buildBuilder(client,opts){<span class="cstat-no" title="statement not covered" ></span>var port,host;<span class="cstat-no" title="statement not covered" >o</span>pts.port=opts.port||1883;<span class="cstat-no" title="statement not covered" >o</span>pts.hostname=opts.hostname||opts.host||"localhost";<span class="cstat-no" title="statement not covered" >p</span>ort=opts.port;<span class="cstat-no" title="statement not covered" >h</span>ost=opts.hostname;<span class="cstat-no" title="statement not covered" >r</span>eturn net.createConnection(port,host)}<span class="cstat-no" title="statement not covered" ></span>module.exports=buildBuilder}</span>,{net:2}],26:[<span class="fstat-no" title="function not covered" >function(require,module,exports){</span>"use strict";<span class="cstat-no" title="statement not covered" >var tls=require("tls");<span class="fstat-no" title="function not covered" >f</span>unction buildBuilder(mqttClient,opts){<span class="cstat-no" title="statement not covered" ></span>var connection;<span class="cstat-no" title="statement not covered" >o</span>pts.port=opts.port||8883;<span class="cstat-no" title="statement not covered" >o</span>pts.host=opts.hostname||opts.host||"localhost";<span class="cstat-no" title="statement not covered" >o</span>pts.rejectUnauthorized=opts.rejectUnauthorized!==false;<span class="cstat-no" title="statement not covered" >c</span>onnection=tls.connect(opts);<span class="cstat-no" title="statement not covered" >c</span>onnection.on("secureConnect",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(opts.rejectUnauthorized&amp;&amp;!connection.authorized){<span class="cstat-no" title="statement not covered" >connection.emit("error",new Error("TLS not authorized"))}</span>else{<span class="cstat-no" title="statement not covered" >connection.removeListener("error",handleTLSerrors)}</span>}</span>);<span class="fstat-no" title="function not covered" >f</span>unction handleTLSerrors(err){<span class="cstat-no" title="statement not covered" ></span>if(opts.rejectUnauthorized){<span class="cstat-no" title="statement not covered" >mqttClient.emit("error",err)}<span class="cstat-no" title="statement not covered" ></span>c</span>onnection.end()}<span class="cstat-no" title="statement not covered" ></span>connection.on("error",handleTLSerrors);<span class="cstat-no" title="statement not covered" >r</span>eturn connection}<span class="cstat-no" title="statement not covered" ></span>module.exports=buildBuilder}</span>,{tls:2}],27:[function(require,module,exports){(function(process){"use strict";var websocket=require("websocket-stream");<span class="cstat-no" title="statement not covered" >var _URL=require("url");<span class="cstat-no" title="statement not covered" >v</span>ar wssProperties=["rejectUnauthorized","ca","cert","key","pfx","passphrase"];<span class="fstat-no" title="function not covered" >f</span>unction buildBuilder(client,opts){<span class="cstat-no" title="statement not covered" ></span>var wsOpt={protocol:"mqtt"};<span class="cstat-no" title="statement not covered" >i</span>f(!opts.wsOptions){<span class="cstat-no" title="statement not covered" >opts.wsOptions={}}<span class="cstat-no" title="statement not covered" ></span>v</span>ar host=opts.hostname||"localhost";<span class="cstat-no" title="statement not covered" >v</span>ar path=opts.path||"/";<span class="cstat-no" title="statement not covered" >i</span>f(!opts.port){<span class="cstat-no" title="statement not covered" >if(opts.protocol==="wss"){<span class="cstat-no" title="statement not covered" >opts.port=443}</span>else{<span class="cstat-no" title="statement not covered" >opts.port=80}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar url=opts.protocol+"://"+host+":"+opts.port+path;<span class="cstat-no" title="statement not covered" >i</span>f(opts.protocolId==="MQIsdp"&amp;&amp;opts.protocolVersion===3){<span class="cstat-no" title="statement not covered" >wsOpt.protocol="mqttv3.1"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(opts.protocol==="wss"){<span class="cstat-no" title="statement not covered" >wssProperties.forEach(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>if(opts.hasOwnProperty(prop)&amp;&amp;!opts.wsOptions.hasOwnProperty(prop)){<span class="cstat-no" title="statement not covered" >opts.wsOptions[prop]=opts[prop]}</span>}</span>)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn websocket(url,[wsOpt.protocol],opts.wsOptions)}<span class="fstat-no" title="function not covered" ></span>function buildBuilderBrowser(mqttClient,opts){<span class="cstat-no" title="statement not covered" ></span>var wsOpt={protocol:"mqtt"};<span class="cstat-no" title="statement not covered" >v</span>ar url;<span class="cstat-no" title="statement not covered" >v</span>ar parsed;<span class="cstat-no" title="statement not covered" >i</span>f(typeof document!=="undefined"){<span class="cstat-no" title="statement not covered" >parsed=_URL.parse(document.URL)}</span>else{<span class="cstat-no" title="statement not covered" >throw new Error("Could not determine host. Specify host manually.")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts.protocol){<span class="cstat-no" title="statement not covered" >if(parsed.protocol==="https:"){<span class="cstat-no" title="statement not covered" >opts.protocol="wss"}</span>else{<span class="cstat-no" title="statement not covered" >opts.protocol="ws"}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts.hostname){<span class="cstat-no" title="statement not covered" >opts.hostname=opts.host}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts.hostname){<span class="cstat-no" title="statement not covered" >opts.hostname=parsed.hostname;<span class="cstat-no" title="statement not covered" >i</span>f(!opts.port){<span class="cstat-no" title="statement not covered" >opts.port=parsed.port}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(opts.protocolId==="MQIsdp"&amp;&amp;opts.protocolVersion===3){<span class="cstat-no" title="statement not covered" >wsOpt.protocol="mqttv3.1"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts.port){<span class="cstat-no" title="statement not covered" >if(opts.protocol==="wss"){<span class="cstat-no" title="statement not covered" >opts.port=443}</span>else{<span class="cstat-no" title="statement not covered" >opts.port=80}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!opts.path){<span class="cstat-no" title="statement not covered" >opts.path="/"}<span class="cstat-no" title="statement not covered" ></span>u</span>rl=opts.protocol+"://"+opts.hostname+":"+opts.port+opts.path;<span class="cstat-no" title="statement not covered" >r</span>eturn websocket(url,wsOpt)}<span class="cstat-no" title="statement not covered" ></span>if(process.title!=="browser"){<span class="cstat-no" title="statement not covered" >module.exports=buildBuilder}</span>else{<span class="cstat-no" title="statement not covered" >module.exports=buildBuilderBrowser}</span>}</span>).call(this,require("_process"))},{_process:48,url:63,"websocket-stream":69}],28:[function(require,module,exports){(function(process){"use strict";var Readable=require("readable-stream").Readable;var streamsOpts={objectMode:true};<span class="fstat-no" title="function not covered" >function Store(){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof Store)){<span class="cstat-no" title="statement not covered" >return new Store}<span class="cstat-no" title="statement not covered" ></span>t</span>his._inflights={}}</span>Store.prototype.put=<span class="fstat-no" title="function not covered" >function(packet,cb){<span class="cstat-no" title="statement not covered" ></span>this._inflights[packet.messageId]=packet;<span class="cstat-no" title="statement not covered" >i</span>f(cb){<span class="cstat-no" title="statement not covered" >cb()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;Store.prototype.createStream=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var stream=new Readable(streamsOpts);<span class="cstat-no" title="statement not covered" >v</span>ar inflights=this._inflights;<span class="cstat-no" title="statement not covered" >v</span>ar ids=Object.keys(this._inflights);<span class="cstat-no" title="statement not covered" >v</span>ar destroyed=false;<span class="cstat-no" title="statement not covered" >v</span>ar i=0;<span class="cstat-no" title="statement not covered" >s</span>tream._read=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!destroyed&amp;&amp;i&lt;ids.length){<span class="cstat-no" title="statement not covered" >this.push(inflights[ids[i++]])}</span>else{<span class="cstat-no" title="statement not covered" >this.push(null)}</span>}</span>;<span class="cstat-no" title="statement not covered" >s</span>tream.destroy=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(destroyed){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>v</span>ar self=this;<span class="cstat-no" title="statement not covered" >d</span>estroyed=true;<span class="cstat-no" title="statement not covered" >p</span>rocess.nextTick(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>self.emit("close")}</span>)}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn stream}</span>;Store.prototype.del=<span class="fstat-no" title="function not covered" >function(packet,cb){<span class="cstat-no" title="statement not covered" ></span>packet=this._inflights[packet.messageId];<span class="cstat-no" title="statement not covered" >i</span>f(packet){<span class="cstat-no" title="statement not covered" >delete this._inflights[packet.messageId];<span class="cstat-no" title="statement not covered" >c</span>b(null,packet)}</span>else <span class="cstat-no" title="statement not covered" >if(cb){<span class="cstat-no" title="statement not covered" >cb(new Error("missing packet"))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this}</span>;Store.prototype.get=<span class="fstat-no" title="function not covered" >function(packet,cb){<span class="cstat-no" title="statement not covered" ></span>packet=this._inflights[packet.messageId];<span class="cstat-no" title="statement not covered" >i</span>f(packet){<span class="cstat-no" title="statement not covered" >cb(null,packet)}</span>else <span class="cstat-no" title="statement not covered" >if(cb){<span class="cstat-no" title="statement not covered" >cb(new Error("missing packet"))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this}</span>;Store.prototype.close=<span class="fstat-no" title="function not covered" >function(cb){<span class="cstat-no" title="statement not covered" ></span>this._inflights=null;<span class="cstat-no" title="statement not covered" >i</span>f(cb){<span class="cstat-no" title="statement not covered" >cb()}</span>}</span>;module.exports=Store}).call(this,require("_process"))},{_process:48,"readable-stream":46}],29:[function(require,module,exports){"use strict";<span class="fstat-no" title="function not covered" >function validateTopic(topic){<span class="cstat-no" title="statement not covered" ></span>var parts=topic.split("/");<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;parts.length;i++){<span class="cstat-no" title="statement not covered" >if(parts[i]==="+"){<span class="cstat-no" title="statement not covered" >continue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parts[i]==="#"){<span class="cstat-no" title="statement not covered" >return i===parts.length-1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parts[i].indexOf("+")!==-1||parts[i].indexOf("#")!==-1){<span class="cstat-no" title="statement not covered" >return false}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true}<span class="fstat-no" title="function not covered" ></span>function validateTopics(topics){<span class="cstat-no" title="statement not covered" ></span>if(topics.length===0){<span class="cstat-no" title="statement not covered" >return"empty_topic_list"}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;topics.length;i++){<span class="cstat-no" title="statement not covered" >if(!validateTopic(topics[i])){<span class="cstat-no" title="statement not covered" >return topics[i]}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>module.exports={validateTopics:validateTopics}},{}],30:[function(require,module,exports){(function(Buffer){var DuplexStream=require("readable-stream/duplex"),util=require("util");<span class="fstat-no" title="function not covered" >function BufferList(callback){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof BufferList))<span class="cstat-no" title="statement not covered" >return new BufferList(callback);<span class="cstat-no" title="statement not covered" >t</span></span>his._bufs=[];<span class="cstat-no" title="statement not covered" >t</span>his.length=0;<span class="cstat-no" title="statement not covered" >i</span>f(typeof callback=="function"){<span class="cstat-no" title="statement not covered" >this._callback=callback;<span class="cstat-no" title="statement not covered" >v</span>ar piper=<span class="fstat-no" title="function not covered" >function piper(err){<span class="cstat-no" title="statement not covered" ></span>if(this._callback){<span class="cstat-no" title="statement not covered" >this._callback(err);<span class="cstat-no" title="statement not covered" >t</span>his._callback=null}</span>}</span>.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his.on("pipe",<span class="fstat-no" title="function not covered" >function onPipe(src){<span class="cstat-no" title="statement not covered" ></span>src.on("error",piper)}</span>);<span class="cstat-no" title="statement not covered" >t</span>his.on("unpipe",<span class="fstat-no" title="function not covered" >function onUnpipe(src){<span class="cstat-no" title="statement not covered" ></span>src.removeListener("error",piper)}</span>)}</span>else{<span class="cstat-no" title="statement not covered" >this.append(callback)}<span class="cstat-no" title="statement not covered" ></span>D</span>uplexStream.call(this)}</span>util.inherits(BufferList,DuplexStream);BufferList.prototype._offset=<span class="fstat-no" title="function not covered" >function _offset(offset){<span class="cstat-no" title="statement not covered" ></span>var tot=0,i=0,_t;<span class="cstat-no" title="statement not covered" >i</span>f(offset===0)<span class="cstat-no" title="statement not covered" >return[0,0];<span class="cstat-no" title="statement not covered" >f</span></span>or(;i&lt;this._bufs.length;i++){<span class="cstat-no" title="statement not covered" >_t=tot+this._bufs[i].length;<span class="cstat-no" title="statement not covered" >i</span>f(offset&lt;_t||i==this._bufs.length-1)<span class="cstat-no" title="statement not covered" >return[i,offset-tot];<span class="cstat-no" title="statement not covered" >t</span></span>ot=_t}</span>}</span>;BufferList.prototype.append=<span class="fstat-no" title="function not covered" >function append(buf){<span class="cstat-no" title="statement not covered" ></span>var i=0;<span class="cstat-no" title="statement not covered" >i</span>f(Buffer.isBuffer(buf)){<span class="cstat-no" title="statement not covered" >this._appendBuffer(buf)}</span>else <span class="cstat-no" title="statement not covered" >if(Array.isArray(buf)){<span class="cstat-no" title="statement not covered" >for(;i&lt;buf.length;i++)<span class="cstat-no" title="statement not covered" >this.append(buf[i])}</span></span>else <span class="cstat-no" title="statement not covered" >if(buf instanceof BufferList){<span class="cstat-no" title="statement not covered" >for(;i&lt;buf._bufs.length;i++)<span class="cstat-no" title="statement not covered" >this.append(buf._bufs[i])}</span></span>else <span class="cstat-no" title="statement not covered" >if(buf!=null){<span class="cstat-no" title="statement not covered" >if(typeof buf=="number")<span class="cstat-no" title="statement not covered" >buf=buf.toString();<span class="cstat-no" title="statement not covered" >t</span></span>his._appendBuffer(new Buffer(buf))}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn this}</span>;BufferList.prototype._appendBuffer=<span class="fstat-no" title="function not covered" >function appendBuffer(buf){<span class="cstat-no" title="statement not covered" ></span>this._bufs.push(buf);<span class="cstat-no" title="statement not covered" >t</span>his.length+=buf.length}</span>;BufferList.prototype._write=<span class="fstat-no" title="function not covered" >function _write(buf,encoding,callback){<span class="cstat-no" title="statement not covered" ></span>this._appendBuffer(buf);<span class="cstat-no" title="statement not covered" >i</span>f(typeof callback=="function")<span class="cstat-no" title="statement not covered" >callback()}</span></span>;BufferList.prototype._read=<span class="fstat-no" title="function not covered" >function _read(size){<span class="cstat-no" title="statement not covered" ></span>if(!this.length)<span class="cstat-no" title="statement not covered" >return this.push(null);<span class="cstat-no" title="statement not covered" >s</span></span>ize=Math.min(size,this.length);<span class="cstat-no" title="statement not covered" >t</span>his.push(this.slice(0,size));<span class="cstat-no" title="statement not covered" >t</span>his.consume(size)}</span>;BufferList.prototype.end=<span class="fstat-no" title="function not covered" >function end(chunk){<span class="cstat-no" title="statement not covered" ></span>DuplexStream.prototype.end.call(this,chunk);<span class="cstat-no" title="statement not covered" >i</span>f(this._callback){<span class="cstat-no" title="statement not covered" >this._callback(null,this.slice());<span class="cstat-no" title="statement not covered" >t</span>his._callback=null}</span>}</span>;BufferList.prototype.get=<span class="fstat-no" title="function not covered" >function get(index){<span class="cstat-no" title="statement not covered" ></span>return this.slice(index,index+1)[0]}</span>;BufferList.prototype.slice=<span class="fstat-no" title="function not covered" >function slice(start,end){<span class="cstat-no" title="statement not covered" ></span>if(typeof start=="number"&amp;&amp;start&lt;0)<span class="cstat-no" title="statement not covered" >start+=this.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof end=="number"&amp;&amp;end&lt;0)<span class="cstat-no" title="statement not covered" >end+=this.length;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.copy(null,0,start,end)}</span>;BufferList.prototype.copy=<span class="fstat-no" title="function not covered" >function copy(dst,dstStart,srcStart,srcEnd){<span class="cstat-no" title="statement not covered" ></span>if(typeof srcStart!="number"||srcStart&lt;0)<span class="cstat-no" title="statement not covered" >srcStart=0;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof srcEnd!="number"||srcEnd&gt;this.length)<span class="cstat-no" title="statement not covered" >srcEnd=this.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(srcStart&gt;=this.length)<span class="cstat-no" title="statement not covered" >return dst||new Buffer(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(srcEnd&lt;=0)<span class="cstat-no" title="statement not covered" >return dst||new Buffer(0);<span class="cstat-no" title="statement not covered" >v</span></span>ar copy=!!dst,off=this._offset(srcStart),len=srcEnd-srcStart,bytes=len,bufoff=copy&amp;&amp;dstStart||0,start=off[1],l,i;<span class="cstat-no" title="statement not covered" >i</span>f(srcStart===0&amp;&amp;srcEnd==this.length){<span class="cstat-no" title="statement not covered" >if(!copy){<span class="cstat-no" title="statement not covered" >return this._bufs.length===1?this._bufs[0]:Buffer.concat(this._bufs,this.length)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;this._bufs.length;i++){<span class="cstat-no" title="statement not covered" >this._bufs[i].copy(dst,bufoff);<span class="cstat-no" title="statement not covered" >b</span>ufoff+=this._bufs[i].length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn dst}<span class="cstat-no" title="statement not covered" ></span>i</span>f(bytes&lt;=this._bufs[off[0]].length-start){<span class="cstat-no" title="statement not covered" >return copy?this._bufs[off[0]].copy(dst,dstStart,start,start+bytes):this._bufs[off[0]].slice(start,start+bytes)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!copy)<span class="cstat-no" title="statement not covered" >dst=new Buffer(len);<span class="cstat-no" title="statement not covered" >f</span></span>or(i=off[0];i&lt;this._bufs.length;i++){<span class="cstat-no" title="statement not covered" >l=this._bufs[i].length-start;<span class="cstat-no" title="statement not covered" >i</span>f(bytes&gt;l){<span class="cstat-no" title="statement not covered" >this._bufs[i].copy(dst,bufoff,start)}</span>else{<span class="cstat-no" title="statement not covered" >this._bufs[i].copy(dst,bufoff,start,start+bytes);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>b</span>ufoff+=l;<span class="cstat-no" title="statement not covered" >b</span>ytes-=l;<span class="cstat-no" title="statement not covered" >i</span>f(start)<span class="cstat-no" title="statement not covered" >start=0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn dst}</span>;BufferList.prototype.shallowSlice=<span class="fstat-no" title="function not covered" >function shallowSlice(start,end){<span class="cstat-no" title="statement not covered" ></span>start=start||0;<span class="cstat-no" title="statement not covered" >e</span>nd=end||this.length;<span class="cstat-no" title="statement not covered" >i</span>f(start&lt;0)<span class="cstat-no" title="statement not covered" >start+=this.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(end&lt;0)<span class="cstat-no" title="statement not covered" >end+=this.length;<span class="cstat-no" title="statement not covered" >v</span></span>ar startOffset=this._offset(start),endOffset=this._offset(end),buffers=this._bufs.slice(startOffset[0],endOffset[0]+1);<span class="cstat-no" title="statement not covered" >i</span>f(startOffset[1]!=0)<span class="cstat-no" title="statement not covered" >buffers[0]=buffers[0].slice(startOffset[1]);<span class="cstat-no" title="statement not covered" >i</span></span>f(endOffset[1]==0)<span class="cstat-no" title="statement not covered" >buffers.pop();e</span>lse <span class="cstat-no" title="statement not covered" >buffers[buffers.length-1]=buffers[buffers.length-1].slice(0,endOffset[1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new BufferList(buffers)}</span>;BufferList.prototype.toString=<span class="fstat-no" title="function not covered" >function toString(encoding,start,end){<span class="cstat-no" title="statement not covered" ></span>return this.slice(start,end).toString(encoding)}</span>;BufferList.prototype.consume=<span class="fstat-no" title="function not covered" >function consume(bytes){<span class="cstat-no" title="statement not covered" ></span>while(this._bufs.length){<span class="cstat-no" title="statement not covered" >if(bytes&gt;=this._bufs[0].length){<span class="cstat-no" title="statement not covered" >bytes-=this._bufs[0].length;<span class="cstat-no" title="statement not covered" >t</span>his.length-=this._bufs[0].length;<span class="cstat-no" title="statement not covered" >t</span>his._bufs.shift()}</span>else{<span class="cstat-no" title="statement not covered" >this._bufs[0]=this._bufs[0].slice(bytes);<span class="cstat-no" title="statement not covered" >t</span>his.length-=bytes;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;BufferList.prototype.duplicate=<span class="fstat-no" title="function not covered" >function duplicate(){<span class="cstat-no" title="statement not covered" ></span>var i=0,copy=new BufferList;<span class="cstat-no" title="statement not covered" >f</span>or(;i&lt;this._bufs.length;i++)<span class="cstat-no" title="statement not covered" >copy.append(this._bufs[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn copy}</span>;BufferList.prototype.destroy=<span class="fstat-no" title="function not covered" >function destroy(){<span class="cstat-no" title="statement not covered" ></span>this._bufs.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.push(null)}</span>;(function(){var methods={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1};for(var m in methods){(function(m){BufferList.prototype[m]=<span class="fstat-no" title="function not covered" >function(offset){<span class="cstat-no" title="statement not covered" ></span>return this.slice(offset,offset+methods[m])[m](0)}</span>})(m)}})();module.exports=BufferList}).call(this,require("buffer").Buffer)},{buffer:4,"readable-stream/duplex":39,util:68}],31:[function(require,module,exports){arguments[4][5][0].apply(exports,arguments)},{dup:5}],32:[function(require,module,exports){(function(Buffer){var protocol=module.exports;protocol.types={0:"reserved",1:"connect",2:"connack",3:"publish",4:"puback",5:"pubrec",6:"pubrel",7:"pubcomp",8:"subscribe",9:"suback",10:"unsubscribe",11:"unsuback",12:"pingreq",13:"pingresp",14:"disconnect",15:"reserved"};protocol.codes={};for(var k in protocol.types){var v=protocol.types[k];protocol.codes[v]=k}protocol.CMD_SHIFT=4;protocol.CMD_MASK=240;protocol.DUP_MASK=8;protocol.QOS_MASK=3;protocol.QOS_SHIFT=1;protocol.RETAIN_MASK=1;protocol.LENGTH_MASK=127;protocol.LENGTH_FIN_MASK=128;protocol.SESSIONPRESENT_MASK=1;protocol.SESSIONPRESENT_HEADER=new Buffer([protocol.SESSIONPRESENT_MASK]);protocol.CONNACK_HEADER=new Buffer([protocol.codes["connack"]&lt;&lt;protocol.CMD_SHIFT]);protocol.USERNAME_MASK=128;protocol.PASSWORD_MASK=64;protocol.WILL_RETAIN_MASK=32;protocol.WILL_QOS_MASK=24;protocol.WILL_QOS_SHIFT=3;protocol.WILL_FLAG_MASK=4;protocol.CLEAN_SESSION_MASK=2;protocol.CONNECT_HEADER=new Buffer([protocol.codes["connect"]&lt;&lt;protocol.CMD_SHIFT]);function genHeader(type){return[0,1,2].map(function(qos){return[0,1].map(function(dup){return[0,1].map(function(retain){var buf=new Buffer(1);buf.writeUInt8(protocol.codes[type]&lt;&lt;protocol.CMD_SHIFT|(dup?protocol.DUP_MASK:0)|qos&lt;&lt;protocol.QOS_SHIFT|retain,0,true);return buf})})})}protocol.PUBLISH_HEADER=genHeader("publish");protocol.SUBSCRIBE_HEADER=genHeader("subscribe");protocol.UNSUBSCRIBE_HEADER=genHeader("unsubscribe");protocol.ACKS={unsuback:genHeader("unsuback"),puback:genHeader("puback"),pubcomp:genHeader("pubcomp"),pubrel:genHeader("pubrel"),pubrec:genHeader("pubrec")};protocol.SUBACK_HEADER=new Buffer([protocol.codes["suback"]&lt;&lt;protocol.CMD_SHIFT]);protocol.VERSION3=new Buffer([3]);protocol.VERSION4=new Buffer([4]);protocol.QOS=[0,1,2].map(function(qos){return new Buffer([qos])});protocol.EMPTY={pingreq:new Buffer([protocol.codes["pingreq"]&lt;&lt;4,0]),pingresp:new Buffer([protocol.codes["pingresp"]&lt;&lt;4,0]),disconnect:new Buffer([protocol.codes["disconnect"]&lt;&lt;4,0])}}).call(this,require("buffer").Buffer)},{buffer:4}],33:[function(require,module,exports){(function(Buffer){"use strict";var writeToStream=require("./writeToStream");var EE=require("events").EventEmitter;var inherits=require("inherits");<span class="fstat-no" title="function not covered" >function generate(packet){<span class="cstat-no" title="statement not covered" ></span>var stream=new Accumulator;<span class="cstat-no" title="statement not covered" >w</span>riteToStream(packet,stream);<span class="cstat-no" title="statement not covered" >r</span>eturn stream.concat()}<span class="fstat-no" title="function not covered" ></span>function Accumulator(){<span class="cstat-no" title="statement not covered" ></span>this._array=new Array(20);<span class="cstat-no" title="statement not covered" >t</span>his._i=0}</span>inherits(Accumulator,EE);Accumulator.prototype.write=<span class="fstat-no" title="function not covered" >function(chunk){<span class="cstat-no" title="statement not covered" ></span>this._array[this._i++]=chunk;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>;Accumulator.prototype.concat=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var length=0;<span class="cstat-no" title="statement not covered" >v</span>ar lengths=new Array(this._array.length);<span class="cstat-no" title="statement not covered" >v</span>ar list=this._array;<span class="cstat-no" title="statement not covered" >v</span>ar pos=0;<span class="cstat-no" title="statement not covered" >v</span>ar i;<span class="cstat-no" title="statement not covered" >v</span>ar result;<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;list.length&amp;&amp;list[i];i++){<span class="cstat-no" title="statement not covered" >if(typeof list[i]!=="string")<span class="cstat-no" title="statement not covered" >lengths[i]=list[i].length;e</span>lse <span class="cstat-no" title="statement not covered" >lengths[i]=Buffer.byteLength(list[i]);<span class="cstat-no" title="statement not covered" >l</span></span>ength+=lengths[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>esult=new Buffer(length);<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;list.length&amp;&amp;list[i];i++){<span class="cstat-no" title="statement not covered" >if(typeof list[i]!=="string"){<span class="cstat-no" title="statement not covered" >list[i].copy(result,pos);<span class="cstat-no" title="statement not covered" >p</span>os+=lengths[i]}</span>else{<span class="cstat-no" title="statement not covered" >result.write(list[i],pos);<span class="cstat-no" title="statement not covered" >p</span>os+=lengths[i]}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result}</span>;module.exports=generate}).call(this,require("buffer").Buffer)},{"./writeToStream":38,buffer:4,events:20,inherits:22}],34:[function(require,module,exports){"use strict";exports.parser=require("./parser");exports.generate=require("./generate");exports.writeToStream=require("./writeToStream")},{"./generate":33,"./parser":37,"./writeToStream":38}],35:[function(require,module,exports){(function(Buffer){"use strict";var max=65536;var cache={};var buffer;for(var i=0;i&lt;max;i++){buffer=new Buffer(2);buffer.writeUInt8(i&gt;&gt;8,0,true);buffer.writeUInt8(i&amp;255,0+1,true);cache[i]=buffer}module.exports=cache}).call(this,require("buffer").Buffer)},{buffer:4}],36:[function(require,module,exports){<span class="fstat-no" title="function not covered" >function Packet(){<span class="cstat-no" title="statement not covered" ></span>this.cmd=null;<span class="cstat-no" title="statement not covered" >t</span>his.retain=false;<span class="cstat-no" title="statement not covered" >t</span>his.qos=0;<span class="cstat-no" title="statement not covered" >t</span>his.dup=false;<span class="cstat-no" title="statement not covered" >t</span>his.length=-1;<span class="cstat-no" title="statement not covered" >t</span>his.topic=null;<span class="cstat-no" title="statement not covered" >t</span>his.payload=null}</span>module.exports=Packet},{}],37:[function(require,module,exports){"use strict";var bl=require("bl");var inherits=require("inherits");var EE=require("events").EventEmitter;var Packet=require("./packet");var constants=require("./constants");<span class="fstat-no" title="function not covered" >function Parser(){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof Parser))<span class="cstat-no" title="statement not covered" >return new Parser;<span class="cstat-no" title="statement not covered" >t</span></span>his._states=["_parseHeader","_parseLength","_parsePayload","_newPacket"];<span class="cstat-no" title="statement not covered" >t</span>his._resetState()}</span>inherits(Parser,EE);Parser.prototype._resetState=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.packet=new Packet;<span class="cstat-no" title="statement not covered" >t</span>his.error=null;<span class="cstat-no" title="statement not covered" >t</span>his._list=bl();<span class="cstat-no" title="statement not covered" >t</span>his._stateCounter=0}</span>;Parser.prototype.parse=<span class="fstat-no" title="function not covered" >function(buf){<span class="cstat-no" title="statement not covered" ></span>if(this.error)<span class="cstat-no" title="statement not covered" >this._resetState();<span class="cstat-no" title="statement not covered" >t</span></span>his._list.append(buf);<span class="cstat-no" title="statement not covered" >w</span>hile((this.packet.length!==-1||this._list.length&gt;0)&amp;&amp;this[this._states[this._stateCounter]]()&amp;&amp;!this.error){<span class="cstat-no" title="statement not covered" >this._stateCounter++;<span class="cstat-no" title="statement not covered" >i</span>f(this._stateCounter&gt;=this._states.length)<span class="cstat-no" title="statement not covered" >this._stateCounter=0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this._list.length}</span>;Parser.prototype._parseHeader=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var zero=this._list.readUInt8(0);<span class="cstat-no" title="statement not covered" >t</span>his.packet.cmd=constants.types[zero&gt;&gt;constants.CMD_SHIFT];<span class="cstat-no" title="statement not covered" >t</span>his.packet.retain=(zero&amp;constants.RETAIN_MASK)!==0;<span class="cstat-no" title="statement not covered" >t</span>his.packet.qos=zero&gt;&gt;constants.QOS_SHIFT&amp;constants.QOS_MASK;<span class="cstat-no" title="statement not covered" >t</span>his.packet.dup=(zero&amp;constants.DUP_MASK)!==0;<span class="cstat-no" title="statement not covered" >t</span>his._list.consume(1);<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>;Parser.prototype._parseLength=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var bytes=0;<span class="cstat-no" title="statement not covered" >v</span>ar mul=1;<span class="cstat-no" title="statement not covered" >v</span>ar length=0;<span class="cstat-no" title="statement not covered" >v</span>ar result=true;<span class="cstat-no" title="statement not covered" >v</span>ar current;<span class="cstat-no" title="statement not covered" >w</span>hile(bytes&lt;5){<span class="cstat-no" title="statement not covered" >current=this._list.readUInt8(bytes++);<span class="cstat-no" title="statement not covered" >l</span>ength+=mul*(current&amp;constants.LENGTH_MASK);<span class="cstat-no" title="statement not covered" >m</span>ul*=128;<span class="cstat-no" title="statement not covered" >i</span>f((current&amp;constants.LENGTH_FIN_MASK)===0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._list.length&lt;=bytes){<span class="cstat-no" title="statement not covered" >result=false;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(result){<span class="cstat-no" title="statement not covered" >this.packet.length=length;<span class="cstat-no" title="statement not covered" >t</span>his._list.consume(bytes)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result}</span>;Parser.prototype._parsePayload=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var result=false;<span class="cstat-no" title="statement not covered" >i</span>f(this.packet.length===0||this._list.length&gt;=this.packet.length){<span class="cstat-no" title="statement not covered" >this._pos=0;<span class="cstat-no" title="statement not covered" >s</span>witch(this.packet.cmd){case"connect":<span class="cstat-no" title="statement not covered" >this._parseConnect();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"connack":<span class="cstat-no" title="statement not covered" >this._parseConnack();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"publish":<span class="cstat-no" title="statement not covered" >this._parsePublish();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"puback":case"pubrec":case"pubrel":case"pubcomp":<span class="cstat-no" title="statement not covered" >this._parseMessageId();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"subscribe":<span class="cstat-no" title="statement not covered" >this._parseSubscribe();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"suback":<span class="cstat-no" title="statement not covered" >this._parseSuback();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"unsubscribe":<span class="cstat-no" title="statement not covered" >this._parseUnsubscribe();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"unsuback":<span class="cstat-no" title="statement not covered" >this._parseUnsuback();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"pingreq":case"pingresp":case"disconnect":<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >this._emitError(new Error("Not supported"))}<span class="cstat-no" title="statement not covered" ></span>r</span>esult=true}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result}</span>;Parser.prototype._parseConnect=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var protocolId;<span class="cstat-no" title="statement not covered" >v</span>ar clientId;<span class="cstat-no" title="statement not covered" >v</span>ar topic;<span class="cstat-no" title="statement not covered" >v</span>ar payload;<span class="cstat-no" title="statement not covered" >v</span>ar password;<span class="cstat-no" title="statement not covered" >v</span>ar username;<span class="cstat-no" title="statement not covered" >v</span>ar flags={};<span class="cstat-no" title="statement not covered" >v</span>ar packet=this.packet;<span class="cstat-no" title="statement not covered" >p</span>rotocolId=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(protocolId===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse protocol id"));<span class="cstat-no" title="statement not covered" >i</span></span>f(protocolId!=="MQTT"&amp;&amp;protocolId!=="MQIsdp"){<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Invalid protocol id"))}<span class="cstat-no" title="statement not covered" ></span>p</span>acket.protocolId=protocolId;<span class="cstat-no" title="statement not covered" >i</span>f(this._pos&gt;=this._list.length)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Packet too short"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.protocolVersion=this._list.readUInt8(this._pos);<span class="cstat-no" title="statement not covered" >i</span>f(packet.protocolVersion!==3&amp;&amp;packet.protocolVersion!==4){<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Invalid protocol version"))}<span class="cstat-no" title="statement not covered" ></span>t</span>his._pos++;<span class="cstat-no" title="statement not covered" >i</span>f(this._pos&gt;=this._list.length){<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Packet too short"))}<span class="cstat-no" title="statement not covered" ></span>f</span>lags.username=this._list.readUInt8(this._pos)&amp;constants.USERNAME_MASK;<span class="cstat-no" title="statement not covered" >f</span>lags.password=this._list.readUInt8(this._pos)&amp;constants.PASSWORD_MASK;<span class="cstat-no" title="statement not covered" >f</span>lags.will=this._list.readUInt8(this._pos)&amp;constants.WILL_FLAG_MASK;<span class="cstat-no" title="statement not covered" >i</span>f(flags.will){<span class="cstat-no" title="statement not covered" >packet.will={};<span class="cstat-no" title="statement not covered" >p</span>acket.will.retain=(this._list.readUInt8(this._pos)&amp;constants.WILL_RETAIN_MASK)!==0;<span class="cstat-no" title="statement not covered" >p</span>acket.will.qos=(this._list.readUInt8(this._pos)&amp;constants.WILL_QOS_MASK)&gt;&gt;constants.WILL_QOS_SHIFT}<span class="cstat-no" title="statement not covered" ></span>p</span>acket.clean=(this._list.readUInt8(this._pos)&amp;constants.CLEAN_SESSION_MASK)!==0;<span class="cstat-no" title="statement not covered" >t</span>his._pos++;<span class="cstat-no" title="statement not covered" >p</span>acket.keepalive=this._parseNum();<span class="cstat-no" title="statement not covered" >i</span>f(packet.keepalive===-1)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Packet too short"));<span class="cstat-no" title="statement not covered" >c</span></span>lientId=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(clientId===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Packet too short"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.clientId=clientId;<span class="cstat-no" title="statement not covered" >i</span>f(flags.will){<span class="cstat-no" title="statement not covered" >topic=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(topic===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse will topic"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.will.topic=topic;<span class="cstat-no" title="statement not covered" >p</span>ayload=this._parseBuffer();<span class="cstat-no" title="statement not covered" >i</span>f(payload===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse will payload"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.will.payload=payload}<span class="cstat-no" title="statement not covered" ></span>i</span>f(flags.username){<span class="cstat-no" title="statement not covered" >username=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(username===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse username"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.username=username}<span class="cstat-no" title="statement not covered" ></span>i</span>f(flags.password){<span class="cstat-no" title="statement not covered" >password=this._parseBuffer();<span class="cstat-no" title="statement not covered" >i</span>f(password===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse password"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.password=password}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn packet}</span>;Parser.prototype._parseConnack=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var packet=this.packet;<span class="cstat-no" title="statement not covered" >i</span>f(this._list.length&lt;2)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >p</span></span>acket.sessionPresent=!!(this._list.readUInt8(this._pos++)&amp;constants.SESSIONPRESENT_MASK);<span class="cstat-no" title="statement not covered" >p</span>acket.returnCode=this._list.readUInt8(this._pos);<span class="cstat-no" title="statement not covered" >i</span>f(packet.returnCode===-1)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse return code"))}</span></span>;Parser.prototype._parsePublish=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var packet=this.packet;<span class="cstat-no" title="statement not covered" >p</span>acket.topic=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(packet.topic===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse topic"));<span class="cstat-no" title="statement not covered" >i</span></span>f(packet.qos&gt;0)<span class="cstat-no" title="statement not covered" >if(!this._parseMessageId()){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>p</span></span>acket.payload=this._list.slice(this._pos,packet.length)}</span>;Parser.prototype._parseSubscribe=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var packet=this.packet;<span class="cstat-no" title="statement not covered" >v</span>ar topic;<span class="cstat-no" title="statement not covered" >v</span>ar qos;<span class="cstat-no" title="statement not covered" >i</span>f(packet.qos!==1){<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Wrong subscribe header"))}<span class="cstat-no" title="statement not covered" ></span>p</span>acket.subscriptions=[];<span class="cstat-no" title="statement not covered" >i</span>f(!this._parseMessageId()){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(this._pos&lt;packet.length){<span class="cstat-no" title="statement not covered" >topic=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(topic===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse topic"));<span class="cstat-no" title="statement not covered" >q</span></span>os=this._list.readUInt8(this._pos++);<span class="cstat-no" title="statement not covered" >p</span>acket.subscriptions.push({topic:topic,qos:qos})}</span>}</span>;Parser.prototype._parseSuback=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.packet.granted=[];<span class="cstat-no" title="statement not covered" >i</span>f(!this._parseMessageId()){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(this._pos&lt;this.packet.length){<span class="cstat-no" title="statement not covered" >this.packet.granted.push(this._list.readUInt8(this._pos++))}</span>}</span>;Parser.prototype._parseUnsubscribe=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var packet=this.packet;<span class="cstat-no" title="statement not covered" >p</span>acket.unsubscriptions=[];<span class="cstat-no" title="statement not covered" >i</span>f(!this._parseMessageId()){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(this._pos&lt;packet.length){<span class="cstat-no" title="statement not covered" >var topic;<span class="cstat-no" title="statement not covered" >t</span>opic=this._parseString();<span class="cstat-no" title="statement not covered" >i</span>f(topic===null)<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse topic"));<span class="cstat-no" title="statement not covered" >p</span></span>acket.unsubscriptions.push(topic)}</span>}</span>;Parser.prototype._parseUnsuback=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(!this._parseMessageId())<span class="cstat-no" title="statement not covered" >return this._emitError(new Error("Cannot parse message id"))}</span></span>;Parser.prototype._parseMessageId=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var packet=this.packet;<span class="cstat-no" title="statement not covered" >p</span>acket.messageId=this._parseNum();<span class="cstat-no" title="statement not covered" >i</span>f(packet.messageId===null){<span class="cstat-no" title="statement not covered" >this._emitError(new Error("Cannot parse message id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true}</span>;Parser.prototype._parseString=<span class="fstat-no" title="function not covered" >function(maybeBuffer){<span class="cstat-no" title="statement not covered" ></span>var length=this._parseNum();<span class="cstat-no" title="statement not covered" >v</span>ar result;<span class="cstat-no" title="statement not covered" >v</span>ar end=length+this._pos;<span class="cstat-no" title="statement not covered" >i</span>f(length===-1||end&gt;this._list.length||end&gt;this.packet.length)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>esult=this._list.toString("utf8",this._pos,end);<span class="cstat-no" title="statement not covered" >t</span>his._pos+=length;<span class="cstat-no" title="statement not covered" >r</span>eturn result}</span>;Parser.prototype._parseBuffer=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var length=this._parseNum();<span class="cstat-no" title="statement not covered" >v</span>ar result;<span class="cstat-no" title="statement not covered" >v</span>ar end=length+this._pos;<span class="cstat-no" title="statement not covered" >i</span>f(length===-1||end&gt;this._list.length||end&gt;this.packet.length)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>esult=this._list.slice(this._pos,end);<span class="cstat-no" title="statement not covered" >t</span>his._pos+=length;<span class="cstat-no" title="statement not covered" >r</span>eturn result}</span>;Parser.prototype._parseNum=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this._list.length-this._pos&lt;2)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >v</span></span>ar result=this._list.readUInt16BE(this._pos);<span class="cstat-no" title="statement not covered" >t</span>his._pos+=2;<span class="cstat-no" title="statement not covered" >r</span>eturn result}</span>;Parser.prototype._newPacket=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this.packet){<span class="cstat-no" title="statement not covered" >this._list.consume(this.packet.length);<span class="cstat-no" title="statement not covered" >t</span>his.emit("packet",this.packet)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.packet=new Packet;<span class="cstat-no" title="statement not covered" >r</span>eturn true}</span>;Parser.prototype._emitError=<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>this.error=err;<span class="cstat-no" title="statement not covered" >t</span>his.emit("error",err)}</span>;module.exports=Parser},{"./constants":32,"./packet":36,bl:30,events:20,inherits:22}],38:[function(require,module,exports){(function(Buffer){"use strict";var protocol=require("./constants");var empty=new Buffer(0);var zeroBuf=new Buffer([0]);var numCache=require("./numbers");var nextTick=require("process-nextick-args");<span class="fstat-no" title="function not covered" >function generate(packet,stream){<span class="cstat-no" title="statement not covered" ></span>if(stream.cork){<span class="cstat-no" title="statement not covered" >stream.cork();<span class="cstat-no" title="statement not covered" >n</span>extTick(uncork,stream)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(packet.cmd){case"connect":<span class="cstat-no" title="statement not covered" >return connect(packet,stream);c</span>ase"connack":<span class="cstat-no" title="statement not covered" >return connack(packet,stream);c</span>ase"publish":<span class="cstat-no" title="statement not covered" >return publish(packet,stream);c</span>ase"puback":case"pubrec":case"pubrel":case"pubcomp":case"unsuback":<span class="cstat-no" title="statement not covered" >return confirmation(packet,stream);c</span>ase"subscribe":<span class="cstat-no" title="statement not covered" >return subscribe(packet,stream);c</span>ase"suback":<span class="cstat-no" title="statement not covered" >return suback(packet,stream);c</span>ase"unsubscribe":<span class="cstat-no" title="statement not covered" >return unsubscribe(packet,stream);c</span>ase"pingreq":case"pingresp":case"disconnect":<span class="cstat-no" title="statement not covered" >return emptyPacket(packet,stream);d</span>efault:<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Unknown command"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>}<span class="fstat-no" title="function not covered" ></span>function uncork(stream){<span class="cstat-no" title="statement not covered" ></span>stream.uncork()}<span class="fstat-no" title="function not covered" ></span>function connect(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar protocolId=settings.protocolId||"MQTT";<span class="cstat-no" title="statement not covered" >v</span>ar protocolVersion=settings.protocolVersion||4;<span class="cstat-no" title="statement not covered" >v</span>ar will=settings.will;<span class="cstat-no" title="statement not covered" >v</span>ar clean=settings.clean;<span class="cstat-no" title="statement not covered" >v</span>ar keepalive=settings.keepalive||0;<span class="cstat-no" title="statement not covered" >v</span>ar clientId=settings.clientId||"";<span class="cstat-no" title="statement not covered" >v</span>ar username=settings.username;<span class="cstat-no" title="statement not covered" >v</span>ar password=settings.password;<span class="cstat-no" title="statement not covered" >i</span>f(clean===undefined)<span class="cstat-no" title="statement not covered" >clean=true;<span class="cstat-no" title="statement not covered" >v</span></span>ar length=0;<span class="cstat-no" title="statement not covered" >i</span>f(!protocolId||typeof protocolId!=="string"&amp;&amp;!Buffer.isBuffer(protocolId)){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid protocol id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else <span class="cstat-no" title="statement not covered" >length+=protocolId.length+2;<span class="cstat-no" title="statement not covered" >i</span></span>f(protocolVersion!==3&amp;&amp;protocolVersion!==4){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid protocol version"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else <span class="cstat-no" title="statement not covered" >length+=1;<span class="cstat-no" title="statement not covered" >i</span></span>f((typeof clientId==="string"||Buffer.isBuffer(clientId))&amp;&amp;(clientId||protocolVersion===4)&amp;&amp;(clientId||clean)){<span class="cstat-no" title="statement not covered" >length+=clientId.length+2}</span>else{<span class="cstat-no" title="statement not covered" >if(protocolVersion&lt;4){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("clientId must be supplied before 3.1.1"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>i</span>f(clean*1===0){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("clientId must be given if cleanSession set to 0"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof keepalive!=="number"||keepalive&lt;0||keepalive&gt;65535||keepalive%1!==0){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid keepalive"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else <span class="cstat-no" title="statement not covered" >length+=2;<span class="cstat-no" title="statement not covered" >l</span></span>ength+=1;<span class="cstat-no" title="statement not covered" >i</span>f(will){<span class="cstat-no" title="statement not covered" >if(typeof will!=="object"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid will"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!will.topic||typeof will.topic!=="string"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid will topic"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else{<span class="cstat-no" title="statement not covered" >length+=Buffer.byteLength(will.topic)+2}<span class="cstat-no" title="statement not covered" ></span>i</span>f(will.payload&amp;&amp;will.payload){<span class="cstat-no" title="statement not covered" >if(will.payload.length&gt;=0){<span class="cstat-no" title="statement not covered" >if(typeof will.payload==="string"){<span class="cstat-no" title="statement not covered" >length+=Buffer.byteLength(will.payload)+2}</span>else{<span class="cstat-no" title="statement not covered" >length+=will.payload.length+2}</span>}</span>else{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid will payload"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>}</span>else{<span class="cstat-no" title="statement not covered" >length+=2}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(username){<span class="cstat-no" title="statement not covered" >if(username.length){<span class="cstat-no" title="statement not covered" >length+=Buffer.byteLength(username)+2}</span>else{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid username"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(password){<span class="cstat-no" title="statement not covered" >if(password.length){<span class="cstat-no" title="statement not covered" >length+=byteLength(password)+2}</span>else{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid password"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.write(protocol.CONNECT_HEADER);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,length);<span class="cstat-no" title="statement not covered" >w</span>riteStringOrBuffer(stream,protocolId);<span class="cstat-no" title="statement not covered" >s</span>tream.write(protocolVersion===4?protocol.VERSION4:protocol.VERSION3);<span class="cstat-no" title="statement not covered" >v</span>ar flags=0;<span class="cstat-no" title="statement not covered" >f</span>lags|=username?protocol.USERNAME_MASK:0;<span class="cstat-no" title="statement not covered" >f</span>lags|=password?protocol.PASSWORD_MASK:0;<span class="cstat-no" title="statement not covered" >f</span>lags|=will&amp;&amp;will.retain?protocol.WILL_RETAIN_MASK:0;<span class="cstat-no" title="statement not covered" >f</span>lags|=will&amp;&amp;will.qos?will.qos&lt;&lt;protocol.WILL_QOS_SHIFT:0;<span class="cstat-no" title="statement not covered" >f</span>lags|=will?protocol.WILL_FLAG_MASK:0;<span class="cstat-no" title="statement not covered" >f</span>lags|=clean?protocol.CLEAN_SESSION_MASK:0;<span class="cstat-no" title="statement not covered" >s</span>tream.write(new Buffer([flags]));<span class="cstat-no" title="statement not covered" >w</span>riteNumber(stream,keepalive);<span class="cstat-no" title="statement not covered" >w</span>riteStringOrBuffer(stream,clientId);<span class="cstat-no" title="statement not covered" >i</span>f(will){<span class="cstat-no" title="statement not covered" >writeString(stream,will.topic);<span class="cstat-no" title="statement not covered" >w</span>riteStringOrBuffer(stream,will.payload)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(username)<span class="cstat-no" title="statement not covered" >writeStringOrBuffer(stream,username);<span class="cstat-no" title="statement not covered" >i</span></span>f(password)<span class="cstat-no" title="statement not covered" >writeStringOrBuffer(stream,password);<span class="cstat-no" title="statement not covered" >r</span></span>eturn true}<span class="fstat-no" title="function not covered" ></span>function connack(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar rc=settings.returnCode;<span class="cstat-no" title="statement not covered" >i</span>f(typeof rc!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid return code"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.write(protocol.CONNACK_HEADER);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,2);<span class="cstat-no" title="statement not covered" >s</span>tream.write(opts.sessionPresent?protocol.SESSIONPRESENT_HEADER:zeroBuf);<span class="cstat-no" title="statement not covered" >r</span>eturn stream.write(new Buffer([rc]))}<span class="fstat-no" title="function not covered" ></span>function publish(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar qos=settings.qos||0;<span class="cstat-no" title="statement not covered" >v</span>ar retain=settings.retain?protocol.RETAIN_MASK:0;<span class="cstat-no" title="statement not covered" >v</span>ar topic=settings.topic;<span class="cstat-no" title="statement not covered" >v</span>ar payload=settings.payload||empty;<span class="cstat-no" title="statement not covered" >v</span>ar id=settings.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar length=0;<span class="cstat-no" title="statement not covered" >i</span>f(typeof topic==="string")<span class="cstat-no" title="statement not covered" >length+=Buffer.byteLength(topic)+2;e</span>lse <span class="cstat-no" title="statement not covered" >if(Buffer.isBuffer(topic))<span class="cstat-no" title="statement not covered" >length+=topic.length+2;e</span>lse{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid topic"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(!Buffer.isBuffer(payload))<span class="cstat-no" title="statement not covered" >length+=Buffer.byteLength(payload);e</span>lse <span class="cstat-no" title="statement not covered" >length+=payload.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(qos&amp;&amp;typeof id!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid message id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else <span class="cstat-no" title="statement not covered" >if(qos)<span class="cstat-no" title="statement not covered" >length+=2;<span class="cstat-no" title="statement not covered" >s</span></span></span>tream.write(protocol.PUBLISH_HEADER[qos][opts.dup?1:0][retain?1:0]);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,length);<span class="cstat-no" title="statement not covered" >w</span>riteNumber(stream,byteLength(topic));<span class="cstat-no" title="statement not covered" >s</span>tream.write(topic);<span class="cstat-no" title="statement not covered" >i</span>f(qos&gt;0)<span class="cstat-no" title="statement not covered" >writeNumber(stream,id);<span class="cstat-no" title="statement not covered" >r</span></span>eturn stream.write(payload)}<span class="fstat-no" title="function not covered" ></span>function confirmation(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar type=settings.cmd||"puback";<span class="cstat-no" title="statement not covered" >v</span>ar id=settings.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar dup=settings.dup&amp;&amp;type==="pubrel"?protocol.DUP_MASK:0;<span class="cstat-no" title="statement not covered" >v</span>ar qos=0;<span class="cstat-no" title="statement not covered" >i</span>f(type==="pubrel")<span class="cstat-no" title="statement not covered" >qos=1;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof id!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid message id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.write(protocol.ACKS[type][qos][dup][0]);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,2);<span class="cstat-no" title="statement not covered" >r</span>eturn writeNumber(stream,id)}<span class="fstat-no" title="function not covered" ></span>function subscribe(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar dup=settings.dup?protocol.DUP_MASK:0;<span class="cstat-no" title="statement not covered" >v</span>ar id=settings.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar subs=settings.subscriptions;<span class="cstat-no" title="statement not covered" >v</span>ar length=0;<span class="cstat-no" title="statement not covered" >i</span>f(typeof id!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid message id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else <span class="cstat-no" title="statement not covered" >length+=2;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof subs==="object"&amp;&amp;subs.length){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;subs.length;i+=1){<span class="cstat-no" title="statement not covered" >var itopic=subs[i].topic;<span class="cstat-no" title="statement not covered" >v</span>ar iqos=subs[i].qos;<span class="cstat-no" title="statement not covered" >i</span>f(typeof itopic!=="string"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid subscriptions - invalid topic"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof iqos!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid subscriptions - invalid qos"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>l</span>ength+=Buffer.byteLength(itopic)+2+1}</span>}</span>else{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid subscriptions"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.write(protocol.SUBSCRIBE_HEADER[1][dup?1:0][0]);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,length);<span class="cstat-no" title="statement not covered" >w</span>riteNumber(stream,id);<span class="cstat-no" title="statement not covered" >v</span>ar result=true;<span class="cstat-no" title="statement not covered" >f</span>or(var j=0;j&lt;subs.length;j++){<span class="cstat-no" title="statement not covered" >var sub=subs[j];<span class="cstat-no" title="statement not covered" >v</span>ar jtopic=sub.topic;<span class="cstat-no" title="statement not covered" >v</span>ar jqos=sub.qos;<span class="cstat-no" title="statement not covered" >w</span>riteString(stream,jtopic);<span class="cstat-no" title="statement not covered" >r</span>esult=stream.write(protocol.QOS[jqos])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result}<span class="fstat-no" title="function not covered" ></span>function suback(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar id=settings.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar granted=settings.granted;<span class="cstat-no" title="statement not covered" >v</span>ar length=0;<span class="cstat-no" title="statement not covered" >i</span>f(typeof id!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid message id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else <span class="cstat-no" title="statement not covered" >length+=2;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof granted==="object"&amp;&amp;granted.length){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;granted.length;i+=1){<span class="cstat-no" title="statement not covered" >if(typeof granted[i]!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid qos vector"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>l</span>ength+=1}</span>}</span>else{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid qos vector"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.write(protocol.SUBACK_HEADER);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,length);<span class="cstat-no" title="statement not covered" >w</span>riteNumber(stream,id);<span class="cstat-no" title="statement not covered" >r</span>eturn stream.write(new Buffer(granted))}<span class="fstat-no" title="function not covered" ></span>function unsubscribe(opts,stream){<span class="cstat-no" title="statement not covered" ></span>var settings=opts||{};<span class="cstat-no" title="statement not covered" >v</span>ar id=settings.messageId;<span class="cstat-no" title="statement not covered" >v</span>ar dup=settings.dup?protocol.DUP_MASK:0;<span class="cstat-no" title="statement not covered" >v</span>ar unsubs=settings.unsubscriptions;<span class="cstat-no" title="statement not covered" >v</span>ar length=0;<span class="cstat-no" title="statement not covered" >i</span>f(typeof id!=="number"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid message id"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}</span>else{<span class="cstat-no" title="statement not covered" >length+=2}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof unsubs==="object"&amp;&amp;unsubs.length){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;unsubs.length;i+=1){<span class="cstat-no" title="statement not covered" >if(typeof unsubs[i]!=="string"){<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid unsubscriptions"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>l</span>ength+=Buffer.byteLength(unsubs[i])+2}</span>}</span>else{<span class="cstat-no" title="statement not covered" >stream.emit("error",new Error("Invalid unsubscriptions"));<span class="cstat-no" title="statement not covered" >r</span>eturn false}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.write(protocol.UNSUBSCRIBE_HEADER[1][dup?1:0][0]);<span class="cstat-no" title="statement not covered" >w</span>riteLength(stream,length);<span class="cstat-no" title="statement not covered" >w</span>riteNumber(stream,id);<span class="cstat-no" title="statement not covered" >v</span>ar result=true;<span class="cstat-no" title="statement not covered" >f</span>or(var j=0;j&lt;unsubs.length;j++){<span class="cstat-no" title="statement not covered" >result=writeString(stream,unsubs[j])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result}<span class="fstat-no" title="function not covered" ></span>function emptyPacket(opts,stream){<span class="cstat-no" title="statement not covered" ></span>return stream.write(protocol.EMPTY[opts.cmd])}<span class="fstat-no" title="function not covered" ></span>function calcLengthLength(length){<span class="cstat-no" title="statement not covered" ></span>if(length&gt;=0&amp;&amp;length&lt;128)<span class="cstat-no" title="statement not covered" >return 1;e</span>lse <span class="cstat-no" title="statement not covered" >if(length&gt;=128&amp;&amp;length&lt;16384)<span class="cstat-no" title="statement not covered" >return 2;e</span>lse <span class="cstat-no" title="statement not covered" >if(length&gt;=16384&amp;&amp;length&lt;2097152)<span class="cstat-no" title="statement not covered" >return 3;e</span>lse <span class="cstat-no" title="statement not covered" >if(length&gt;=2097152&amp;&amp;length&lt;268435456)<span class="cstat-no" title="statement not covered" >return 4;e</span>lse <span class="cstat-no" title="statement not covered" >return 0}<span class="fstat-no" title="function not covered" ></span></span></span></span></span>function genBufLength(length){<span class="cstat-no" title="statement not covered" ></span>var digit=0;<span class="cstat-no" title="statement not covered" >v</span>ar pos=0;<span class="cstat-no" title="statement not covered" >v</span>ar buffer=new Buffer(calcLengthLength(length));<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >digit=length%128|0;<span class="cstat-no" title="statement not covered" >l</span>ength=length/128|0;<span class="cstat-no" title="statement not covered" >i</span>f(length&gt;0)<span class="cstat-no" title="statement not covered" >digit=digit|128;<span class="cstat-no" title="statement not covered" >b</span></span>uffer.writeUInt8(digit,pos++,true)}</span>while(length&gt;0);<span class="cstat-no" title="statement not covered" >r</span>eturn buffer}</span>var lengthCache={};<span class="fstat-no" title="function not covered" >function writeLength(stream,length){<span class="cstat-no" title="statement not covered" ></span>var buffer=lengthCache[length];<span class="cstat-no" title="statement not covered" >i</span>f(!buffer){<span class="cstat-no" title="statement not covered" >buffer=genBufLength(length);<span class="cstat-no" title="statement not covered" >i</span>f(length&lt;16384)<span class="cstat-no" title="statement not covered" >lengthCache[length]=buffer}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tream.write(buffer)}<span class="fstat-no" title="function not covered" ></span>function writeString(stream,string){<span class="cstat-no" title="statement not covered" ></span>var strlen=Buffer.byteLength(string);<span class="cstat-no" title="statement not covered" >w</span>riteNumber(stream,strlen);<span class="cstat-no" title="statement not covered" >s</span>tream.write(string,"utf8")}<span class="fstat-no" title="function not covered" ></span>function writeNumber(stream,number){<span class="cstat-no" title="statement not covered" ></span>return stream.write(numCache[number])}<span class="fstat-no" title="function not covered" ></span>function writeStringOrBuffer(stream,toWrite){<span class="cstat-no" title="statement not covered" ></span>if(toWrite&amp;&amp;typeof toWrite==="string")<span class="cstat-no" title="statement not covered" >writeString(stream,toWrite);e</span>lse <span class="cstat-no" title="statement not covered" >if(toWrite){<span class="cstat-no" title="statement not covered" >writeNumber(stream,toWrite.length);<span class="cstat-no" title="statement not covered" >s</span>tream.write(toWrite)}</span>else <span class="cstat-no" title="statement not covered" >writeNumber(stream,0)}<span class="fstat-no" title="function not covered" ></span></span></span>function byteLength(bufOrString){<span class="cstat-no" title="statement not covered" ></span>if(!bufOrString)<span class="cstat-no" title="statement not covered" >return 0;e</span>lse <span class="cstat-no" title="statement not covered" >if(Buffer.isBuffer(bufOrString))<span class="cstat-no" title="statement not covered" >return bufOrString.length;e</span>lse <span class="cstat-no" title="statement not covered" >return Buffer.byteLength(bufOrString)}</span></span></span>module.exports=generate}).call(this,require("buffer").Buffer)},{"./constants":32,"./numbers":35,buffer:4,"process-nextick-args":47}],39:[function(require,module,exports){module.exports=require("./lib/_stream_duplex.js")},{"./lib/_stream_duplex.js":40}],40:[function(require,module,exports){arguments[4][11][0].apply(exports,arguments);
},{"./_stream_readable":42,"./_stream_writable":44,"core-util-is":6,dup:11,inherits:22,"process-nextick-args":47}],41:[function(require,module,exports){arguments[4][12][0].apply(exports,arguments)},{"./_stream_transform":43,"core-util-is":6,dup:12,inherits:22}],42:[function(require,module,exports){arguments[4][13][0].apply(exports,arguments)},{"./_stream_duplex":40,"./internal/streams/BufferList":45,_process:48,buffer:4,"buffer-shims":3,"core-util-is":6,dup:13,events:20,inherits:22,isarray:31,"process-nextick-args":47,"string_decoder/":55,util:2}],43:[function(require,module,exports){arguments[4][14][0].apply(exports,arguments)},{"./_stream_duplex":40,"core-util-is":6,dup:14,inherits:22}],44:[function(require,module,exports){arguments[4][15][0].apply(exports,arguments)},{"./_stream_duplex":40,_process:48,buffer:4,"buffer-shims":3,"core-util-is":6,dup:15,events:20,inherits:22,"process-nextick-args":47,"util-deprecate":65}],45:[function(require,module,exports){arguments[4][16][0].apply(exports,arguments)},{buffer:4,"buffer-shims":3,dup:16}],46:[function(require,module,exports){arguments[4][17][0].apply(exports,arguments)},{"./lib/_stream_duplex.js":40,"./lib/_stream_passthrough.js":41,"./lib/_stream_readable.js":42,"./lib/_stream_transform.js":43,"./lib/_stream_writable.js":44,_process:48,dup:17}],47:[function(require,module,exports){(function(process){"use strict";<span class="missing-if-branch" title="else path not taken" >E</span>if(!process.version||<span class="branch-1 cbranch-no" title="branch not covered" >process.version.indexOf("v0.")===0|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >process.version.indexOf("v1.")===0&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >process.version.indexOf("v1.8.")!==0)</span>{module.exports=nextTick}else{<span class="cstat-no" title="statement not covered" >module.exports=process.nextTick}<span class="fstat-no" title="function not covered" ></span>function nextTick(fn,arg1,arg2,arg3){<span class="cstat-no" title="statement not covered" ></span>if(typeof fn!=="function"){<span class="cstat-no" title="statement not covered" >throw new TypeError('"callback" argument must be a function')}<span class="cstat-no" title="statement not covered" ></span>v</span>ar len=arguments.length;<span class="cstat-no" title="statement not covered" >v</span>ar args,i;<span class="cstat-no" title="statement not covered" >s</span>witch(len){case 0:case 1:<span class="cstat-no" title="statement not covered" >return process.nextTick(fn);c</span>ase 2:<span class="cstat-no" title="statement not covered" >return process.nextTick(<span class="fstat-no" title="function not covered" >function afterTickOne(){<span class="cstat-no" title="statement not covered" ></span>fn.call(null,arg1)}</span>);c</span>ase 3:<span class="cstat-no" title="statement not covered" >return process.nextTick(<span class="fstat-no" title="function not covered" >function afterTickTwo(){<span class="cstat-no" title="statement not covered" ></span>fn.call(null,arg1,arg2)}</span>);c</span>ase 4:<span class="cstat-no" title="statement not covered" >return process.nextTick(<span class="fstat-no" title="function not covered" >function afterTickThree(){<span class="cstat-no" title="statement not covered" ></span>fn.call(null,arg1,arg2,arg3)}</span>);d</span>efault:<span class="cstat-no" title="statement not covered" >args=new Array(len-1);<span class="cstat-no" title="statement not covered" >i</span>=0;<span class="cstat-no" title="statement not covered" >w</span>hile(i&lt;args.length){<span class="cstat-no" title="statement not covered" >args[i++]=arguments[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn process.nextTick(<span class="fstat-no" title="function not covered" >function afterTick(){<span class="cstat-no" title="statement not covered" ></span>fn.apply(null,args)}</span>)}</span>}</span>}).call(this,require("_process"))},{_process:48}],48:[function(require,module,exports){var process=module.exports={};var cachedSetTimeout;var cachedClearTimeout;<span class="fstat-no" title="function not covered" >function defaultSetTimout(){<span class="cstat-no" title="statement not covered" ></span>throw new Error("setTimeout has not been defined")}<span class="fstat-no" title="function not covered" ></span>function defaultClearTimeout(){<span class="cstat-no" title="statement not covered" ></span>throw new Error("clearTimeout has not been defined")}</span>(function(){try{<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof setTimeout==="function"){cachedSetTimeout=setTimeout}else{<span class="cstat-no" title="statement not covered" >cachedSetTimeout=defaultSetTimout}</span>}catch(e){<span class="cstat-no" title="statement not covered" >cachedSetTimeout=defaultSetTimout}</span>try{<span class="missing-if-branch" title="else path not taken" >E</span>if(typeof clearTimeout==="function"){cachedClearTimeout=clearTimeout}else{<span class="cstat-no" title="statement not covered" >cachedClearTimeout=defaultClearTimeout}</span>}catch(e){<span class="cstat-no" title="statement not covered" >cachedClearTimeout=defaultClearTimeout}</span>})();<span class="fstat-no" title="function not covered" >function runTimeout(fun){<span class="cstat-no" title="statement not covered" ></span>if(cachedSetTimeout===setTimeout){<span class="cstat-no" title="statement not covered" >return setTimeout(fun,0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&amp;&amp;setTimeout){<span class="cstat-no" title="statement not covered" >cachedSetTimeout=setTimeout;<span class="cstat-no" title="statement not covered" >r</span>eturn setTimeout(fun,0)}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{<span class="cstat-no" title="statement not covered" >return cachedSetTimeout(fun,0)}</span>catch(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return cachedSetTimeout.call(null,fun,0)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return cachedSetTimeout.call(this,fun,0)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function runClearTimeout(marker){<span class="cstat-no" title="statement not covered" ></span>if(cachedClearTimeout===clearTimeout){<span class="cstat-no" title="statement not covered" >return clearTimeout(marker)}<span class="cstat-no" title="statement not covered" ></span>i</span>f((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&amp;&amp;clearTimeout){<span class="cstat-no" title="statement not covered" >cachedClearTimeout=clearTimeout;<span class="cstat-no" title="statement not covered" >r</span>eturn clearTimeout(marker)}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{<span class="cstat-no" title="statement not covered" >return cachedClearTimeout(marker)}</span>catch(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return cachedClearTimeout.call(null,marker)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return cachedClearTimeout.call(this,marker)}</span>}</span>}</span>var queue=[];var draining=false;var currentQueue;var queueIndex=-1;<span class="fstat-no" title="function not covered" >function cleanUpNextTick(){<span class="cstat-no" title="statement not covered" ></span>if(!draining||!currentQueue){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>d</span>raining=false;<span class="cstat-no" title="statement not covered" >i</span>f(currentQueue.length){<span class="cstat-no" title="statement not covered" >queue=currentQueue.concat(queue)}</span>else{<span class="cstat-no" title="statement not covered" >queueIndex=-1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(queue.length){<span class="cstat-no" title="statement not covered" >drainQueue()}</span>}<span class="fstat-no" title="function not covered" ></span>function drainQueue(){<span class="cstat-no" title="statement not covered" ></span>if(draining){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>v</span>ar timeout=runTimeout(cleanUpNextTick);<span class="cstat-no" title="statement not covered" >d</span>raining=true;<span class="cstat-no" title="statement not covered" >v</span>ar len=queue.length;<span class="cstat-no" title="statement not covered" >w</span>hile(len){<span class="cstat-no" title="statement not covered" >currentQueue=queue;<span class="cstat-no" title="statement not covered" >q</span>ueue=[];<span class="cstat-no" title="statement not covered" >w</span>hile(++queueIndex&lt;len){<span class="cstat-no" title="statement not covered" >if(currentQueue){<span class="cstat-no" title="statement not covered" >currentQueue[queueIndex].run()}</span>}<span class="cstat-no" title="statement not covered" ></span>q</span>ueueIndex=-1;<span class="cstat-no" title="statement not covered" >l</span>en=queue.length}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentQueue=null;<span class="cstat-no" title="statement not covered" >d</span>raining=false;<span class="cstat-no" title="statement not covered" >r</span>unClearTimeout(timeout)}</span>process.nextTick=<span class="fstat-no" title="function not covered" >function(fun){<span class="cstat-no" title="statement not covered" ></span>var args=new Array(arguments.length-1);<span class="cstat-no" title="statement not covered" >i</span>f(arguments.length&gt;1){<span class="cstat-no" title="statement not covered" >for(var i=1;i&lt;arguments.length;i++){<span class="cstat-no" title="statement not covered" >args[i-1]=arguments[i]}</span>}<span class="cstat-no" title="statement not covered" ></span>q</span>ueue.push(new Item(fun,args));<span class="cstat-no" title="statement not covered" >i</span>f(queue.length===1&amp;&amp;!draining){<span class="cstat-no" title="statement not covered" >runTimeout(drainQueue)}</span>}</span>;<span class="fstat-no" title="function not covered" >function Item(fun,array){<span class="cstat-no" title="statement not covered" ></span>this.fun=fun;<span class="cstat-no" title="statement not covered" >t</span>his.array=array}</span>Item.prototype.run=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.fun.apply(null,this.array)}</span>;process.title="browser";process.browser=true;process.env={};process.argv=[];process.version="";process.versions={};<span class="fstat-no" title="function not covered" >function noop(){</span>}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.binding=<span class="fstat-no" title="function not covered" >function(name){<span class="cstat-no" title="statement not covered" ></span>throw new Error("process.binding is not supported")}</span>;process.cwd=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return"/"}</span>;process.chdir=<span class="fstat-no" title="function not covered" >function(dir){<span class="cstat-no" title="statement not covered" ></span>throw new Error("process.chdir is not supported")}</span>;process.umask=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return 0}</span>},{}],49:[function(require,module,exports){(function(global){(function(root){var freeExports=typeof exports=="object"&amp;&amp;exports&amp;&amp;!exports.nodeType&amp;&amp;exports;var freeModule=typeof module=="object"&amp;&amp;module&amp;&amp;!module.nodeType&amp;&amp;module;var freeGlobal=typeof global=="object"&amp;&amp;global;<span class="missing-if-branch" title="else path not taken" >E</span>if(freeGlobal.global===freeGlobal||<span class="branch-1 cbranch-no" title="branch not covered" >freeGlobal.window===freeGlobal|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >freeGlobal.self===freeGlobal)</span>{root=freeGlobal}var punycode,maxInt=2147483647,base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,delimiter="-",regexPunycode=/^xn--/,regexNonASCII=/[^\x20-\x7E]/,regexSeparators=/[\x2E\u3002\uFF0E\uFF61]/g,errors={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input &gt;= 0x80 (not a basic code point)","invalid-input":"Invalid input"},baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode,key;<span class="fstat-no" title="function not covered" >function error(type){<span class="cstat-no" title="statement not covered" ></span>throw new RangeError(errors[type])}<span class="fstat-no" title="function not covered" ></span>function map(array,fn){<span class="cstat-no" title="statement not covered" ></span>var length=array.length;<span class="cstat-no" title="statement not covered" >v</span>ar result=[];<span class="cstat-no" title="statement not covered" >w</span>hile(length--){<span class="cstat-no" title="statement not covered" >result[length]=fn(array[length])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result}<span class="fstat-no" title="function not covered" ></span>function mapDomain(string,fn){<span class="cstat-no" title="statement not covered" ></span>var parts=string.split("@");<span class="cstat-no" title="statement not covered" >v</span>ar result="";<span class="cstat-no" title="statement not covered" >i</span>f(parts.length&gt;1){<span class="cstat-no" title="statement not covered" >result=parts[0]+"@";<span class="cstat-no" title="statement not covered" >s</span>tring=parts[1]}<span class="cstat-no" title="statement not covered" ></span>s</span>tring=string.replace(regexSeparators,".");<span class="cstat-no" title="statement not covered" >v</span>ar labels=string.split(".");<span class="cstat-no" title="statement not covered" >v</span>ar encoded=map(labels,fn).join(".");<span class="cstat-no" title="statement not covered" >r</span>eturn result+encoded}<span class="fstat-no" title="function not covered" ></span>function ucs2decode(string){<span class="cstat-no" title="statement not covered" ></span>var output=[],counter=0,length=string.length,value,extra;<span class="cstat-no" title="statement not covered" >w</span>hile(counter&lt;length){<span class="cstat-no" title="statement not covered" >value=string.charCodeAt(counter++);<span class="cstat-no" title="statement not covered" >i</span>f(value&gt;=55296&amp;&amp;value&lt;=56319&amp;&amp;counter&lt;length){<span class="cstat-no" title="statement not covered" >extra=string.charCodeAt(counter++);<span class="cstat-no" title="statement not covered" >i</span>f((extra&amp;64512)==56320){<span class="cstat-no" title="statement not covered" >output.push(((value&amp;1023)&lt;&lt;10)+(extra&amp;1023)+65536)}</span>else{<span class="cstat-no" title="statement not covered" >output.push(value);<span class="cstat-no" title="statement not covered" >c</span>ounter--}</span>}</span>else{<span class="cstat-no" title="statement not covered" >output.push(value)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn output}<span class="fstat-no" title="function not covered" ></span>function ucs2encode(array){<span class="cstat-no" title="statement not covered" ></span>return map(array,<span class="fstat-no" title="function not covered" >function(value){<span class="cstat-no" title="statement not covered" ></span>var output="";<span class="cstat-no" title="statement not covered" >i</span>f(value&gt;65535){<span class="cstat-no" title="statement not covered" >value-=65536;<span class="cstat-no" title="statement not covered" >o</span>utput+=stringFromCharCode(value&gt;&gt;&gt;10&amp;1023|55296);<span class="cstat-no" title="statement not covered" >v</span>alue=56320|value&amp;1023}<span class="cstat-no" title="statement not covered" ></span>o</span>utput+=stringFromCharCode(value);<span class="cstat-no" title="statement not covered" >r</span>eturn output}</span>).join("")}<span class="fstat-no" title="function not covered" ></span>function basicToDigit(codePoint){<span class="cstat-no" title="statement not covered" ></span>if(codePoint-48&lt;10){<span class="cstat-no" title="statement not covered" >return codePoint-22}<span class="cstat-no" title="statement not covered" ></span>i</span>f(codePoint-65&lt;26){<span class="cstat-no" title="statement not covered" >return codePoint-65}<span class="cstat-no" title="statement not covered" ></span>i</span>f(codePoint-97&lt;26){<span class="cstat-no" title="statement not covered" >return codePoint-97}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn base}<span class="fstat-no" title="function not covered" ></span>function digitToBasic(digit,flag){<span class="cstat-no" title="statement not covered" ></span>return digit+22+75*(digit&lt;26)-((flag!=0)&lt;&lt;5)}<span class="fstat-no" title="function not covered" ></span>function adapt(delta,numPoints,firstTime){<span class="cstat-no" title="statement not covered" ></span>var k=0;<span class="cstat-no" title="statement not covered" >d</span>elta=firstTime?floor(delta/damp):delta&gt;&gt;1;<span class="cstat-no" title="statement not covered" >d</span>elta+=floor(delta/numPoints);<span class="cstat-no" title="statement not covered" >f</span>or(;delta&gt;baseMinusTMin*tMax&gt;&gt;1;k+=base){<span class="cstat-no" title="statement not covered" >delta=floor(delta/baseMinusTMin)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn floor(k+(baseMinusTMin+1)*delta/(delta+skew))}<span class="fstat-no" title="function not covered" ></span>function decode(input){<span class="cstat-no" title="statement not covered" ></span>var output=[],inputLength=input.length,out,i=0,n=initialN,bias=initialBias,basic,j,index,oldi,w,k,digit,t,baseMinusT;<span class="cstat-no" title="statement not covered" >b</span>asic=input.lastIndexOf(delimiter);<span class="cstat-no" title="statement not covered" >i</span>f(basic&lt;0){<span class="cstat-no" title="statement not covered" >basic=0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(j=0;j&lt;basic;++j){<span class="cstat-no" title="statement not covered" >if(input.charCodeAt(j)&gt;=128){<span class="cstat-no" title="statement not covered" >error("not-basic")}<span class="cstat-no" title="statement not covered" ></span>o</span>utput.push(input.charCodeAt(j))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(index=basic&gt;0?basic+1:0;index&lt;inputLength;){<span class="cstat-no" title="statement not covered" >for(oldi=i,w=1,k=base;;k+=base){<span class="cstat-no" title="statement not covered" >if(index&gt;=inputLength){<span class="cstat-no" title="statement not covered" >error("invalid-input")}<span class="cstat-no" title="statement not covered" ></span>d</span>igit=basicToDigit(input.charCodeAt(index++));<span class="cstat-no" title="statement not covered" >i</span>f(digit&gt;=base||digit&gt;floor((maxInt-i)/w)){<span class="cstat-no" title="statement not covered" >error("overflow")}<span class="cstat-no" title="statement not covered" ></span>i</span>+=digit*w;<span class="cstat-no" title="statement not covered" >t</span>=k&lt;=bias?tMin:k&gt;=bias+tMax?tMax:k-bias;<span class="cstat-no" title="statement not covered" >i</span>f(digit&lt;t){<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span>b</span>aseMinusT=base-t;<span class="cstat-no" title="statement not covered" >i</span>f(w&gt;floor(maxInt/baseMinusT)){<span class="cstat-no" title="statement not covered" >error("overflow")}<span class="cstat-no" title="statement not covered" ></span>w</span>*=baseMinusT}<span class="cstat-no" title="statement not covered" ></span>o</span>ut=output.length+1;<span class="cstat-no" title="statement not covered" >b</span>ias=adapt(i-oldi,out,oldi==0);<span class="cstat-no" title="statement not covered" >i</span>f(floor(i/out)&gt;maxInt-n){<span class="cstat-no" title="statement not covered" >error("overflow")}<span class="cstat-no" title="statement not covered" ></span>n</span>+=floor(i/out);<span class="cstat-no" title="statement not covered" >i</span>%=out;<span class="cstat-no" title="statement not covered" >o</span>utput.splice(i++,0,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ucs2encode(output)}<span class="fstat-no" title="function not covered" ></span>function encode(input){<span class="cstat-no" title="statement not covered" ></span>var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,output=[],inputLength,handledCPCountPlusOne,baseMinusT,qMinusT;<span class="cstat-no" title="statement not covered" >i</span>nput=ucs2decode(input);<span class="cstat-no" title="statement not covered" >i</span>nputLength=input.length;<span class="cstat-no" title="statement not covered" >n</span>=initialN;<span class="cstat-no" title="statement not covered" >d</span>elta=0;<span class="cstat-no" title="statement not covered" >b</span>ias=initialBias;<span class="cstat-no" title="statement not covered" >f</span>or(j=0;j&lt;inputLength;++j){<span class="cstat-no" title="statement not covered" >currentValue=input[j];<span class="cstat-no" title="statement not covered" >i</span>f(currentValue&lt;128){<span class="cstat-no" title="statement not covered" >output.push(stringFromCharCode(currentValue))}</span>}<span class="cstat-no" title="statement not covered" ></span>h</span>andledCPCount=basicLength=output.length;<span class="cstat-no" title="statement not covered" >i</span>f(basicLength){<span class="cstat-no" title="statement not covered" >output.push(delimiter)}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(handledCPCount&lt;inputLength){<span class="cstat-no" title="statement not covered" >for(m=maxInt,j=0;j&lt;inputLength;++j){<span class="cstat-no" title="statement not covered" >currentValue=input[j];<span class="cstat-no" title="statement not covered" >i</span>f(currentValue&gt;=n&amp;&amp;currentValue&lt;m){<span class="cstat-no" title="statement not covered" >m=currentValue}</span>}<span class="cstat-no" title="statement not covered" ></span>h</span>andledCPCountPlusOne=handledCPCount+1;<span class="cstat-no" title="statement not covered" >i</span>f(m-n&gt;floor((maxInt-delta)/handledCPCountPlusOne)){<span class="cstat-no" title="statement not covered" >error("overflow")}<span class="cstat-no" title="statement not covered" ></span>d</span>elta+=(m-n)*handledCPCountPlusOne;<span class="cstat-no" title="statement not covered" >n</span>=m;<span class="cstat-no" title="statement not covered" >f</span>or(j=0;j&lt;inputLength;++j){<span class="cstat-no" title="statement not covered" >currentValue=input[j];<span class="cstat-no" title="statement not covered" >i</span>f(currentValue&lt;n&amp;&amp;++delta&gt;maxInt){<span class="cstat-no" title="statement not covered" >error("overflow")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(currentValue==n){<span class="cstat-no" title="statement not covered" >for(q=delta,k=base;;k+=base){<span class="cstat-no" title="statement not covered" >t=k&lt;=bias?tMin:k&gt;=bias+tMax?tMax:k-bias;<span class="cstat-no" title="statement not covered" >i</span>f(q&lt;t){<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span>q</span>MinusT=q-t;<span class="cstat-no" title="statement not covered" >b</span>aseMinusT=base-t;<span class="cstat-no" title="statement not covered" >o</span>utput.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0)));<span class="cstat-no" title="statement not covered" >q</span>=floor(qMinusT/baseMinusT)}<span class="cstat-no" title="statement not covered" ></span>o</span>utput.push(stringFromCharCode(digitToBasic(q,0)));<span class="cstat-no" title="statement not covered" >b</span>ias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength);<span class="cstat-no" title="statement not covered" >d</span>elta=0;<span class="cstat-no" title="statement not covered" >+</span>+handledCPCount}</span>}<span class="cstat-no" title="statement not covered" ></span>+</span>+delta;<span class="cstat-no" title="statement not covered" >+</span>+n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn output.join("")}<span class="fstat-no" title="function not covered" ></span>function toUnicode(input){<span class="cstat-no" title="statement not covered" ></span>return mapDomain(input,<span class="fstat-no" title="function not covered" >function(string){<span class="cstat-no" title="statement not covered" ></span>return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string}</span>)}<span class="fstat-no" title="function not covered" ></span>function toASCII(input){<span class="cstat-no" title="statement not covered" ></span>return mapDomain(input,<span class="fstat-no" title="function not covered" >function(string){<span class="cstat-no" title="statement not covered" ></span>return regexNonASCII.test(string)?"xn--"+encode(string):string}</span>)}</span>punycode={version:"1.4.1",ucs2:{decode:ucs2decode,encode:ucs2encode},decode:decode,encode:encode,toASCII:toASCII,toUnicode:toUnicode};<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof define=="function"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >typeof define.amd=="object"&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >define.amd)</span>{<span class="cstat-no" title="statement not covered" >define("punycode",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return punycode}</span>)}</span>else <span class="missing-if-branch" title="else path not taken" >E</span>if(freeExports&amp;&amp;freeModule){<span class="missing-if-branch" title="else path not taken" >E</span>if(module.exports==freeExports){freeModule.exports=punycode}else{<span class="cstat-no" title="statement not covered" >for(key in punycode){<span class="cstat-no" title="statement not covered" >punycode.hasOwnProperty(key)&amp;&amp;(freeExports[key]=punycode[key])}</span>}</span>}else{<span class="cstat-no" title="statement not covered" >root.punycode=punycode}</span>})(this)}).call(this,typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})</span>},{}],50:[function(require,module,exports){"use strict";<span class="fstat-no" title="function not covered" >function hasOwnProperty(obj,prop){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.hasOwnProperty.call(obj,prop)}</span>module.exports=<span class="fstat-no" title="function not covered" >function(qs,sep,eq,options){<span class="cstat-no" title="statement not covered" ></span>sep=sep||"&amp;";<span class="cstat-no" title="statement not covered" >e</span>q=eq||"=";<span class="cstat-no" title="statement not covered" >v</span>ar obj={};<span class="cstat-no" title="statement not covered" >i</span>f(typeof qs!=="string"||qs.length===0){<span class="cstat-no" title="statement not covered" >return obj}<span class="cstat-no" title="statement not covered" ></span>v</span>ar regexp=/\+/g;<span class="cstat-no" title="statement not covered" >q</span>s=qs.split(sep);<span class="cstat-no" title="statement not covered" >v</span>ar maxKeys=1e3;<span class="cstat-no" title="statement not covered" >i</span>f(options&amp;&amp;typeof options.maxKeys==="number"){<span class="cstat-no" title="statement not covered" >maxKeys=options.maxKeys}<span class="cstat-no" title="statement not covered" ></span>v</span>ar len=qs.length;<span class="cstat-no" title="statement not covered" >i</span>f(maxKeys&gt;0&amp;&amp;len&gt;maxKeys){<span class="cstat-no" title="statement not covered" >len=maxKeys}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;len;++i){<span class="cstat-no" title="statement not covered" >var x=qs[i].replace(regexp,"%20"),idx=x.indexOf(eq),kstr,vstr,k,v;<span class="cstat-no" title="statement not covered" >i</span>f(idx&gt;=0){<span class="cstat-no" title="statement not covered" >kstr=x.substr(0,idx);<span class="cstat-no" title="statement not covered" >v</span>str=x.substr(idx+1)}</span>else{<span class="cstat-no" title="statement not covered" >kstr=x;<span class="cstat-no" title="statement not covered" >v</span>str=""}<span class="cstat-no" title="statement not covered" ></span>k</span>=decodeURIComponent(kstr);<span class="cstat-no" title="statement not covered" >v</span>=decodeURIComponent(vstr);<span class="cstat-no" title="statement not covered" >i</span>f(!hasOwnProperty(obj,k)){<span class="cstat-no" title="statement not covered" >obj[k]=v}</span>else <span class="cstat-no" title="statement not covered" >if(isArray(obj[k])){<span class="cstat-no" title="statement not covered" >obj[k].push(v)}</span>else{<span class="cstat-no" title="statement not covered" >obj[k]=[obj[k],v]}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn obj}</span>;var isArray=Array.isArray||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(xs){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.toString.call(xs)==="[object Array]"}</span>}</span>,{}],51:[function(require,module,exports){"use strict";var stringifyPrimitive=<span class="fstat-no" title="function not covered" >function(v){<span class="cstat-no" title="statement not covered" ></span>switch(typeof v){case"string":<span class="cstat-no" title="statement not covered" >return v;c</span>ase"boolean":<span class="cstat-no" title="statement not covered" >return v?"true":"false";c</span>ase"number":<span class="cstat-no" title="statement not covered" >return isFinite(v)?v:"";d</span>efault:<span class="cstat-no" title="statement not covered" >return""}</span>}</span>;module.exports=<span class="fstat-no" title="function not covered" >function(obj,sep,eq,name){<span class="cstat-no" title="statement not covered" ></span>sep=sep||"&amp;";<span class="cstat-no" title="statement not covered" >e</span>q=eq||"=";<span class="cstat-no" title="statement not covered" >i</span>f(obj===null){<span class="cstat-no" title="statement not covered" >obj=undefined}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof obj==="object"){<span class="cstat-no" title="statement not covered" >return map(objectKeys(obj),<span class="fstat-no" title="function not covered" >function(k){<span class="cstat-no" title="statement not covered" ></span>var ks=encodeURIComponent(stringifyPrimitive(k))+eq;<span class="cstat-no" title="statement not covered" >i</span>f(isArray(obj[k])){<span class="cstat-no" title="statement not covered" >return map(obj[k],<span class="fstat-no" title="function not covered" >function(v){<span class="cstat-no" title="statement not covered" ></span>return ks+encodeURIComponent(stringifyPrimitive(v))}</span>).join(sep)}</span>else{<span class="cstat-no" title="statement not covered" >return ks+encodeURIComponent(stringifyPrimitive(obj[k]))}</span>}</span>).join(sep)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!name)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >r</span></span>eturn encodeURIComponent(stringifyPrimitive(name))+eq+encodeURIComponent(stringifyPrimitive(obj))}</span>;var isArray=Array.isArray||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(xs){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.toString.call(xs)==="[object Array]"}</span>;<span class="fstat-no" title="function not covered" ></span>function map(xs,f){<span class="cstat-no" title="statement not covered" ></span>if(xs.map)<span class="cstat-no" title="statement not covered" >return xs.map(f);<span class="cstat-no" title="statement not covered" >v</span></span>ar res=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;xs.length;i++){<span class="cstat-no" title="statement not covered" >res.push(f(xs[i],i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res}</span>var objectKeys=Object.keys||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>var res=[];<span class="cstat-no" title="statement not covered" >f</span>or(var key in obj){<span class="cstat-no" title="statement not covered" >if(Object.prototype.hasOwnProperty.call(obj,key))<span class="cstat-no" title="statement not covered" >res.push(key)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn res}</span>}</span>,{}],52:[function(require,module,exports){"use strict";exports.decode=exports.parse=require("./decode");exports.encode=exports.stringify=require("./encode")},{"./decode":50,"./encode":51}],53:[function(require,module,exports){"use strict";<span class="fstat-no" title="function not covered" >function ReInterval(callback,interval,args){<span class="cstat-no" title="statement not covered" ></span>var self=this;<span class="cstat-no" title="statement not covered" >t</span>his._callback=callback;<span class="cstat-no" title="statement not covered" >t</span>his._args=args;<span class="cstat-no" title="statement not covered" >t</span>his._interval=setInterval(callback,interval,this._args);<span class="cstat-no" title="statement not covered" >t</span>his.reschedule=<span class="fstat-no" title="function not covered" >function(interval){<span class="cstat-no" title="statement not covered" ></span>if(!interval)<span class="cstat-no" title="statement not covered" >interval=self._interval;<span class="cstat-no" title="statement not covered" >i</span></span>f(self._interval)<span class="cstat-no" title="statement not covered" >clearInterval(self._interval);<span class="cstat-no" title="statement not covered" >s</span></span>elf._interval=setInterval(self._callback,interval,self._args)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.clear=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(self._interval){<span class="cstat-no" title="statement not covered" >clearInterval(self._interval);<span class="cstat-no" title="statement not covered" >s</span>elf._interval=undefined}</span>}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.destroy=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(self._interval){<span class="cstat-no" title="statement not covered" >clearInterval(self._interval)}<span class="cstat-no" title="statement not covered" ></span>s</span>elf._callback=undefined;<span class="cstat-no" title="statement not covered" >s</span>elf._interval=undefined;<span class="cstat-no" title="statement not covered" >s</span>elf._args=undefined}</span>}<span class="fstat-no" title="function not covered" ></span>function reInterval(){<span class="cstat-no" title="statement not covered" ></span>if(typeof arguments[0]!=="function")<span class="cstat-no" title="statement not covered" >throw new Error("callback needed");<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof arguments[1]!=="number")<span class="cstat-no" title="statement not covered" >throw new Error("interval needed");<span class="cstat-no" title="statement not covered" >v</span></span>ar args;<span class="cstat-no" title="statement not covered" >i</span>f(arguments.length&gt;0){<span class="cstat-no" title="statement not covered" >args=new Array(arguments.length-2);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;args.length;i++){<span class="cstat-no" title="statement not covered" >args[i]=arguments[i+2]}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new ReInterval(arguments[0],arguments[1],args)}</span>module.exports=reInterval},{}],54:[function(require,module,exports){module.exports=shift;<span class="fstat-no" title="function not covered" >function shift(stream){<span class="cstat-no" title="statement not covered" ></span>var rs=stream._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!rs)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn rs.objectMode?stream.read():stream.read(getStateLength(rs))}<span class="fstat-no" title="function not covered" ></span>function getStateLength(state){<span class="cstat-no" title="statement not covered" ></span>if(state.buffer.length){<span class="cstat-no" title="statement not covered" >if(state.buffer.head){<span class="cstat-no" title="statement not covered" >return state.buffer.head.data.length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn state.buffer[0].length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn state.length}</span>},{}],55:[<span class="fstat-no" title="function not covered" >function(require,module,exports){<span class="cstat-no" title="statement not covered" ></span>var Buffer=require("buffer").Buffer;<span class="cstat-no" title="statement not covered" >v</span>ar isBufferEncoding=Buffer.isEncoding||<span class="fstat-no" title="function not covered" >function(encoding){<span class="cstat-no" title="statement not covered" ></span>switch(encoding&amp;&amp;encoding.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":<span class="cstat-no" title="statement not covered" >return true;d</span>efault:<span class="cstat-no" title="statement not covered" >return false}</span>}</span>;<span class="fstat-no" title="function not covered" >f</span>unction assertEncoding(encoding){<span class="cstat-no" title="statement not covered" ></span>if(encoding&amp;&amp;!isBufferEncoding(encoding)){<span class="cstat-no" title="statement not covered" >throw new Error("Unknown encoding: "+encoding)}</span>}<span class="cstat-no" title="statement not covered" ></span>var StringDecoder=exports.StringDecoder=<span class="fstat-no" title="function not covered" >function(encoding){<span class="cstat-no" title="statement not covered" ></span>this.encoding=(encoding||"utf8").toLowerCase().replace(/[-_]/,"");<span class="cstat-no" title="statement not covered" >a</span>ssertEncoding(encoding);<span class="cstat-no" title="statement not covered" >s</span>witch(this.encoding){case"utf8":<span class="cstat-no" title="statement not covered" >this.surrogateSize=3;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ucs2":case"utf16le":<span class="cstat-no" title="statement not covered" >this.surrogateSize=2;<span class="cstat-no" title="statement not covered" >t</span>his.detectIncompleteChar=utf16DetectIncompleteChar;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"base64":<span class="cstat-no" title="statement not covered" >this.surrogateSize=3;<span class="cstat-no" title="statement not covered" >t</span>his.detectIncompleteChar=base64DetectIncompleteChar;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.write=passThroughWrite;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.charBuffer=new Buffer(6);<span class="cstat-no" title="statement not covered" >t</span>his.charReceived=0;<span class="cstat-no" title="statement not covered" >t</span>his.charLength=0}</span>;<span class="cstat-no" title="statement not covered" >S</span>tringDecoder.prototype.write=<span class="fstat-no" title="function not covered" >function(buffer){<span class="cstat-no" title="statement not covered" ></span>var charStr="";<span class="cstat-no" title="statement not covered" >w</span>hile(this.charLength){<span class="cstat-no" title="statement not covered" >var available=buffer.length&gt;=this.charLength-this.charReceived?this.charLength-this.charReceived:buffer.length;<span class="cstat-no" title="statement not covered" >b</span>uffer.copy(this.charBuffer,this.charReceived,0,available);<span class="cstat-no" title="statement not covered" >t</span>his.charReceived+=available;<span class="cstat-no" title="statement not covered" >i</span>f(this.charReceived&lt;this.charLength){<span class="cstat-no" title="statement not covered" >return""}<span class="cstat-no" title="statement not covered" ></span>b</span>uffer=buffer.slice(available,buffer.length);<span class="cstat-no" title="statement not covered" >c</span>harStr=this.charBuffer.slice(0,this.charLength).toString(this.encoding);<span class="cstat-no" title="statement not covered" >v</span>ar charCode=charStr.charCodeAt(charStr.length-1);<span class="cstat-no" title="statement not covered" >i</span>f(charCode&gt;=55296&amp;&amp;charCode&lt;=56319){<span class="cstat-no" title="statement not covered" >this.charLength+=this.surrogateSize;<span class="cstat-no" title="statement not covered" >c</span>harStr="";<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>his.charReceived=this.charLength=0;<span class="cstat-no" title="statement not covered" >i</span>f(buffer.length===0){<span class="cstat-no" title="statement not covered" >return charStr}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>his.detectIncompleteChar(buffer);<span class="cstat-no" title="statement not covered" >v</span>ar end=buffer.length;<span class="cstat-no" title="statement not covered" >i</span>f(this.charLength){<span class="cstat-no" title="statement not covered" >buffer.copy(this.charBuffer,0,buffer.length-this.charReceived,end);<span class="cstat-no" title="statement not covered" >e</span>nd-=this.charReceived}<span class="cstat-no" title="statement not covered" ></span>c</span>harStr+=buffer.toString(this.encoding,0,end);<span class="cstat-no" title="statement not covered" >v</span>ar end=charStr.length-1;<span class="cstat-no" title="statement not covered" >v</span>ar charCode=charStr.charCodeAt(end);<span class="cstat-no" title="statement not covered" >i</span>f(charCode&gt;=55296&amp;&amp;charCode&lt;=56319){<span class="cstat-no" title="statement not covered" >var size=this.surrogateSize;<span class="cstat-no" title="statement not covered" >t</span>his.charLength+=size;<span class="cstat-no" title="statement not covered" >t</span>his.charReceived+=size;<span class="cstat-no" title="statement not covered" >t</span>his.charBuffer.copy(this.charBuffer,size,0,size);<span class="cstat-no" title="statement not covered" >b</span>uffer.copy(this.charBuffer,0,0,size);<span class="cstat-no" title="statement not covered" >r</span>eturn charStr.substring(0,end)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn charStr}</span>;<span class="cstat-no" title="statement not covered" >S</span>tringDecoder.prototype.detectIncompleteChar=<span class="fstat-no" title="function not covered" >function(buffer){<span class="cstat-no" title="statement not covered" ></span>var i=buffer.length&gt;=3?3:buffer.length;<span class="cstat-no" title="statement not covered" >f</span>or(;i&gt;0;i--){<span class="cstat-no" title="statement not covered" >var c=buffer[buffer.length-i];<span class="cstat-no" title="statement not covered" >i</span>f(i==1&amp;&amp;c&gt;&gt;5==6){<span class="cstat-no" title="statement not covered" >this.charLength=2;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i&lt;=2&amp;&amp;c&gt;&gt;4==14){<span class="cstat-no" title="statement not covered" >this.charLength=3;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i&lt;=3&amp;&amp;c&gt;&gt;3==30){<span class="cstat-no" title="statement not covered" >this.charLength=4;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.charReceived=i}</span>;<span class="cstat-no" title="statement not covered" >S</span>tringDecoder.prototype.end=<span class="fstat-no" title="function not covered" >function(buffer){<span class="cstat-no" title="statement not covered" ></span>var res="";<span class="cstat-no" title="statement not covered" >i</span>f(buffer&amp;&amp;buffer.length)<span class="cstat-no" title="statement not covered" >res=this.write(buffer);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.charReceived){<span class="cstat-no" title="statement not covered" >var cr=this.charReceived;<span class="cstat-no" title="statement not covered" >v</span>ar buf=this.charBuffer;<span class="cstat-no" title="statement not covered" >v</span>ar enc=this.encoding;<span class="cstat-no" title="statement not covered" >r</span>es+=buf.slice(0,cr).toString(enc)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res}</span>;<span class="fstat-no" title="function not covered" >f</span>unction passThroughWrite(buffer){<span class="cstat-no" title="statement not covered" ></span>return buffer.toString(this.encoding)}<span class="fstat-no" title="function not covered" ></span>function utf16DetectIncompleteChar(buffer){<span class="cstat-no" title="statement not covered" ></span>this.charReceived=buffer.length%2;<span class="cstat-no" title="statement not covered" >t</span>his.charLength=this.charReceived?2:0}<span class="fstat-no" title="function not covered" ></span>function base64DetectIncompleteChar(buffer){<span class="cstat-no" title="statement not covered" ></span>this.charReceived=buffer.length%3;<span class="cstat-no" title="statement not covered" >t</span>his.charLength=this.charReceived?3:0}</span>},{buffer:4}],56:[function(require,module,exports){arguments[4][5][0].apply(exports,arguments)},{dup:5}],57:[function(require,module,exports){arguments[4][11][0].apply(exports,arguments)},{"./_stream_readable":58,"./_stream_writable":60,"core-util-is":6,dup:11,inherits:22,"process-nextick-args":47}],58:[function(require,module,exports){(function(process){"use strict";module.exports=Readable;var processNextTick=require("process-nextick-args");var isArray=require("isarray");var Buffer=require("buffer").Buffer;Readable.ReadableState=ReadableState;var EE=require("events");var EElistenerCount=<span class="fstat-no" title="function not covered" >function(emitter,type){<span class="cstat-no" title="statement not covered" ></span>return emitter.listeners(type).length}</span>;var Stream;(function(){try{Stream=require("st"+"ream")}catch(_){}finally{<span class="missing-if-branch" title="if path not taken" >I</span>if(!Stream)<span class="cstat-no" title="statement not covered" >Stream=require("events").EventEmitter}</span>})();var Buffer=require("buffer").Buffer;var util=require("core-util-is");util.inherits=require("inherits");var debugUtil=require("util");var debug=undefined;<span class="missing-if-branch" title="if path not taken" >I</span>if(debugUtil&amp;&amp;debugUtil.debuglog){<span class="cstat-no" title="statement not covered" >debug=debugUtil.debuglog("stream")}</span>else{debug=<span class="fstat-no" title="function not covered" >function(){</span>}}var StringDecoder;util.inherits(Readable,Stream);var Duplex;<span class="fstat-no" title="function not covered" >function ReadableState(options,stream){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >o</span>ptions=options||{};<span class="cstat-no" title="statement not covered" >t</span>his.objectMode=!!options.objectMode;<span class="cstat-no" title="statement not covered" >i</span>f(stream instanceof Duplex)<span class="cstat-no" title="statement not covered" >this.objectMode=this.objectMode||!!options.readableObjectMode;<span class="cstat-no" title="statement not covered" >v</span></span>ar hwm=options.highWaterMark;<span class="cstat-no" title="statement not covered" >v</span>ar defaultHwm=this.objectMode?16:16*1024;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=hwm||hwm===0?hwm:defaultHwm;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=~~this.highWaterMark;<span class="cstat-no" title="statement not covered" >t</span>his.buffer=[];<span class="cstat-no" title="statement not covered" >t</span>his.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.pipes=null;<span class="cstat-no" title="statement not covered" >t</span>his.pipesCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.flowing=null;<span class="cstat-no" title="statement not covered" >t</span>his.ended=false;<span class="cstat-no" title="statement not covered" >t</span>his.endEmitted=false;<span class="cstat-no" title="statement not covered" >t</span>his.reading=false;<span class="cstat-no" title="statement not covered" >t</span>his.sync=true;<span class="cstat-no" title="statement not covered" >t</span>his.needReadable=false;<span class="cstat-no" title="statement not covered" >t</span>his.emittedReadable=false;<span class="cstat-no" title="statement not covered" >t</span>his.readableListening=false;<span class="cstat-no" title="statement not covered" >t</span>his.resumeScheduled=false;<span class="cstat-no" title="statement not covered" >t</span>his.defaultEncoding=options.defaultEncoding||"utf8";<span class="cstat-no" title="statement not covered" >t</span>his.ranOut=false;<span class="cstat-no" title="statement not covered" >t</span>his.awaitDrain=0;<span class="cstat-no" title="statement not covered" >t</span>his.readingMore=false;<span class="cstat-no" title="statement not covered" >t</span>his.decoder=null;<span class="cstat-no" title="statement not covered" >t</span>his.encoding=null;<span class="cstat-no" title="statement not covered" >i</span>f(options.encoding){<span class="cstat-no" title="statement not covered" >if(!StringDecoder)<span class="cstat-no" title="statement not covered" >StringDecoder=require("string_decoder/").StringDecoder;<span class="cstat-no" title="statement not covered" >t</span></span>his.decoder=new StringDecoder(options.encoding);<span class="cstat-no" title="statement not covered" >t</span>his.encoding=options.encoding}</span>}</span>var Duplex;<span class="fstat-no" title="function not covered" >function Readable(options){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >i</span>f(!(this instanceof Readable))<span class="cstat-no" title="statement not covered" >return new Readable(options);<span class="cstat-no" title="statement not covered" >t</span></span>his._readableState=new ReadableState(options,this);<span class="cstat-no" title="statement not covered" >t</span>his.readable=true;<span class="cstat-no" title="statement not covered" >i</span>f(options&amp;&amp;typeof options.read==="function")<span class="cstat-no" title="statement not covered" >this._read=options.read;<span class="cstat-no" title="statement not covered" >S</span></span>tream.call(this)}</span>Readable.prototype.push=<span class="fstat-no" title="function not covered" >function(chunk,encoding){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!state.objectMode&amp;&amp;typeof chunk==="string"){<span class="cstat-no" title="statement not covered" >encoding=encoding||state.defaultEncoding;<span class="cstat-no" title="statement not covered" >i</span>f(encoding!==state.encoding){<span class="cstat-no" title="statement not covered" >chunk=new Buffer(chunk,encoding);<span class="cstat-no" title="statement not covered" >e</span>ncoding=""}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn readableAddChunk(this,state,chunk,encoding,false)}</span>;Readable.prototype.unshift=<span class="fstat-no" title="function not covered" >function(chunk){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >r</span>eturn readableAddChunk(this,state,chunk,"",true)}</span>;Readable.prototype.isPaused=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._readableState.flowing===false}</span>;<span class="fstat-no" title="function not covered" >function readableAddChunk(stream,state,chunk,encoding,addToFront){<span class="cstat-no" title="statement not covered" ></span>var er=chunkInvalid(state,chunk);<span class="cstat-no" title="statement not covered" >i</span>f(er){<span class="cstat-no" title="statement not covered" >stream.emit("error",er)}</span>else <span class="cstat-no" title="statement not covered" >if(chunk===null){<span class="cstat-no" title="statement not covered" >state.reading=false;<span class="cstat-no" title="statement not covered" >o</span>nEofChunk(stream,state)}</span>else <span class="cstat-no" title="statement not covered" >if(state.objectMode||chunk&amp;&amp;chunk.length&gt;0){<span class="cstat-no" title="statement not covered" >if(state.ended&amp;&amp;!addToFront){<span class="cstat-no" title="statement not covered" >var e=new Error("stream.push() after EOF");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",e)}</span>else <span class="cstat-no" title="statement not covered" >if(state.endEmitted&amp;&amp;addToFront){<span class="cstat-no" title="statement not covered" >var e=new Error("stream.unshift() after end event");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",e)}</span>else{<span class="cstat-no" title="statement not covered" >var skipAdd;<span class="cstat-no" title="statement not covered" >i</span>f(state.decoder&amp;&amp;!addToFront&amp;&amp;!encoding){<span class="cstat-no" title="statement not covered" >chunk=state.decoder.write(chunk);<span class="cstat-no" title="statement not covered" >s</span>kipAdd=!state.objectMode&amp;&amp;chunk.length===0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!addToFront)<span class="cstat-no" title="statement not covered" >state.reading=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(!skipAdd){<span class="cstat-no" title="statement not covered" >if(state.flowing&amp;&amp;state.length===0&amp;&amp;!state.sync){<span class="cstat-no" title="statement not covered" >stream.emit("data",chunk);<span class="cstat-no" title="statement not covered" >s</span>tream.read(0)}</span>else{<span class="cstat-no" title="statement not covered" >state.length+=state.objectMode?1:chunk.length;<span class="cstat-no" title="statement not covered" >i</span>f(addToFront)<span class="cstat-no" title="statement not covered" >state.buffer.unshift(chunk);e</span>lse <span class="cstat-no" title="statement not covered" >state.buffer.push(chunk);<span class="cstat-no" title="statement not covered" >i</span></span>f(state.needReadable)<span class="cstat-no" title="statement not covered" >emitReadable(stream)}</span></span>}<span class="cstat-no" title="statement not covered" ></span>m</span>aybeReadMore(stream,state)}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >if(!addToFront){<span class="cstat-no" title="statement not covered" >state.reading=false}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn needMoreData(state)}<span class="fstat-no" title="function not covered" ></span>function needMoreData(state){<span class="cstat-no" title="statement not covered" ></span>return!state.ended&amp;&amp;(state.needReadable||state.length&lt;state.highWaterMark||state.length===0)}</span>Readable.prototype.setEncoding=<span class="fstat-no" title="function not covered" >function(enc){<span class="cstat-no" title="statement not covered" ></span>if(!StringDecoder)<span class="cstat-no" title="statement not covered" >StringDecoder=require("string_decoder/").StringDecoder;<span class="cstat-no" title="statement not covered" >t</span></span>his._readableState.decoder=new StringDecoder(enc);<span class="cstat-no" title="statement not covered" >t</span>his._readableState.encoding=enc;<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;var MAX_HWM=8388608;<span class="fstat-no" title="function not covered" >function computeNewHighWaterMark(n){<span class="cstat-no" title="statement not covered" ></span>if(n&gt;=MAX_HWM){<span class="cstat-no" title="statement not covered" >n=MAX_HWM}</span>else{<span class="cstat-no" title="statement not covered" >n--;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;2;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;4;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >n</span>|=n&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >n</span>++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>function howMuchToRead(n,state){<span class="cstat-no" title="statement not covered" ></span>if(state.length===0&amp;&amp;state.ended)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.objectMode)<span class="cstat-no" title="statement not covered" >return n===0?0:1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n===null||isNaN(n)){<span class="cstat-no" title="statement not covered" >if(state.flowing&amp;&amp;state.buffer.length)<span class="cstat-no" title="statement not covered" >return state.buffer[0].length;e</span>lse <span class="cstat-no" title="statement not covered" >return state.length}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(n&lt;=0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&gt;state.highWaterMark)<span class="cstat-no" title="statement not covered" >state.highWaterMark=computeNewHighWaterMark(n);<span class="cstat-no" title="statement not covered" >i</span></span>f(n&gt;state.length){<span class="cstat-no" title="statement not covered" >if(!state.ended){<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >r</span>eturn 0}</span>else{<span class="cstat-no" title="statement not covered" >return state.length}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>Readable.prototype.read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>debug("read",n);<span class="cstat-no" title="statement not covered" >v</span>ar state=this._readableState;<span class="cstat-no" title="statement not covered" >v</span>ar nOrig=n;<span class="cstat-no" title="statement not covered" >i</span>f(typeof n!=="number"||n&gt;0)<span class="cstat-no" title="statement not covered" >state.emittedReadable=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(n===0&amp;&amp;state.needReadable&amp;&amp;(state.length&gt;=state.highWaterMark||state.ended)){<span class="cstat-no" title="statement not covered" >debug("read: emitReadable",state.length,state.ended);<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0&amp;&amp;state.ended)<span class="cstat-no" title="statement not covered" >endReadable(this);e</span>lse <span class="cstat-no" title="statement not covered" >emitReadable(this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn null}<span class="cstat-no" title="statement not covered" ></span>n</span>=howMuchToRead(n,state);<span class="cstat-no" title="statement not covered" >i</span>f(n===0&amp;&amp;state.ended){<span class="cstat-no" title="statement not covered" >if(state.length===0)<span class="cstat-no" title="statement not covered" >endReadable(this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn null}<span class="cstat-no" title="statement not covered" ></span>v</span>ar doRead=state.needReadable;<span class="cstat-no" title="statement not covered" >d</span>ebug("need readable",doRead);<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0||state.length-n&lt;state.highWaterMark){<span class="cstat-no" title="statement not covered" >doRead=true;<span class="cstat-no" title="statement not covered" >d</span>ebug("length less than watermark",doRead)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(state.ended||state.reading){<span class="cstat-no" title="statement not covered" >doRead=false;<span class="cstat-no" title="statement not covered" >d</span>ebug("reading or ended",doRead)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(doRead){<span class="cstat-no" title="statement not covered" >debug("do read");<span class="cstat-no" title="statement not covered" >s</span>tate.reading=true;<span class="cstat-no" title="statement not covered" >s</span>tate.sync=true;<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0)<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >t</span></span>his._read(state.highWaterMark);<span class="cstat-no" title="statement not covered" >s</span>tate.sync=false}<span class="cstat-no" title="statement not covered" ></span>i</span>f(doRead&amp;&amp;!state.reading)<span class="cstat-no" title="statement not covered" >n=howMuchToRead(nOrig,state);<span class="cstat-no" title="statement not covered" >v</span></span>ar ret;<span class="cstat-no" title="statement not covered" >i</span>f(n&gt;0)<span class="cstat-no" title="statement not covered" >ret=fromList(n,state);e</span>lse <span class="cstat-no" title="statement not covered" >ret=null;<span class="cstat-no" title="statement not covered" >i</span></span>f(ret===null){<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >n</span>=0}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.length-=n;<span class="cstat-no" title="statement not covered" >i</span>f(state.length===0&amp;&amp;!state.ended)<span class="cstat-no" title="statement not covered" >state.needReadable=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(nOrig!==n&amp;&amp;state.ended&amp;&amp;state.length===0)<span class="cstat-no" title="statement not covered" >endReadable(this);<span class="cstat-no" title="statement not covered" >i</span></span>f(ret!==null)<span class="cstat-no" title="statement not covered" >this.emit("data",ret);<span class="cstat-no" title="statement not covered" >r</span></span>eturn ret}</span>;<span class="fstat-no" title="function not covered" >function chunkInvalid(state,chunk){<span class="cstat-no" title="statement not covered" ></span>var er=null;<span class="cstat-no" title="statement not covered" >i</span>f(!Buffer.isBuffer(chunk)&amp;&amp;typeof chunk!=="string"&amp;&amp;chunk!==null&amp;&amp;chunk!==undefined&amp;&amp;!state.objectMode){<span class="cstat-no" title="statement not covered" >er=new TypeError("Invalid non-string/buffer chunk")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn er}<span class="fstat-no" title="function not covered" ></span>function onEofChunk(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(state.ended)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.decoder){<span class="cstat-no" title="statement not covered" >var chunk=state.decoder.end();<span class="cstat-no" title="statement not covered" >i</span>f(chunk&amp;&amp;chunk.length){<span class="cstat-no" title="statement not covered" >state.buffer.push(chunk);<span class="cstat-no" title="statement not covered" >s</span>tate.length+=state.objectMode?1:chunk.length}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.ended=true;<span class="cstat-no" title="statement not covered" >e</span>mitReadable(stream)}<span class="fstat-no" title="function not covered" ></span>function emitReadable(stream){<span class="cstat-no" title="statement not covered" ></span>var state=stream._readableState;<span class="cstat-no" title="statement not covered" >s</span>tate.needReadable=false;<span class="cstat-no" title="statement not covered" >i</span>f(!state.emittedReadable){<span class="cstat-no" title="statement not covered" >debug("emitReadable",state.flowing);<span class="cstat-no" title="statement not covered" >s</span>tate.emittedReadable=true;<span class="cstat-no" title="statement not covered" >i</span>f(state.sync)<span class="cstat-no" title="statement not covered" >processNextTick(emitReadable_,stream);e</span>lse <span class="cstat-no" title="statement not covered" >emitReadable_(stream)}</span></span>}<span class="fstat-no" title="function not covered" ></span>function emitReadable_(stream){<span class="cstat-no" title="statement not covered" ></span>debug("emit readable");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("readable");<span class="cstat-no" title="statement not covered" >f</span>low(stream)}<span class="fstat-no" title="function not covered" ></span>function maybeReadMore(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.readingMore){<span class="cstat-no" title="statement not covered" >state.readingMore=true;<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(maybeReadMore_,stream,state)}</span>}<span class="fstat-no" title="function not covered" ></span>function maybeReadMore_(stream,state){<span class="cstat-no" title="statement not covered" ></span>var len=state.length;<span class="cstat-no" title="statement not covered" >w</span>hile(!state.reading&amp;&amp;!state.flowing&amp;&amp;!state.ended&amp;&amp;state.length&lt;state.highWaterMark){<span class="cstat-no" title="statement not covered" >debug("maybeReadMore read 0");<span class="cstat-no" title="statement not covered" >s</span>tream.read(0);<span class="cstat-no" title="statement not covered" >i</span>f(len===state.length)<span class="cstat-no" title="statement not covered" >break;e</span>lse <span class="cstat-no" title="statement not covered" >len=state.length}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tate.readingMore=false}</span>Readable.prototype._read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>this.emit("error",new Error("not implemented"))}</span>;Readable.prototype.pipe=<span class="fstat-no" title="function not covered" >function(dest,pipeOpts){<span class="cstat-no" title="statement not covered" ></span>var src=this;<span class="cstat-no" title="statement not covered" >v</span>ar state=this._readableState;<span class="cstat-no" title="statement not covered" >s</span>witch(state.pipesCount){case 0:<span class="cstat-no" title="statement not covered" >state.pipes=dest;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >state.pipes=[state.pipes,dest];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >state.pipes.push(dest);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.pipesCount+=1;<span class="cstat-no" title="statement not covered" >d</span>ebug("pipe count=%d opts=%j",state.pipesCount,pipeOpts);<span class="cstat-no" title="statement not covered" >v</span>ar doEnd=(!pipeOpts||pipeOpts.end!==false)&amp;&amp;dest!==process.stdout&amp;&amp;dest!==process.stderr;<span class="cstat-no" title="statement not covered" >v</span>ar endFn=doEnd?onend:cleanup;<span class="cstat-no" title="statement not covered" >i</span>f(state.endEmitted)<span class="cstat-no" title="statement not covered" >processNextTick(endFn);e</span>lse <span class="cstat-no" title="statement not covered" >src.once("end",endFn);<span class="cstat-no" title="statement not covered" >d</span></span>est.on("unpipe",onunpipe);<span class="fstat-no" title="function not covered" >f</span>unction onunpipe(readable){<span class="cstat-no" title="statement not covered" ></span>debug("onunpipe");<span class="cstat-no" title="statement not covered" >i</span>f(readable===src){<span class="cstat-no" title="statement not covered" >cleanup()}</span>}<span class="fstat-no" title="function not covered" ></span>function onend(){<span class="cstat-no" title="statement not covered" ></span>debug("onend");<span class="cstat-no" title="statement not covered" >d</span>est.end()}<span class="cstat-no" title="statement not covered" ></span>var ondrain=pipeOnDrain(src);<span class="cstat-no" title="statement not covered" >d</span>est.on("drain",ondrain);<span class="cstat-no" title="statement not covered" >v</span>ar cleanedUp=false;<span class="fstat-no" title="function not covered" >f</span>unction cleanup(){<span class="cstat-no" title="statement not covered" ></span>debug("cleanup");<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("close",onclose);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("drain",ondrain);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("error",onerror);<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("unpipe",onunpipe);<span class="cstat-no" title="statement not covered" >s</span>rc.removeListener("end",onend);<span class="cstat-no" title="statement not covered" >s</span>rc.removeListener("end",cleanup);<span class="cstat-no" title="statement not covered" >s</span>rc.removeListener("data",ondata);<span class="cstat-no" title="statement not covered" >c</span>leanedUp=true;<span class="cstat-no" title="statement not covered" >i</span>f(state.awaitDrain&amp;&amp;(!dest._writableState||dest._writableState.needDrain))<span class="cstat-no" title="statement not covered" >ondrain()}<span class="cstat-no" title="statement not covered" ></span></span>src.on("data",ondata);<span class="fstat-no" title="function not covered" >f</span>unction ondata(chunk){<span class="cstat-no" title="statement not covered" ></span>debug("ondata");<span class="cstat-no" title="statement not covered" >v</span>ar ret=dest.write(chunk);<span class="cstat-no" title="statement not covered" >i</span>f(false===ret){<span class="cstat-no" title="statement not covered" >if(state.pipesCount===1&amp;&amp;state.pipes[0]===dest&amp;&amp;src.listenerCount("data")===1&amp;&amp;!cleanedUp){<span class="cstat-no" title="statement not covered" >debug("false write response, pause",src._readableState.awaitDrain);<span class="cstat-no" title="statement not covered" >s</span>rc._readableState.awaitDrain++}<span class="cstat-no" title="statement not covered" ></span>s</span>rc.pause()}</span>}<span class="fstat-no" title="function not covered" ></span>function onerror(er){<span class="cstat-no" title="statement not covered" ></span>debug("onerror",er);<span class="cstat-no" title="statement not covered" >u</span>npipe();<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("error",onerror);<span class="cstat-no" title="statement not covered" >i</span>f(EElistenerCount(dest,"error")===0)<span class="cstat-no" title="statement not covered" >dest.emit("error",er)}<span class="cstat-no" title="statement not covered" ></span></span>if(!dest._events||!dest._events.error)<span class="cstat-no" title="statement not covered" >dest.on("error",onerror);e</span>lse <span class="cstat-no" title="statement not covered" >if(isArray(dest._events.error))<span class="cstat-no" title="statement not covered" >dest._events.error.unshift(onerror);e</span>lse <span class="cstat-no" title="statement not covered" >dest._events.error=[onerror,dest._events.error];<span class="fstat-no" title="function not covered" >f</span></span></span>unction onclose(){<span class="cstat-no" title="statement not covered" ></span>dest.removeListener("finish",onfinish);<span class="cstat-no" title="statement not covered" >u</span>npipe()}<span class="cstat-no" title="statement not covered" ></span>dest.once("close",onclose);<span class="fstat-no" title="function not covered" >f</span>unction onfinish(){<span class="cstat-no" title="statement not covered" ></span>debug("onfinish");<span class="cstat-no" title="statement not covered" >d</span>est.removeListener("close",onclose);<span class="cstat-no" title="statement not covered" >u</span>npipe()}<span class="cstat-no" title="statement not covered" ></span>dest.once("finish",onfinish);<span class="fstat-no" title="function not covered" >f</span>unction unpipe(){<span class="cstat-no" title="statement not covered" ></span>debug("unpipe");<span class="cstat-no" title="statement not covered" >s</span>rc.unpipe(dest)}<span class="cstat-no" title="statement not covered" ></span>dest.emit("pipe",src);<span class="cstat-no" title="statement not covered" >i</span>f(!state.flowing){<span class="cstat-no" title="statement not covered" >debug("pipe resume");<span class="cstat-no" title="statement not covered" >s</span>rc.resume()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn dest}</span>;<span class="fstat-no" title="function not covered" >function pipeOnDrain(src){<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=src._readableState;<span class="cstat-no" title="statement not covered" >d</span>ebug("pipeOnDrain",state.awaitDrain);<span class="cstat-no" title="statement not covered" >i</span>f(state.awaitDrain)<span class="cstat-no" title="statement not covered" >state.awaitDrain--;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.awaitDrain===0&amp;&amp;EElistenerCount(src,"data")){<span class="cstat-no" title="statement not covered" >state.flowing=true;<span class="cstat-no" title="statement not covered" >f</span>low(src)}</span>}</span>}</span>Readable.prototype.unpipe=<span class="fstat-no" title="function not covered" >function(dest){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(state.pipesCount===0)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.pipesCount===1){<span class="cstat-no" title="statement not covered" >if(dest&amp;&amp;dest!==state.pipes)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(!dest)<span class="cstat-no" title="statement not covered" >dest=state.pipes;<span class="cstat-no" title="statement not covered" >s</span></span>tate.pipes=null;<span class="cstat-no" title="statement not covered" >s</span>tate.pipesCount=0;<span class="cstat-no" title="statement not covered" >s</span>tate.flowing=false;<span class="cstat-no" title="statement not covered" >i</span>f(dest)<span class="cstat-no" title="statement not covered" >dest.emit("unpipe",this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!dest){<span class="cstat-no" title="statement not covered" >var dests=state.pipes;<span class="cstat-no" title="statement not covered" >v</span>ar len=state.pipesCount;<span class="cstat-no" title="statement not covered" >s</span>tate.pipes=null;<span class="cstat-no" title="statement not covered" >s</span>tate.pipesCount=0;<span class="cstat-no" title="statement not covered" >s</span>tate.flowing=false;<span class="cstat-no" title="statement not covered" >f</span>or(var _i=0;_i&lt;len;_i++){<span class="cstat-no" title="statement not covered" >dests[_i].emit("unpipe",this)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}<span class="cstat-no" title="statement not covered" ></span>v</span>ar i=indexOf(state.pipes,dest);<span class="cstat-no" title="statement not covered" >i</span>f(i===-1)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >s</span></span>tate.pipes.splice(i,1);<span class="cstat-no" title="statement not covered" >s</span>tate.pipesCount-=1;<span class="cstat-no" title="statement not covered" >i</span>f(state.pipesCount===1)<span class="cstat-no" title="statement not covered" >state.pipes=state.pipes[0];<span class="cstat-no" title="statement not covered" >d</span></span>est.emit("unpipe",this);<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;Readable.prototype.on=<span class="fstat-no" title="function not covered" >function(ev,fn){<span class="cstat-no" title="statement not covered" ></span>var res=Stream.prototype.on.call(this,ev,fn);<span class="cstat-no" title="statement not covered" >i</span>f(ev==="data"&amp;&amp;false!==this._readableState.flowing){<span class="cstat-no" title="statement not covered" >this.resume()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(ev==="readable"&amp;&amp;!this._readableState.endEmitted){<span class="cstat-no" title="statement not covered" >var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!state.readableListening){<span class="cstat-no" title="statement not covered" >state.readableListening=true;<span class="cstat-no" title="statement not covered" >s</span>tate.emittedReadable=false;<span class="cstat-no" title="statement not covered" >s</span>tate.needReadable=true;<span class="cstat-no" title="statement not covered" >i</span>f(!state.reading){<span class="cstat-no" title="statement not covered" >processNextTick(nReadingNextTick,this)}</span>else <span class="cstat-no" title="statement not covered" >if(state.length){<span class="cstat-no" title="statement not covered" >emitReadable(this,state)}</span>}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res}</span>;Readable.prototype.addListener=Readable.prototype.on;<span class="fstat-no" title="function not covered" >function nReadingNextTick(self){<span class="cstat-no" title="statement not covered" ></span>debug("readable nexttick read 0");<span class="cstat-no" title="statement not covered" >s</span>elf.read(0)}</span>Readable.prototype.resume=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(!state.flowing){<span class="cstat-no" title="statement not covered" >debug("resume");<span class="cstat-no" title="statement not covered" >s</span>tate.flowing=true;<span class="cstat-no" title="statement not covered" >r</span>esume(this,state)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;<span class="fstat-no" title="function not covered" >function resume(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.resumeScheduled){<span class="cstat-no" title="statement not covered" >state.resumeScheduled=true;<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(resume_,stream,state)}</span>}<span class="fstat-no" title="function not covered" ></span>function resume_(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.reading){<span class="cstat-no" title="statement not covered" >debug("resume read 0");<span class="cstat-no" title="statement not covered" >s</span>tream.read(0)}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.resumeScheduled=false;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("resume");<span class="cstat-no" title="statement not covered" >f</span>low(stream);<span class="cstat-no" title="statement not covered" >i</span>f(state.flowing&amp;&amp;!state.reading)<span class="cstat-no" title="statement not covered" >stream.read(0)}</span></span>Readable.prototype.pause=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>debug("call pause flowing=%j",this._readableState.flowing);<span class="cstat-no" title="statement not covered" >i</span>f(false!==this._readableState.flowing){<span class="cstat-no" title="statement not covered" >debug("pause");<span class="cstat-no" title="statement not covered" >t</span>his._readableState.flowing=false;<span class="cstat-no" title="statement not covered" >t</span>his.emit("pause")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>;<span class="fstat-no" title="function not covered" >function flow(stream){<span class="cstat-no" title="statement not covered" ></span>var state=stream._readableState;<span class="cstat-no" title="statement not covered" >d</span>ebug("flow",state.flowing);<span class="cstat-no" title="statement not covered" >i</span>f(state.flowing){<span class="cstat-no" title="statement not covered" >do{<span class="cstat-no" title="statement not covered" >var chunk=stream.read()}</span>while(null!==chunk&amp;&amp;state.flowing)}</span>}</span>Readable.prototype.wrap=<span class="fstat-no" title="function not covered" >function(stream){<span class="cstat-no" title="statement not covered" ></span>var state=this._readableState;<span class="cstat-no" title="statement not covered" >v</span>ar paused=false;<span class="cstat-no" title="statement not covered" >v</span>ar self=this;<span class="cstat-no" title="statement not covered" >s</span>tream.on("end",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>debug("wrapped end");<span class="cstat-no" title="statement not covered" >i</span>f(state.decoder&amp;&amp;!state.ended){<span class="cstat-no" title="statement not covered" >var chunk=state.decoder.end();<span class="cstat-no" title="statement not covered" >i</span>f(chunk&amp;&amp;chunk.length)<span class="cstat-no" title="statement not covered" >self.push(chunk)}<span class="cstat-no" title="statement not covered" ></span></span>s</span>elf.push(null)}</span>);<span class="cstat-no" title="statement not covered" >s</span>tream.on("data",<span class="fstat-no" title="function not covered" >function(chunk){<span class="cstat-no" title="statement not covered" ></span>debug("wrapped data");<span class="cstat-no" title="statement not covered" >i</span>f(state.decoder)<span class="cstat-no" title="statement not covered" >chunk=state.decoder.write(chunk);<span class="cstat-no" title="statement not covered" >i</span></span>f(state.objectMode&amp;&amp;(chunk===null||chunk===undefined))<span class="cstat-no" title="statement not covered" >return;e</span>lse <span class="cstat-no" title="statement not covered" >if(!state.objectMode&amp;&amp;(!chunk||!chunk.length))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span></span>ar ret=self.push(chunk);<span class="cstat-no" title="statement not covered" >i</span>f(!ret){<span class="cstat-no" title="statement not covered" >paused=true;<span class="cstat-no" title="statement not covered" >s</span>tream.pause()}</span>}</span>);<span class="cstat-no" title="statement not covered" >f</span>or(var i in stream){<span class="cstat-no" title="statement not covered" >if(this[i]===undefined&amp;&amp;typeof stream[i]==="function"){<span class="cstat-no" title="statement not covered" >this[i]=<span class="fstat-no" title="function not covered" >function(method){<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return stream[method].apply(stream,arguments)}</span>}</span>(i)}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar events=["error","close","destroy","pause","resume"];<span class="cstat-no" title="statement not covered" >f</span>orEach(events,<span class="fstat-no" title="function not covered" >function(ev){<span class="cstat-no" title="statement not covered" ></span>stream.on(ev,self.emit.bind(self,ev))}</span>);<span class="cstat-no" title="statement not covered" >s</span>elf._read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>debug("wrapped _read",n);<span class="cstat-no" title="statement not covered" >i</span>f(paused){<span class="cstat-no" title="statement not covered" >paused=false;<span class="cstat-no" title="statement not covered" >s</span>tream.resume()}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn self}</span>;Readable._fromList=fromList;<span class="fstat-no" title="function not covered" >function fromList(n,state){<span class="cstat-no" title="statement not covered" ></span>var list=state.buffer;<span class="cstat-no" title="statement not covered" >v</span>ar length=state.length;<span class="cstat-no" title="statement not covered" >v</span>ar stringMode=!!state.decoder;<span class="cstat-no" title="statement not covered" >v</span>ar objectMode=!!state.objectMode;<span class="cstat-no" title="statement not covered" >v</span>ar ret;<span class="cstat-no" title="statement not covered" >i</span>f(list.length===0)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(length===0)<span class="cstat-no" title="statement not covered" >ret=null;e</span>lse <span class="cstat-no" title="statement not covered" >if(objectMode)<span class="cstat-no" title="statement not covered" >ret=list.shift();e</span>lse <span class="cstat-no" title="statement not covered" >if(!n||n&gt;=length){<span class="cstat-no" title="statement not covered" >if(stringMode)<span class="cstat-no" title="statement not covered" >ret=list.join("");e</span>lse <span class="cstat-no" title="statement not covered" >if(list.length===1)<span class="cstat-no" title="statement not covered" >ret=list[0];e</span>lse <span class="cstat-no" title="statement not covered" >ret=Buffer.concat(list,length);<span class="cstat-no" title="statement not covered" >l</span></span></span>ist.length=0}</span>else{<span class="cstat-no" title="statement not covered" >if(n&lt;list[0].length){<span class="cstat-no" title="statement not covered" >var buf=list[0];<span class="cstat-no" title="statement not covered" >r</span>et=buf.slice(0,n);<span class="cstat-no" title="statement not covered" >l</span>ist[0]=buf.slice(n)}</span>else <span class="cstat-no" title="statement not covered" >if(n===list[0].length){<span class="cstat-no" title="statement not covered" >ret=list.shift()}</span>else{<span class="cstat-no" title="statement not covered" >if(stringMode)<span class="cstat-no" title="statement not covered" >ret="";e</span>lse <span class="cstat-no" title="statement not covered" >ret=new Buffer(n);<span class="cstat-no" title="statement not covered" >v</span></span>ar c=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,l=list.length;i&lt;l&amp;&amp;c&lt;n;i++){<span class="cstat-no" title="statement not covered" >var buf=list[0];<span class="cstat-no" title="statement not covered" >v</span>ar cpy=Math.min(n-c,buf.length);<span class="cstat-no" title="statement not covered" >i</span>f(stringMode)<span class="cstat-no" title="statement not covered" >ret+=buf.slice(0,cpy);e</span>lse <span class="cstat-no" title="statement not covered" >buf.copy(ret,c,0,cpy);<span class="cstat-no" title="statement not covered" >i</span></span>f(cpy&lt;buf.length)<span class="cstat-no" title="statement not covered" >list[0]=buf.slice(cpy);e</span>lse <span class="cstat-no" title="statement not covered" >list.shift();<span class="cstat-no" title="statement not covered" >c</span></span>+=cpy}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span></span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function endReadable(stream){<span class="cstat-no" title="statement not covered" ></span>var state=stream._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(state.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new Error("endReadable called on non-empty stream");<span class="cstat-no" title="statement not covered" >i</span></span>f(!state.endEmitted){<span class="cstat-no" title="statement not covered" >state.ended=true;<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(endReadableNT,state,stream)}</span>}<span class="fstat-no" title="function not covered" ></span>function endReadableNT(state,stream){<span class="cstat-no" title="statement not covered" ></span>if(!state.endEmitted&amp;&amp;state.length===0){<span class="cstat-no" title="statement not covered" >state.endEmitted=true;<span class="cstat-no" title="statement not covered" >s</span>tream.readable=false;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("end")}</span>}<span class="fstat-no" title="function not covered" ></span>function forEach(xs,f){<span class="cstat-no" title="statement not covered" ></span>for(var i=0,l=xs.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >f(xs[i],i)}</span>}<span class="fstat-no" title="function not covered" ></span>function indexOf(xs,x){<span class="cstat-no" title="statement not covered" ></span>for(var i=0,l=xs.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >if(xs[i]===x)<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn-1}</span>}).call(this,require("_process"))},{"./_stream_duplex":57,_process:48,buffer:4,"core-util-is":6,events:20,inherits:22,isarray:56,"process-nextick-args":47,"string_decoder/":55,util:2}],59:[function(require,module,exports){"use strict";module.exports=Transform;var Duplex=require("./_stream_duplex");var util=require("core-util-is");util.inherits=require("inherits");util.inherits(Transform,Duplex);<span class="fstat-no" title="function not covered" >function TransformState(stream){<span class="cstat-no" title="statement not covered" ></span>this.afterTransform=<span class="fstat-no" title="function not covered" >function(er,data){<span class="cstat-no" title="statement not covered" ></span>return afterTransform(stream,er,data)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.needTransform=false;<span class="cstat-no" title="statement not covered" >t</span>his.transforming=false;<span class="cstat-no" title="statement not covered" >t</span>his.writecb=null;<span class="cstat-no" title="statement not covered" >t</span>his.writechunk=null;<span class="cstat-no" title="statement not covered" >t</span>his.writeencoding=null}<span class="fstat-no" title="function not covered" ></span>function afterTransform(stream,er,data){<span class="cstat-no" title="statement not covered" ></span>var ts=stream._transformState;<span class="cstat-no" title="statement not covered" >t</span>s.transforming=false;<span class="cstat-no" title="statement not covered" >v</span>ar cb=ts.writecb;<span class="cstat-no" title="statement not covered" >i</span>f(!cb)<span class="cstat-no" title="statement not covered" >return stream.emit("error",new Error("no writecb in Transform class"));<span class="cstat-no" title="statement not covered" >t</span></span>s.writechunk=null;<span class="cstat-no" title="statement not covered" >t</span>s.writecb=null;<span class="cstat-no" title="statement not covered" >i</span>f(data!==null&amp;&amp;data!==undefined)<span class="cstat-no" title="statement not covered" >stream.push(data);<span class="cstat-no" title="statement not covered" >c</span></span>b(er);<span class="cstat-no" title="statement not covered" >v</span>ar rs=stream._readableState;<span class="cstat-no" title="statement not covered" >r</span>s.reading=false;<span class="cstat-no" title="statement not covered" >i</span>f(rs.needReadable||rs.length&lt;rs.highWaterMark){<span class="cstat-no" title="statement not covered" >stream._read(rs.highWaterMark)}</span>}<span class="fstat-no" title="function not covered" ></span>function Transform(options){</span>
<span class="cstat-no" title="statement not covered" >if(!(this instanceof Transform))<span class="cstat-no" title="statement not covered" >return new Transform(options);<span class="cstat-no" title="statement not covered" >D</span></span>uplex.call(this,options);<span class="cstat-no" title="statement not covered" >t</span>his._transformState=new TransformState(this);<span class="cstat-no" title="statement not covered" >v</span>ar stream=this;<span class="cstat-no" title="statement not covered" >t</span>his._readableState.needReadable=true;<span class="cstat-no" title="statement not covered" >t</span>his._readableState.sync=false;<span class="cstat-no" title="statement not covered" >i</span>f(options){<span class="cstat-no" title="statement not covered" >if(typeof options.transform==="function")<span class="cstat-no" title="statement not covered" >this._transform=options.transform;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof options.flush==="function")<span class="cstat-no" title="statement not covered" >this._flush=options.flush}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.once("prefinish",<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(typeof this._flush==="function")<span class="cstat-no" title="statement not covered" >this._flush(<span class="fstat-no" title="function not covered" >function(er){<span class="cstat-no" title="statement not covered" ></span>done(stream,er)}</span>);e</span>lse <span class="cstat-no" title="statement not covered" >done(stream)}</span></span>)}</span>Transform.prototype.push=<span class="fstat-no" title="function not covered" >function(chunk,encoding){<span class="cstat-no" title="statement not covered" ></span>this._transformState.needTransform=false;<span class="cstat-no" title="statement not covered" >r</span>eturn Duplex.prototype.push.call(this,chunk,encoding)}</span>;Transform.prototype._transform=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>throw new Error("not implemented")}</span>;Transform.prototype._write=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>var ts=this._transformState;<span class="cstat-no" title="statement not covered" >t</span>s.writecb=cb;<span class="cstat-no" title="statement not covered" >t</span>s.writechunk=chunk;<span class="cstat-no" title="statement not covered" >t</span>s.writeencoding=encoding;<span class="cstat-no" title="statement not covered" >i</span>f(!ts.transforming){<span class="cstat-no" title="statement not covered" >var rs=this._readableState;<span class="cstat-no" title="statement not covered" >i</span>f(ts.needTransform||rs.needReadable||rs.length&lt;rs.highWaterMark)<span class="cstat-no" title="statement not covered" >this._read(rs.highWaterMark)}</span></span>}</span>;Transform.prototype._read=<span class="fstat-no" title="function not covered" >function(n){<span class="cstat-no" title="statement not covered" ></span>var ts=this._transformState;<span class="cstat-no" title="statement not covered" >i</span>f(ts.writechunk!==null&amp;&amp;ts.writecb&amp;&amp;!ts.transforming){<span class="cstat-no" title="statement not covered" >ts.transforming=true;<span class="cstat-no" title="statement not covered" >t</span>his._transform(ts.writechunk,ts.writeencoding,ts.afterTransform)}</span>else{<span class="cstat-no" title="statement not covered" >ts.needTransform=true}</span>}</span>;<span class="fstat-no" title="function not covered" >function done(stream,er){<span class="cstat-no" title="statement not covered" ></span>if(er)<span class="cstat-no" title="statement not covered" >return stream.emit("error",er);<span class="cstat-no" title="statement not covered" >v</span></span>ar ws=stream._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar ts=stream._transformState;<span class="cstat-no" title="statement not covered" >i</span>f(ws.length)<span class="cstat-no" title="statement not covered" >throw new Error("calling transform done when ws.length != 0");<span class="cstat-no" title="statement not covered" >i</span></span>f(ts.transforming)<span class="cstat-no" title="statement not covered" >throw new Error("calling transform done when still transforming");<span class="cstat-no" title="statement not covered" >r</span></span>eturn stream.push(null)}</span>},{"./_stream_duplex":57,"core-util-is":6,inherits:22}],60:[function(require,module,exports){(function(process){"use strict";module.exports=Writable;var processNextTick=require("process-nextick-args");var asyncWrite=!process.browser&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >["v0.10","v0.9."].indexOf(process.version.slice(0,5))&gt;-1?<span class="branch-0 cbranch-no" title="branch not covered" ></span>setImmediate:</span>processNextTick;var Buffer=require("buffer").Buffer;Writable.WritableState=WritableState;var util=require("core-util-is");util.inherits=require("inherits");var internalUtil={deprecate:require("util-deprecate")};var Stream;(function(){try{Stream=require("st"+"ream")}catch(_){}finally{<span class="missing-if-branch" title="if path not taken" >I</span>if(!Stream)<span class="cstat-no" title="statement not covered" >Stream=require("events").EventEmitter}</span>})();var Buffer=require("buffer").Buffer;util.inherits(Writable,Stream);<span class="fstat-no" title="function not covered" >function nop(){</span>}<span class="fstat-no" title="function not covered" >function WriteReq(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>this.chunk=chunk;<span class="cstat-no" title="statement not covered" >t</span>his.encoding=encoding;<span class="cstat-no" title="statement not covered" >t</span>his.callback=cb;<span class="cstat-no" title="statement not covered" >t</span>his.next=null}</span>var Duplex;<span class="fstat-no" title="function not covered" >function WritableState(options,stream){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >o</span>ptions=options||{};<span class="cstat-no" title="statement not covered" >t</span>his.objectMode=!!options.objectMode;<span class="cstat-no" title="statement not covered" >i</span>f(stream instanceof Duplex)<span class="cstat-no" title="statement not covered" >this.objectMode=this.objectMode||!!options.writableObjectMode;<span class="cstat-no" title="statement not covered" >v</span></span>ar hwm=options.highWaterMark;<span class="cstat-no" title="statement not covered" >v</span>ar defaultHwm=this.objectMode?16:16*1024;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=hwm||hwm===0?hwm:defaultHwm;<span class="cstat-no" title="statement not covered" >t</span>his.highWaterMark=~~this.highWaterMark;<span class="cstat-no" title="statement not covered" >t</span>his.needDrain=false;<span class="cstat-no" title="statement not covered" >t</span>his.ending=false;<span class="cstat-no" title="statement not covered" >t</span>his.ended=false;<span class="cstat-no" title="statement not covered" >t</span>his.finished=false;<span class="cstat-no" title="statement not covered" >v</span>ar noDecode=options.decodeStrings===false;<span class="cstat-no" title="statement not covered" >t</span>his.decodeStrings=!noDecode;<span class="cstat-no" title="statement not covered" >t</span>his.defaultEncoding=options.defaultEncoding||"utf8";<span class="cstat-no" title="statement not covered" >t</span>his.length=0;<span class="cstat-no" title="statement not covered" >t</span>his.writing=false;<span class="cstat-no" title="statement not covered" >t</span>his.corked=0;<span class="cstat-no" title="statement not covered" >t</span>his.sync=true;<span class="cstat-no" title="statement not covered" >t</span>his.bufferProcessing=false;<span class="cstat-no" title="statement not covered" >t</span>his.onwrite=<span class="fstat-no" title="function not covered" >function(er){<span class="cstat-no" title="statement not covered" ></span>onwrite(stream,er)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.writecb=null;<span class="cstat-no" title="statement not covered" >t</span>his.writelen=0;<span class="cstat-no" title="statement not covered" >t</span>his.bufferedRequest=null;<span class="cstat-no" title="statement not covered" >t</span>his.lastBufferedRequest=null;<span class="cstat-no" title="statement not covered" >t</span>his.pendingcb=0;<span class="cstat-no" title="statement not covered" >t</span>his.prefinished=false;<span class="cstat-no" title="statement not covered" >t</span>his.errorEmitted=false;<span class="cstat-no" title="statement not covered" >t</span>his.bufferedRequestCount=0;<span class="cstat-no" title="statement not covered" >t</span>his.corkedRequestsFree=new CorkedRequest(this);<span class="cstat-no" title="statement not covered" >t</span>his.corkedRequestsFree.next=new CorkedRequest(this)}</span>WritableState.prototype.getBuffer=<span class="fstat-no" title="function not covered" >function writableStateGetBuffer(){<span class="cstat-no" title="statement not covered" ></span>var current=this.bufferedRequest;<span class="cstat-no" title="statement not covered" >v</span>ar out=[];<span class="cstat-no" title="statement not covered" >w</span>hile(current){<span class="cstat-no" title="statement not covered" >out.push(current);<span class="cstat-no" title="statement not covered" >c</span>urrent=current.next}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn out}</span>;(function(){try{Object.defineProperty(WritableState.prototype,"buffer",{get:internalUtil.deprecate(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this.getBuffer()}</span>,"_writableState.buffer is deprecated. Use _writableState.getBuffer "+"instead.")})}catch(_){}})();var Duplex;<span class="fstat-no" title="function not covered" >function Writable(options){<span class="cstat-no" title="statement not covered" ></span>Duplex=Duplex||require("./_stream_duplex");<span class="cstat-no" title="statement not covered" >i</span>f(!(this instanceof Writable)&amp;&amp;!(this instanceof Duplex))<span class="cstat-no" title="statement not covered" >return new Writable(options);<span class="cstat-no" title="statement not covered" >t</span></span>his._writableState=new WritableState(options,this);<span class="cstat-no" title="statement not covered" >t</span>his.writable=true;<span class="cstat-no" title="statement not covered" >i</span>f(options){<span class="cstat-no" title="statement not covered" >if(typeof options.write==="function")<span class="cstat-no" title="statement not covered" >this._write=options.write;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof options.writev==="function")<span class="cstat-no" title="statement not covered" >this._writev=options.writev}<span class="cstat-no" title="statement not covered" ></span></span>S</span>tream.call(this)}</span>Writable.prototype.pipe=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.emit("error",new Error("Cannot pipe. Not readable."))}</span>;<span class="fstat-no" title="function not covered" >function writeAfterEnd(stream,cb){<span class="cstat-no" title="statement not covered" ></span>var er=new Error("write after end");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",er);<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(cb,er)}<span class="fstat-no" title="function not covered" ></span>function validChunk(stream,state,chunk,cb){<span class="cstat-no" title="statement not covered" ></span>var valid=true;<span class="cstat-no" title="statement not covered" >i</span>f(!Buffer.isBuffer(chunk)&amp;&amp;typeof chunk!=="string"&amp;&amp;chunk!==null&amp;&amp;chunk!==undefined&amp;&amp;!state.objectMode){<span class="cstat-no" title="statement not covered" >var er=new TypeError("Invalid non-string/buffer chunk");<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",er);<span class="cstat-no" title="statement not covered" >p</span>rocessNextTick(cb,er);<span class="cstat-no" title="statement not covered" >v</span>alid=false}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn valid}</span>Writable.prototype.write=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar ret=false;<span class="cstat-no" title="statement not covered" >i</span>f(typeof encoding==="function"){<span class="cstat-no" title="statement not covered" >cb=encoding;<span class="cstat-no" title="statement not covered" >e</span>ncoding=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Buffer.isBuffer(chunk))<span class="cstat-no" title="statement not covered" >encoding="buffer";e</span>lse <span class="cstat-no" title="statement not covered" >if(!encoding)<span class="cstat-no" title="statement not covered" >encoding=state.defaultEncoding;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(typeof cb!=="function")<span class="cstat-no" title="statement not covered" >cb=nop;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.ended)<span class="cstat-no" title="statement not covered" >writeAfterEnd(this,cb);e</span>lse <span class="cstat-no" title="statement not covered" >if(validChunk(this,state,chunk,cb)){<span class="cstat-no" title="statement not covered" >state.pendingcb++;<span class="cstat-no" title="statement not covered" >r</span>et=writeOrBuffer(this,state,chunk,encoding,cb)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn ret}</span>;Writable.prototype.cork=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >s</span>tate.corked++}</span>;Writable.prototype.uncork=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >i</span>f(state.corked){<span class="cstat-no" title="statement not covered" >state.corked--;<span class="cstat-no" title="statement not covered" >i</span>f(!state.writing&amp;&amp;!state.corked&amp;&amp;!state.finished&amp;&amp;!state.bufferProcessing&amp;&amp;state.bufferedRequest)<span class="cstat-no" title="statement not covered" >clearBuffer(this,state)}</span></span>}</span>;Writable.prototype.setDefaultEncoding=<span class="fstat-no" title="function not covered" >function setDefaultEncoding(encoding){<span class="cstat-no" title="statement not covered" ></span>if(typeof encoding==="string")<span class="cstat-no" title="statement not covered" >encoding=encoding.toLowerCase();<span class="cstat-no" title="statement not covered" >i</span></span>f(!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((encoding+"").toLowerCase())&gt;-1))<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+encoding);<span class="cstat-no" title="statement not covered" >t</span></span>his._writableState.defaultEncoding=encoding}</span>;<span class="fstat-no" title="function not covered" >function decodeChunk(state,chunk,encoding){<span class="cstat-no" title="statement not covered" ></span>if(!state.objectMode&amp;&amp;state.decodeStrings!==false&amp;&amp;typeof chunk==="string"){<span class="cstat-no" title="statement not covered" >chunk=new Buffer(chunk,encoding)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn chunk}<span class="fstat-no" title="function not covered" ></span>function writeOrBuffer(stream,state,chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>chunk=decodeChunk(state,chunk,encoding);<span class="cstat-no" title="statement not covered" >i</span>f(Buffer.isBuffer(chunk))<span class="cstat-no" title="statement not covered" >encoding="buffer";<span class="cstat-no" title="statement not covered" >v</span></span>ar len=state.objectMode?1:chunk.length;<span class="cstat-no" title="statement not covered" >s</span>tate.length+=len;<span class="cstat-no" title="statement not covered" >v</span>ar ret=state.length&lt;state.highWaterMark;<span class="cstat-no" title="statement not covered" >i</span>f(!ret)<span class="cstat-no" title="statement not covered" >state.needDrain=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(state.writing||state.corked){<span class="cstat-no" title="statement not covered" >var last=state.lastBufferedRequest;<span class="cstat-no" title="statement not covered" >s</span>tate.lastBufferedRequest=new WriteReq(chunk,encoding,cb);<span class="cstat-no" title="statement not covered" >i</span>f(last){<span class="cstat-no" title="statement not covered" >last.next=state.lastBufferedRequest}</span>else{<span class="cstat-no" title="statement not covered" >state.bufferedRequest=state.lastBufferedRequest}<span class="cstat-no" title="statement not covered" ></span>s</span>tate.bufferedRequestCount+=1}</span>else{<span class="cstat-no" title="statement not covered" >doWrite(stream,state,false,len,chunk,encoding,cb)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}<span class="fstat-no" title="function not covered" ></span>function doWrite(stream,state,writev,len,chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>state.writelen=len;<span class="cstat-no" title="statement not covered" >s</span>tate.writecb=cb;<span class="cstat-no" title="statement not covered" >s</span>tate.writing=true;<span class="cstat-no" title="statement not covered" >s</span>tate.sync=true;<span class="cstat-no" title="statement not covered" >i</span>f(writev)<span class="cstat-no" title="statement not covered" >stream._writev(chunk,state.onwrite);e</span>lse <span class="cstat-no" title="statement not covered" >stream._write(chunk,encoding,state.onwrite);<span class="cstat-no" title="statement not covered" >s</span></span>tate.sync=false}<span class="fstat-no" title="function not covered" ></span>function onwriteError(stream,state,sync,er,cb){<span class="cstat-no" title="statement not covered" ></span>--state.pendingcb;<span class="cstat-no" title="statement not covered" >i</span>f(sync)<span class="cstat-no" title="statement not covered" >processNextTick(cb,er);e</span>lse <span class="cstat-no" title="statement not covered" >cb(er);<span class="cstat-no" title="statement not covered" >s</span></span>tream._writableState.errorEmitted=true;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("error",er)}<span class="fstat-no" title="function not covered" ></span>function onwriteStateUpdate(state){<span class="cstat-no" title="statement not covered" ></span>state.writing=false;<span class="cstat-no" title="statement not covered" >s</span>tate.writecb=null;<span class="cstat-no" title="statement not covered" >s</span>tate.length-=state.writelen;<span class="cstat-no" title="statement not covered" >s</span>tate.writelen=0}<span class="fstat-no" title="function not covered" ></span>function onwrite(stream,er){<span class="cstat-no" title="statement not covered" ></span>var state=stream._writableState;<span class="cstat-no" title="statement not covered" >v</span>ar sync=state.sync;<span class="cstat-no" title="statement not covered" >v</span>ar cb=state.writecb;<span class="cstat-no" title="statement not covered" >o</span>nwriteStateUpdate(state);<span class="cstat-no" title="statement not covered" >i</span>f(er)<span class="cstat-no" title="statement not covered" >onwriteError(stream,state,sync,er,cb);e</span>lse{<span class="cstat-no" title="statement not covered" >var finished=needFinish(state);<span class="cstat-no" title="statement not covered" >i</span>f(!finished&amp;&amp;!state.corked&amp;&amp;!state.bufferProcessing&amp;&amp;state.bufferedRequest){<span class="cstat-no" title="statement not covered" >clearBuffer(stream,state)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(sync){<span class="cstat-no" title="statement not covered" >asyncWrite(afterWrite,stream,state,finished,cb)}</span>else{<span class="cstat-no" title="statement not covered" >afterWrite(stream,state,finished,cb)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function afterWrite(stream,state,finished,cb){<span class="cstat-no" title="statement not covered" ></span>if(!finished)<span class="cstat-no" title="statement not covered" >onwriteDrain(stream,state);<span class="cstat-no" title="statement not covered" >s</span></span>tate.pendingcb--;<span class="cstat-no" title="statement not covered" >c</span>b();<span class="cstat-no" title="statement not covered" >f</span>inishMaybe(stream,state)}<span class="fstat-no" title="function not covered" ></span>function onwriteDrain(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(state.length===0&amp;&amp;state.needDrain){<span class="cstat-no" title="statement not covered" >state.needDrain=false;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("drain")}</span>}<span class="fstat-no" title="function not covered" ></span>function clearBuffer(stream,state){<span class="cstat-no" title="statement not covered" ></span>state.bufferProcessing=true;<span class="cstat-no" title="statement not covered" >v</span>ar entry=state.bufferedRequest;<span class="cstat-no" title="statement not covered" >i</span>f(stream._writev&amp;&amp;entry&amp;&amp;entry.next){<span class="cstat-no" title="statement not covered" >var l=state.bufferedRequestCount;<span class="cstat-no" title="statement not covered" >v</span>ar buffer=new Array(l);<span class="cstat-no" title="statement not covered" >v</span>ar holder=state.corkedRequestsFree;<span class="cstat-no" title="statement not covered" >h</span>older.entry=entry;<span class="cstat-no" title="statement not covered" >v</span>ar count=0;<span class="cstat-no" title="statement not covered" >w</span>hile(entry){<span class="cstat-no" title="statement not covered" >buffer[count]=entry;<span class="cstat-no" title="statement not covered" >e</span>ntry=entry.next;<span class="cstat-no" title="statement not covered" >c</span>ount+=1}<span class="cstat-no" title="statement not covered" ></span>d</span>oWrite(stream,state,true,state.length,buffer,"",holder.finish);<span class="cstat-no" title="statement not covered" >s</span>tate.pendingcb++;<span class="cstat-no" title="statement not covered" >s</span>tate.lastBufferedRequest=null;<span class="cstat-no" title="statement not covered" >s</span>tate.corkedRequestsFree=holder.next;<span class="cstat-no" title="statement not covered" >h</span>older.next=null}</span>else{<span class="cstat-no" title="statement not covered" >while(entry){<span class="cstat-no" title="statement not covered" >var chunk=entry.chunk;<span class="cstat-no" title="statement not covered" >v</span>ar encoding=entry.encoding;<span class="cstat-no" title="statement not covered" >v</span>ar cb=entry.callback;<span class="cstat-no" title="statement not covered" >v</span>ar len=state.objectMode?1:chunk.length;<span class="cstat-no" title="statement not covered" >d</span>oWrite(stream,state,false,len,chunk,encoding,cb);<span class="cstat-no" title="statement not covered" >e</span>ntry=entry.next;<span class="cstat-no" title="statement not covered" >i</span>f(state.writing){<span class="cstat-no" title="statement not covered" >break}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(entry===null)<span class="cstat-no" title="statement not covered" >state.lastBufferedRequest=null}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tate.bufferedRequestCount=0;<span class="cstat-no" title="statement not covered" >s</span>tate.bufferedRequest=entry;<span class="cstat-no" title="statement not covered" >s</span>tate.bufferProcessing=false}</span>Writable.prototype._write=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>cb(new Error("not implemented"))}</span>;Writable.prototype._writev=null;Writable.prototype.end=<span class="fstat-no" title="function not covered" >function(chunk,encoding,cb){<span class="cstat-no" title="statement not covered" ></span>var state=this._writableState;<span class="cstat-no" title="statement not covered" >i</span>f(typeof chunk==="function"){<span class="cstat-no" title="statement not covered" >cb=chunk;<span class="cstat-no" title="statement not covered" >c</span>hunk=null;<span class="cstat-no" title="statement not covered" >e</span>ncoding=null}</span>else <span class="cstat-no" title="statement not covered" >if(typeof encoding==="function"){<span class="cstat-no" title="statement not covered" >cb=encoding;<span class="cstat-no" title="statement not covered" >e</span>ncoding=null}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(chunk!==null&amp;&amp;chunk!==undefined)<span class="cstat-no" title="statement not covered" >this.write(chunk,encoding);<span class="cstat-no" title="statement not covered" >i</span></span>f(state.corked){<span class="cstat-no" title="statement not covered" >state.corked=1;<span class="cstat-no" title="statement not covered" >t</span>his.uncork()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!state.ending&amp;&amp;!state.finished)<span class="cstat-no" title="statement not covered" >endWritable(this,state,cb)}</span></span>;<span class="fstat-no" title="function not covered" >function needFinish(state){<span class="cstat-no" title="statement not covered" ></span>return state.ending&amp;&amp;state.length===0&amp;&amp;state.bufferedRequest===null&amp;&amp;!state.finished&amp;&amp;!state.writing}<span class="fstat-no" title="function not covered" ></span>function prefinish(stream,state){<span class="cstat-no" title="statement not covered" ></span>if(!state.prefinished){<span class="cstat-no" title="statement not covered" >state.prefinished=true;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("prefinish")}</span>}<span class="fstat-no" title="function not covered" ></span>function finishMaybe(stream,state){<span class="cstat-no" title="statement not covered" ></span>var need=needFinish(state);<span class="cstat-no" title="statement not covered" >i</span>f(need){<span class="cstat-no" title="statement not covered" >if(state.pendingcb===0){<span class="cstat-no" title="statement not covered" >prefinish(stream,state);<span class="cstat-no" title="statement not covered" >s</span>tate.finished=true;<span class="cstat-no" title="statement not covered" >s</span>tream.emit("finish")}</span>else{<span class="cstat-no" title="statement not covered" >prefinish(stream,state)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn need}<span class="fstat-no" title="function not covered" ></span>function endWritable(stream,state,cb){<span class="cstat-no" title="statement not covered" ></span>state.ending=true;<span class="cstat-no" title="statement not covered" >f</span>inishMaybe(stream,state);<span class="cstat-no" title="statement not covered" >i</span>f(cb){<span class="cstat-no" title="statement not covered" >if(state.finished)<span class="cstat-no" title="statement not covered" >processNextTick(cb);e</span>lse <span class="cstat-no" title="statement not covered" >stream.once("finish",cb)}<span class="cstat-no" title="statement not covered" ></span></span>s</span>tate.ended=true;<span class="cstat-no" title="statement not covered" >s</span>tream.writable=false}<span class="fstat-no" title="function not covered" ></span>function CorkedRequest(state){<span class="cstat-no" title="statement not covered" ></span>var _this=this;<span class="cstat-no" title="statement not covered" >t</span>his.next=null;<span class="cstat-no" title="statement not covered" >t</span>his.entry=null;<span class="cstat-no" title="statement not covered" >t</span>his.finish=<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>var entry=_this.entry;<span class="cstat-no" title="statement not covered" >_</span>this.entry=null;<span class="cstat-no" title="statement not covered" >w</span>hile(entry){<span class="cstat-no" title="statement not covered" >var cb=entry.callback;<span class="cstat-no" title="statement not covered" >s</span>tate.pendingcb--;<span class="cstat-no" title="statement not covered" >c</span>b(err);<span class="cstat-no" title="statement not covered" >e</span>ntry=entry.next}<span class="cstat-no" title="statement not covered" ></span>i</span>f(state.corkedRequestsFree){<span class="cstat-no" title="statement not covered" >state.corkedRequestsFree.next=_this}</span>else{<span class="cstat-no" title="statement not covered" >state.corkedRequestsFree=_this}</span>}</span>}</span>}).call(this,require("_process"))},{"./_stream_duplex":57,_process:48,buffer:4,"core-util-is":6,events:20,inherits:22,"process-nextick-args":47,"util-deprecate":65}],61:[function(require,module,exports){module.exports=require("./lib/_stream_transform.js")},{"./lib/_stream_transform.js":59}],62:[function(require,module,exports){(function(process){var Transform=require("readable-stream/transform"),inherits=require("util").inherits,xtend=require("xtend");<span class="fstat-no" title="function not covered" >function DestroyableTransform(opts){<span class="cstat-no" title="statement not covered" ></span>Transform.call(this,opts);<span class="cstat-no" title="statement not covered" >t</span>his._destroyed=false}</span>inherits(DestroyableTransform,Transform);DestroyableTransform.prototype.destroy=<span class="fstat-no" title="function not covered" >function(err){<span class="cstat-no" title="statement not covered" ></span>if(this._destroyed)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._destroyed=true;<span class="cstat-no" title="statement not covered" >v</span>ar self=this;<span class="cstat-no" title="statement not covered" >p</span>rocess.nextTick(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(err)<span class="cstat-no" title="statement not covered" >self.emit("error",err);<span class="cstat-no" title="statement not covered" >s</span></span>elf.emit("close")}</span>)}</span>;<span class="fstat-no" title="function not covered" >function noop(chunk,enc,callback){<span class="cstat-no" title="statement not covered" ></span>callback(null,chunk)}</span>function through2(construct){return <span class="fstat-no" title="function not covered" >function(options,transform,flush){<span class="cstat-no" title="statement not covered" ></span>if(typeof options=="function"){<span class="cstat-no" title="statement not covered" >flush=transform;<span class="cstat-no" title="statement not covered" >t</span>ransform=options;<span class="cstat-no" title="statement not covered" >o</span>ptions={}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof transform!="function")<span class="cstat-no" title="statement not covered" >transform=noop;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof flush!="function")<span class="cstat-no" title="statement not covered" >flush=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn construct(options,transform,flush)}</span>}module.exports=through2(<span class="fstat-no" title="function not covered" >function(options,transform,flush){<span class="cstat-no" title="statement not covered" ></span>var t2=new DestroyableTransform(options);<span class="cstat-no" title="statement not covered" >t</span>2._transform=transform;<span class="cstat-no" title="statement not covered" >i</span>f(flush)<span class="cstat-no" title="statement not covered" >t2._flush=flush;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t2}</span>);module.exports.ctor=through2(<span class="fstat-no" title="function not covered" >function(options,transform,flush){<span class="fstat-no" title="function not covered" ></span>function Through2(override){<span class="cstat-no" title="statement not covered" ></span>if(!(this instanceof Through2))<span class="cstat-no" title="statement not covered" >return new Through2(override);<span class="cstat-no" title="statement not covered" >t</span></span>his.options=xtend(options,override);<span class="cstat-no" title="statement not covered" >D</span>estroyableTransform.call(this,this.options)}<span class="cstat-no" title="statement not covered" ></span>inherits(Through2,DestroyableTransform);<span class="cstat-no" title="statement not covered" >T</span>hrough2.prototype._transform=transform;<span class="cstat-no" title="statement not covered" >i</span>f(flush)<span class="cstat-no" title="statement not covered" >Through2.prototype._flush=flush;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Through2}</span>);module.exports.obj=through2(<span class="fstat-no" title="function not covered" >function(options,transform,flush){<span class="cstat-no" title="statement not covered" ></span>var t2=new DestroyableTransform(xtend({objectMode:true,highWaterMark:16},options));<span class="cstat-no" title="statement not covered" >t</span>2._transform=transform;<span class="cstat-no" title="statement not covered" >i</span>f(flush)<span class="cstat-no" title="statement not covered" >t2._flush=flush;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t2}</span>)}).call(this,require("_process"))},{_process:48,"readable-stream/transform":61,util:68,xtend:72}],63:[function(require,module,exports){"use strict";var punycode=require("punycode");var util=require("./util");exports.parse=urlParse;exports.resolve=urlResolve;exports.resolveObject=urlResolveObject;exports.format=urlFormat;exports.Url=Url;<span class="fstat-no" title="function not covered" >function Url(){<span class="cstat-no" title="statement not covered" ></span>this.protocol=null;<span class="cstat-no" title="statement not covered" >t</span>his.slashes=null;<span class="cstat-no" title="statement not covered" >t</span>his.auth=null;<span class="cstat-no" title="statement not covered" >t</span>his.host=null;<span class="cstat-no" title="statement not covered" >t</span>his.port=null;<span class="cstat-no" title="statement not covered" >t</span>his.hostname=null;<span class="cstat-no" title="statement not covered" >t</span>his.hash=null;<span class="cstat-no" title="statement not covered" >t</span>his.search=null;<span class="cstat-no" title="statement not covered" >t</span>his.query=null;<span class="cstat-no" title="statement not covered" >t</span>his.pathname=null;<span class="cstat-no" title="statement not covered" >t</span>his.path=null;<span class="cstat-no" title="statement not covered" >t</span>his.href=null}</span>var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,simplePathPattern=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,delims=["&lt;","&gt;",'"',"`"," ","\r","\n","\t"],unwise=["{","}","|","\\","^","`"].concat(delims),autoEscape=["'"].concat(unwise),nonHostChars=["%","/","?",";","#"].concat(autoEscape),hostEndingChars=["/","?","#"],hostnameMaxLen=255,hostnamePartPattern=/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,unsafeProtocol={javascript:true,"javascript:":true},hostlessProtocol={javascript:true,"javascript:":true},slashedProtocol={http:true,https:true,ftp:true,gopher:true,file:true,"http:":true,"https:":true,"ftp:":true,"gopher:":true,"file:":true},querystring=require("querystring");<span class="fstat-no" title="function not covered" >function urlParse(url,parseQueryString,slashesDenoteHost){<span class="cstat-no" title="statement not covered" ></span>if(url&amp;&amp;util.isObject(url)&amp;&amp;url instanceof Url)<span class="cstat-no" title="statement not covered" >return url;<span class="cstat-no" title="statement not covered" >v</span></span>ar u=new Url;<span class="cstat-no" title="statement not covered" >u</span>.parse(url,parseQueryString,slashesDenoteHost);<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>Url.prototype.parse=<span class="fstat-no" title="function not covered" >function(url,parseQueryString,slashesDenoteHost){<span class="cstat-no" title="statement not covered" ></span>if(!util.isString(url)){<span class="cstat-no" title="statement not covered" >throw new TypeError("Parameter 'url' must be a string, not "+typeof url)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar queryIndex=url.indexOf("?"),splitter=queryIndex!==-1&amp;&amp;queryIndex&lt;url.indexOf("#")?"?":"#",uSplit=url.split(splitter),slashRegex=/\\/g;<span class="cstat-no" title="statement not covered" >u</span>Split[0]=uSplit[0].replace(slashRegex,"/");<span class="cstat-no" title="statement not covered" >u</span>rl=uSplit.join(splitter);<span class="cstat-no" title="statement not covered" >v</span>ar rest=url;<span class="cstat-no" title="statement not covered" >r</span>est=rest.trim();<span class="cstat-no" title="statement not covered" >i</span>f(!slashesDenoteHost&amp;&amp;url.split("#").length===1){<span class="cstat-no" title="statement not covered" >var simplePath=simplePathPattern.exec(rest);<span class="cstat-no" title="statement not covered" >i</span>f(simplePath){<span class="cstat-no" title="statement not covered" >this.path=rest;<span class="cstat-no" title="statement not covered" >t</span>his.href=rest;<span class="cstat-no" title="statement not covered" >t</span>his.pathname=simplePath[1];<span class="cstat-no" title="statement not covered" >i</span>f(simplePath[2]){<span class="cstat-no" title="statement not covered" >this.search=simplePath[2];<span class="cstat-no" title="statement not covered" >i</span>f(parseQueryString){<span class="cstat-no" title="statement not covered" >this.query=querystring.parse(this.search.substr(1))}</span>else{<span class="cstat-no" title="statement not covered" >this.query=this.search.substr(1)}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(parseQueryString){<span class="cstat-no" title="statement not covered" >this.search="";<span class="cstat-no" title="statement not covered" >t</span>his.query={}}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar proto=protocolPattern.exec(rest);<span class="cstat-no" title="statement not covered" >i</span>f(proto){<span class="cstat-no" title="statement not covered" >proto=proto[0];<span class="cstat-no" title="statement not covered" >v</span>ar lowerProto=proto.toLowerCase();<span class="cstat-no" title="statement not covered" >t</span>his.protocol=lowerProto;<span class="cstat-no" title="statement not covered" >r</span>est=rest.substr(proto.length)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(slashesDenoteHost||proto||rest.match(/^\/\/[^@\/]+@[^@\/]+/)){<span class="cstat-no" title="statement not covered" >var slashes=rest.substr(0,2)==="//";<span class="cstat-no" title="statement not covered" >i</span>f(slashes&amp;&amp;!(proto&amp;&amp;hostlessProtocol[proto])){<span class="cstat-no" title="statement not covered" >rest=rest.substr(2);<span class="cstat-no" title="statement not covered" >t</span>his.slashes=true}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!hostlessProtocol[proto]&amp;&amp;(slashes||proto&amp;&amp;!slashedProtocol[proto])){<span class="cstat-no" title="statement not covered" >var hostEnd=-1;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;hostEndingChars.length;i++){<span class="cstat-no" title="statement not covered" >var hec=rest.indexOf(hostEndingChars[i]);<span class="cstat-no" title="statement not covered" >i</span>f(hec!==-1&amp;&amp;(hostEnd===-1||hec&lt;hostEnd))<span class="cstat-no" title="statement not covered" >hostEnd=hec}<span class="cstat-no" title="statement not covered" ></span></span>v</span>ar auth,atSign;<span class="cstat-no" title="statement not covered" >i</span>f(hostEnd===-1){<span class="cstat-no" title="statement not covered" >atSign=rest.lastIndexOf("@")}</span>else{<span class="cstat-no" title="statement not covered" >atSign=rest.lastIndexOf("@",hostEnd)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(atSign!==-1){<span class="cstat-no" title="statement not covered" >auth=rest.slice(0,atSign);<span class="cstat-no" title="statement not covered" >r</span>est=rest.slice(atSign+1);<span class="cstat-no" title="statement not covered" >t</span>his.auth=decodeURIComponent(auth)}<span class="cstat-no" title="statement not covered" ></span>h</span>ostEnd=-1;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;nonHostChars.length;i++){<span class="cstat-no" title="statement not covered" >var hec=rest.indexOf(nonHostChars[i]);<span class="cstat-no" title="statement not covered" >i</span>f(hec!==-1&amp;&amp;(hostEnd===-1||hec&lt;hostEnd))<span class="cstat-no" title="statement not covered" >hostEnd=hec}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(hostEnd===-1)<span class="cstat-no" title="statement not covered" >hostEnd=rest.length;<span class="cstat-no" title="statement not covered" >t</span></span>his.host=rest.slice(0,hostEnd);<span class="cstat-no" title="statement not covered" >r</span>est=rest.slice(hostEnd);<span class="cstat-no" title="statement not covered" >t</span>his.parseHost();<span class="cstat-no" title="statement not covered" >t</span>his.hostname=this.hostname||"";<span class="cstat-no" title="statement not covered" >v</span>ar ipv6Hostname=this.hostname[0]==="["&amp;&amp;this.hostname[this.hostname.length-1]==="]";<span class="cstat-no" title="statement not covered" >i</span>f(!ipv6Hostname){<span class="cstat-no" title="statement not covered" >var hostparts=this.hostname.split(/\./);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,l=hostparts.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >var part=hostparts[i];<span class="cstat-no" title="statement not covered" >i</span>f(!part)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!part.match(hostnamePartPattern)){<span class="cstat-no" title="statement not covered" >var newpart="";<span class="cstat-no" title="statement not covered" >f</span>or(var j=0,k=part.length;j&lt;k;j++){<span class="cstat-no" title="statement not covered" >if(part.charCodeAt(j)&gt;127){<span class="cstat-no" title="statement not covered" >newpart+="x"}</span>else{<span class="cstat-no" title="statement not covered" >newpart+=part[j]}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!newpart.match(hostnamePartPattern)){<span class="cstat-no" title="statement not covered" >var validParts=hostparts.slice(0,i);<span class="cstat-no" title="statement not covered" >v</span>ar notHost=hostparts.slice(i+1);<span class="cstat-no" title="statement not covered" >v</span>ar bit=part.match(hostnamePartStart);<span class="cstat-no" title="statement not covered" >i</span>f(bit){<span class="cstat-no" title="statement not covered" >validParts.push(bit[1]);<span class="cstat-no" title="statement not covered" >n</span>otHost.unshift(bit[2])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(notHost.length){<span class="cstat-no" title="statement not covered" >rest="/"+notHost.join(".")+rest}<span class="cstat-no" title="statement not covered" ></span>t</span>his.hostname=validParts.join(".");<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.hostname.length&gt;hostnameMaxLen){<span class="cstat-no" title="statement not covered" >this.hostname=""}</span>else{<span class="cstat-no" title="statement not covered" >this.hostname=this.hostname.toLowerCase()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!ipv6Hostname){<span class="cstat-no" title="statement not covered" >this.hostname=punycode.toASCII(this.hostname)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar p=this.port?":"+this.port:"";<span class="cstat-no" title="statement not covered" >v</span>ar h=this.hostname||"";<span class="cstat-no" title="statement not covered" >t</span>his.host=h+p;<span class="cstat-no" title="statement not covered" >t</span>his.href+=this.host;<span class="cstat-no" title="statement not covered" >i</span>f(ipv6Hostname){<span class="cstat-no" title="statement not covered" >this.hostname=this.hostname.substr(1,this.hostname.length-2);<span class="cstat-no" title="statement not covered" >i</span>f(rest[0]!=="/"){<span class="cstat-no" title="statement not covered" >rest="/"+rest}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!unsafeProtocol[lowerProto]){<span class="cstat-no" title="statement not covered" >for(var i=0,l=autoEscape.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >var ae=autoEscape[i];<span class="cstat-no" title="statement not covered" >i</span>f(rest.indexOf(ae)===-1)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar esc=encodeURIComponent(ae);<span class="cstat-no" title="statement not covered" >i</span>f(esc===ae){<span class="cstat-no" title="statement not covered" >esc=escape(ae)}<span class="cstat-no" title="statement not covered" ></span>r</span>est=rest.split(ae).join(esc)}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar hash=rest.indexOf("#");<span class="cstat-no" title="statement not covered" >i</span>f(hash!==-1){<span class="cstat-no" title="statement not covered" >this.hash=rest.substr(hash);<span class="cstat-no" title="statement not covered" >r</span>est=rest.slice(0,hash)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar qm=rest.indexOf("?");<span class="cstat-no" title="statement not covered" >i</span>f(qm!==-1){<span class="cstat-no" title="statement not covered" >this.search=rest.substr(qm);<span class="cstat-no" title="statement not covered" >t</span>his.query=rest.substr(qm+1);<span class="cstat-no" title="statement not covered" >i</span>f(parseQueryString){<span class="cstat-no" title="statement not covered" >this.query=querystring.parse(this.query)}<span class="cstat-no" title="statement not covered" ></span>r</span>est=rest.slice(0,qm)}</span>else <span class="cstat-no" title="statement not covered" >if(parseQueryString){<span class="cstat-no" title="statement not covered" >this.search="";<span class="cstat-no" title="statement not covered" >t</span>his.query={}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(rest)<span class="cstat-no" title="statement not covered" >this.pathname=rest;<span class="cstat-no" title="statement not covered" >i</span></span>f(slashedProtocol[lowerProto]&amp;&amp;this.hostname&amp;&amp;!this.pathname){<span class="cstat-no" title="statement not covered" >this.pathname="/"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.pathname||this.search){<span class="cstat-no" title="statement not covered" >var p=this.pathname||"";<span class="cstat-no" title="statement not covered" >v</span>ar s=this.search||"";<span class="cstat-no" title="statement not covered" >t</span>his.path=p+s}<span class="cstat-no" title="statement not covered" ></span>t</span>his.href=this.format();<span class="cstat-no" title="statement not covered" >r</span>eturn this}</span>;<span class="fstat-no" title="function not covered" >function urlFormat(obj){<span class="cstat-no" title="statement not covered" ></span>if(util.isString(obj))<span class="cstat-no" title="statement not covered" >obj=urlParse(obj);<span class="cstat-no" title="statement not covered" >i</span></span>f(!(obj instanceof Url))<span class="cstat-no" title="statement not covered" >return Url.prototype.format.call(obj);<span class="cstat-no" title="statement not covered" >r</span></span>eturn obj.format()}</span>Url.prototype.format=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var auth=this.auth||"";<span class="cstat-no" title="statement not covered" >i</span>f(auth){<span class="cstat-no" title="statement not covered" >auth=encodeURIComponent(auth);<span class="cstat-no" title="statement not covered" >a</span>uth=auth.replace(/%3A/i,":");<span class="cstat-no" title="statement not covered" >a</span>uth+="@"}<span class="cstat-no" title="statement not covered" ></span>v</span>ar protocol=this.protocol||"",pathname=this.pathname||"",hash=this.hash||"",host=false,query="";<span class="cstat-no" title="statement not covered" >i</span>f(this.host){<span class="cstat-no" title="statement not covered" >host=auth+this.host}</span>else <span class="cstat-no" title="statement not covered" >if(this.hostname){<span class="cstat-no" title="statement not covered" >host=auth+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]");<span class="cstat-no" title="statement not covered" >i</span>f(this.port){<span class="cstat-no" title="statement not covered" >host+=":"+this.port}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(this.query&amp;&amp;util.isObject(this.query)&amp;&amp;Object.keys(this.query).length){<span class="cstat-no" title="statement not covered" >query=querystring.stringify(this.query)}<span class="cstat-no" title="statement not covered" ></span>v</span>ar search=this.search||query&amp;&amp;"?"+query||"";<span class="cstat-no" title="statement not covered" >i</span>f(protocol&amp;&amp;protocol.substr(-1)!==":")<span class="cstat-no" title="statement not covered" >protocol+=":";<span class="cstat-no" title="statement not covered" >i</span></span>f(this.slashes||(!protocol||slashedProtocol[protocol])&amp;&amp;host!==false){<span class="cstat-no" title="statement not covered" >host="//"+(host||"");<span class="cstat-no" title="statement not covered" >i</span>f(pathname&amp;&amp;pathname.charAt(0)!=="/")<span class="cstat-no" title="statement not covered" >pathname="/"+pathname}</span></span>else <span class="cstat-no" title="statement not covered" >if(!host){<span class="cstat-no" title="statement not covered" >host=""}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(hash&amp;&amp;hash.charAt(0)!=="#")<span class="cstat-no" title="statement not covered" >hash="#"+hash;<span class="cstat-no" title="statement not covered" >i</span></span>f(search&amp;&amp;search.charAt(0)!=="?")<span class="cstat-no" title="statement not covered" >search="?"+search;<span class="cstat-no" title="statement not covered" >p</span></span>athname=pathname.replace(/[?#]/g,<span class="fstat-no" title="function not covered" >function(match){<span class="cstat-no" title="statement not covered" ></span>return encodeURIComponent(match)}</span>);<span class="cstat-no" title="statement not covered" >s</span>earch=search.replace("#","%23");<span class="cstat-no" title="statement not covered" >r</span>eturn protocol+host+pathname+search+hash}</span>;<span class="fstat-no" title="function not covered" >function urlResolve(source,relative){<span class="cstat-no" title="statement not covered" ></span>return urlParse(source,false,true).resolve(relative)}</span>Url.prototype.resolve=<span class="fstat-no" title="function not covered" >function(relative){<span class="cstat-no" title="statement not covered" ></span>return this.resolveObject(urlParse(relative,false,true)).format()}</span>;<span class="fstat-no" title="function not covered" >function urlResolveObject(source,relative){<span class="cstat-no" title="statement not covered" ></span>if(!source)<span class="cstat-no" title="statement not covered" >return relative;<span class="cstat-no" title="statement not covered" >r</span></span>eturn urlParse(source,false,true).resolveObject(relative)}</span>Url.prototype.resolveObject=<span class="fstat-no" title="function not covered" >function(relative){<span class="cstat-no" title="statement not covered" ></span>if(util.isString(relative)){<span class="cstat-no" title="statement not covered" >var rel=new Url;<span class="cstat-no" title="statement not covered" >r</span>el.parse(relative,false,true);<span class="cstat-no" title="statement not covered" >r</span>elative=rel}<span class="cstat-no" title="statement not covered" ></span>v</span>ar result=new Url;<span class="cstat-no" title="statement not covered" >v</span>ar tkeys=Object.keys(this);<span class="cstat-no" title="statement not covered" >f</span>or(var tk=0;tk&lt;tkeys.length;tk++){<span class="cstat-no" title="statement not covered" >var tkey=tkeys[tk];<span class="cstat-no" title="statement not covered" >r</span>esult[tkey]=this[tkey]}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.hash=relative.hash;<span class="cstat-no" title="statement not covered" >i</span>f(relative.href===""){<span class="cstat-no" title="statement not covered" >result.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}<span class="cstat-no" title="statement not covered" ></span>i</span>f(relative.slashes&amp;&amp;!relative.protocol){<span class="cstat-no" title="statement not covered" >var rkeys=Object.keys(relative);<span class="cstat-no" title="statement not covered" >f</span>or(var rk=0;rk&lt;rkeys.length;rk++){<span class="cstat-no" title="statement not covered" >var rkey=rkeys[rk];<span class="cstat-no" title="statement not covered" >i</span>f(rkey!=="protocol")<span class="cstat-no" title="statement not covered" >result[rkey]=relative[rkey]}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(slashedProtocol[result.protocol]&amp;&amp;result.hostname&amp;&amp;!result.pathname){<span class="cstat-no" title="statement not covered" >result.path=result.pathname="/"}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}<span class="cstat-no" title="statement not covered" ></span>i</span>f(relative.protocol&amp;&amp;relative.protocol!==result.protocol){<span class="cstat-no" title="statement not covered" >if(!slashedProtocol[relative.protocol]){<span class="cstat-no" title="statement not covered" >var keys=Object.keys(relative);<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;keys.length;v++){<span class="cstat-no" title="statement not covered" >var k=keys[v];<span class="cstat-no" title="statement not covered" >r</span>esult[k]=relative[k]}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.protocol=relative.protocol;<span class="cstat-no" title="statement not covered" >i</span>f(!relative.host&amp;&amp;!hostlessProtocol[relative.protocol]){<span class="cstat-no" title="statement not covered" >var relPath=(relative.pathname||"").split("/");<span class="cstat-no" title="statement not covered" >w</span>hile(relPath.length&amp;&amp;!(relative.host=relPath.shift()));<span class="cstat-no" title="statement not covered" >i</span>f(!relative.host)<span class="cstat-no" title="statement not covered" >relative.host="";<span class="cstat-no" title="statement not covered" >i</span></span>f(!relative.hostname)<span class="cstat-no" title="statement not covered" >relative.hostname="";<span class="cstat-no" title="statement not covered" >i</span></span>f(relPath[0]!=="")<span class="cstat-no" title="statement not covered" >relPath.unshift("");<span class="cstat-no" title="statement not covered" >i</span></span>f(relPath.length&lt;2)<span class="cstat-no" title="statement not covered" >relPath.unshift("");<span class="cstat-no" title="statement not covered" >r</span></span>esult.pathname=relPath.join("/")}</span>else{<span class="cstat-no" title="statement not covered" >result.pathname=relative.pathname}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.search=relative.search;<span class="cstat-no" title="statement not covered" >r</span>esult.query=relative.query;<span class="cstat-no" title="statement not covered" >r</span>esult.host=relative.host||"";<span class="cstat-no" title="statement not covered" >r</span>esult.auth=relative.auth;<span class="cstat-no" title="statement not covered" >r</span>esult.hostname=relative.hostname||relative.host;<span class="cstat-no" title="statement not covered" >r</span>esult.port=relative.port;<span class="cstat-no" title="statement not covered" >i</span>f(result.pathname||result.search){<span class="cstat-no" title="statement not covered" >var p=result.pathname||"";<span class="cstat-no" title="statement not covered" >v</span>ar s=result.search||"";<span class="cstat-no" title="statement not covered" >r</span>esult.path=p+s}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.slashes=result.slashes||relative.slashes;<span class="cstat-no" title="statement not covered" >r</span>esult.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}<span class="cstat-no" title="statement not covered" ></span>v</span>ar isSourceAbs=result.pathname&amp;&amp;result.pathname.charAt(0)==="/",isRelAbs=relative.host||relative.pathname&amp;&amp;relative.pathname.charAt(0)==="/",mustEndAbs=isRelAbs||isSourceAbs||result.host&amp;&amp;relative.pathname,removeAllDots=mustEndAbs,srcPath=result.pathname&amp;&amp;result.pathname.split("/")||[],relPath=relative.pathname&amp;&amp;relative.pathname.split("/")||[],psychotic=result.protocol&amp;&amp;!slashedProtocol[result.protocol];<span class="cstat-no" title="statement not covered" >i</span>f(psychotic){<span class="cstat-no" title="statement not covered" >result.hostname="";<span class="cstat-no" title="statement not covered" >r</span>esult.port=null;<span class="cstat-no" title="statement not covered" >i</span>f(result.host){<span class="cstat-no" title="statement not covered" >if(srcPath[0]==="")<span class="cstat-no" title="statement not covered" >srcPath[0]=result.host;e</span>lse <span class="cstat-no" title="statement not covered" >srcPath.unshift(result.host)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>esult.host="";<span class="cstat-no" title="statement not covered" >i</span>f(relative.protocol){<span class="cstat-no" title="statement not covered" >relative.hostname=null;<span class="cstat-no" title="statement not covered" >r</span>elative.port=null;<span class="cstat-no" title="statement not covered" >i</span>f(relative.host){<span class="cstat-no" title="statement not covered" >if(relPath[0]==="")<span class="cstat-no" title="statement not covered" >relPath[0]=relative.host;e</span>lse <span class="cstat-no" title="statement not covered" >relPath.unshift(relative.host)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>elative.host=null}<span class="cstat-no" title="statement not covered" ></span>m</span>ustEndAbs=mustEndAbs&amp;&amp;(relPath[0]===""||srcPath[0]==="")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isRelAbs){<span class="cstat-no" title="statement not covered" >result.host=relative.host||relative.host===""?relative.host:result.host;<span class="cstat-no" title="statement not covered" >r</span>esult.hostname=relative.hostname||relative.hostname===""?relative.hostname:result.hostname;<span class="cstat-no" title="statement not covered" >r</span>esult.search=relative.search;<span class="cstat-no" title="statement not covered" >r</span>esult.query=relative.query;<span class="cstat-no" title="statement not covered" >s</span>rcPath=relPath}</span>else <span class="cstat-no" title="statement not covered" >if(relPath.length){<span class="cstat-no" title="statement not covered" >if(!srcPath)<span class="cstat-no" title="statement not covered" >srcPath=[];<span class="cstat-no" title="statement not covered" >s</span></span>rcPath.pop();<span class="cstat-no" title="statement not covered" >s</span>rcPath=srcPath.concat(relPath);<span class="cstat-no" title="statement not covered" >r</span>esult.search=relative.search;<span class="cstat-no" title="statement not covered" >r</span>esult.query=relative.query}</span>else <span class="cstat-no" title="statement not covered" >if(!util.isNullOrUndefined(relative.search)){<span class="cstat-no" title="statement not covered" >if(psychotic){<span class="cstat-no" title="statement not covered" >result.hostname=result.host=srcPath.shift();<span class="cstat-no" title="statement not covered" >v</span>ar authInHost=result.host&amp;&amp;result.host.indexOf("@")&gt;0?result.host.split("@"):false;<span class="cstat-no" title="statement not covered" >i</span>f(authInHost){<span class="cstat-no" title="statement not covered" >result.auth=authInHost.shift();<span class="cstat-no" title="statement not covered" >r</span>esult.host=result.hostname=authInHost.shift()}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.search=relative.search;<span class="cstat-no" title="statement not covered" >r</span>esult.query=relative.query;<span class="cstat-no" title="statement not covered" >i</span>f(!util.isNull(result.pathname)||!util.isNull(result.search)){<span class="cstat-no" title="statement not covered" >result.path=(result.pathname?result.pathname:"")+(result.search?result.search:"")}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(!srcPath.length){<span class="cstat-no" title="statement not covered" >result.pathname=null;<span class="cstat-no" title="statement not covered" >i</span>f(result.search){<span class="cstat-no" title="statement not covered" >result.path="/"+result.search}</span>else{<span class="cstat-no" title="statement not covered" >result.path=null}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}<span class="cstat-no" title="statement not covered" ></span>v</span>ar last=srcPath.slice(-1)[0];<span class="cstat-no" title="statement not covered" >v</span>ar hasTrailingSlash=(result.host||relative.host||srcPath.length&gt;1)&amp;&amp;(last==="."||last==="..")||last==="";<span class="cstat-no" title="statement not covered" >v</span>ar up=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=srcPath.length;i&gt;=0;i--){<span class="cstat-no" title="statement not covered" >last=srcPath[i];<span class="cstat-no" title="statement not covered" >i</span>f(last==="."){<span class="cstat-no" title="statement not covered" >srcPath.splice(i,1)}</span>else <span class="cstat-no" title="statement not covered" >if(last===".."){<span class="cstat-no" title="statement not covered" >srcPath.splice(i,1);<span class="cstat-no" title="statement not covered" >u</span>p++}</span>else <span class="cstat-no" title="statement not covered" >if(up){<span class="cstat-no" title="statement not covered" >srcPath.splice(i,1);<span class="cstat-no" title="statement not covered" >u</span>p--}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>i</span>f(!mustEndAbs&amp;&amp;!removeAllDots){<span class="cstat-no" title="statement not covered" >for(;up--;up){<span class="cstat-no" title="statement not covered" >srcPath.unshift("..")}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(mustEndAbs&amp;&amp;srcPath[0]!==""&amp;&amp;(!srcPath[0]||srcPath[0].charAt(0)!=="/")){<span class="cstat-no" title="statement not covered" >srcPath.unshift("")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(hasTrailingSlash&amp;&amp;srcPath.join("/").substr(-1)!=="/"){<span class="cstat-no" title="statement not covered" >srcPath.push("")}<span class="cstat-no" title="statement not covered" ></span>v</span>ar isAbsolute=srcPath[0]===""||srcPath[0]&amp;&amp;srcPath[0].charAt(0)==="/";<span class="cstat-no" title="statement not covered" >i</span>f(psychotic){<span class="cstat-no" title="statement not covered" >result.hostname=result.host=isAbsolute?"":srcPath.length?srcPath.shift():"";<span class="cstat-no" title="statement not covered" >v</span>ar authInHost=result.host&amp;&amp;result.host.indexOf("@")&gt;0?result.host.split("@"):false;<span class="cstat-no" title="statement not covered" >i</span>f(authInHost){<span class="cstat-no" title="statement not covered" >result.auth=authInHost.shift();<span class="cstat-no" title="statement not covered" >r</span>esult.host=result.hostname=authInHost.shift()}</span>}<span class="cstat-no" title="statement not covered" ></span>m</span>ustEndAbs=mustEndAbs||result.host&amp;&amp;srcPath.length;<span class="cstat-no" title="statement not covered" >i</span>f(mustEndAbs&amp;&amp;!isAbsolute){<span class="cstat-no" title="statement not covered" >srcPath.unshift("")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!srcPath.length){<span class="cstat-no" title="statement not covered" >result.pathname=null;<span class="cstat-no" title="statement not covered" >r</span>esult.path=null}</span>else{<span class="cstat-no" title="statement not covered" >result.pathname=srcPath.join("/")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!util.isNull(result.pathname)||!util.isNull(result.search)){<span class="cstat-no" title="statement not covered" >result.path=(result.pathname?result.pathname:"")+(result.search?result.search:"")}<span class="cstat-no" title="statement not covered" ></span>r</span>esult.auth=relative.auth||result.auth;<span class="cstat-no" title="statement not covered" >r</span>esult.slashes=result.slashes||relative.slashes;<span class="cstat-no" title="statement not covered" >r</span>esult.href=result.format();<span class="cstat-no" title="statement not covered" >r</span>eturn result}</span>;Url.prototype.parseHost=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var host=this.host;<span class="cstat-no" title="statement not covered" >v</span>ar port=portPattern.exec(host);<span class="cstat-no" title="statement not covered" >i</span>f(port){<span class="cstat-no" title="statement not covered" >port=port[0];<span class="cstat-no" title="statement not covered" >i</span>f(port!==":"){<span class="cstat-no" title="statement not covered" >this.port=port.substr(1)}<span class="cstat-no" title="statement not covered" ></span>h</span>ost=host.substr(0,host.length-port.length)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(host)<span class="cstat-no" title="statement not covered" >this.hostname=host}</span></span>},{"./util":64,punycode:49,querystring:52}],64:[function(require,module,exports){"use strict";module.exports={isString:<span class="fstat-no" title="function not covered" >function(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="string"}</span>,isObject:<span class="fstat-no" title="function not covered" >function(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="object"&amp;&amp;arg!==null}</span>,isNull:<span class="fstat-no" title="function not covered" >function(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===null}</span>,isNullOrUndefined:<span class="fstat-no" title="function not covered" >function(arg){<span class="cstat-no" title="statement not covered" ></span>return arg==null}</span>}},{}],65:[function(require,module,exports){(function(global){module.exports=deprecate;function deprecate(fn,msg){<span class="missing-if-branch" title="if path not taken" >I</span>if(config("noDeprecation")){<span class="cstat-no" title="statement not covered" >return fn}</span>var warned=false;<span class="fstat-no" title="function not covered" >function deprecated(){<span class="cstat-no" title="statement not covered" ></span>if(!warned){<span class="cstat-no" title="statement not covered" >if(config("throwDeprecation")){<span class="cstat-no" title="statement not covered" >throw new Error(msg)}</span>else <span class="cstat-no" title="statement not covered" >if(config("traceDeprecation")){<span class="cstat-no" title="statement not covered" >console.trace(msg)}</span>else{<span class="cstat-no" title="statement not covered" >console.warn(msg)}<span class="cstat-no" title="statement not covered" ></span>w</span></span>arned=true}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn fn.apply(this,arguments)}</span>return deprecated}function config(name){try{<span class="missing-if-branch" title="else path not taken" >E</span>if(!global.localStorage)return false}catch(_){<span class="cstat-no" title="statement not covered" >return false}<span class="cstat-no" title="statement not covered" ></span>var val=global.localStorage[name];<span class="cstat-no" title="statement not covered" >i</span>f(null==val)<span class="cstat-no" title="statement not covered" >return false;<span class="cstat-no" title="statement not covered" >r</span></span>eturn String(val).toLowerCase()==="true"}</span>}).call(this,typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})</span>},{}],66:[function(require,module,exports){arguments[4][22][0].apply(exports,arguments)},{dup:22}],67:[function(require,module,exports){module.exports=<span class="fstat-no" title="function not covered" >function isBuffer(arg){<span class="cstat-no" title="statement not covered" ></span>return arg&amp;&amp;typeof arg==="object"&amp;&amp;typeof arg.copy==="function"&amp;&amp;typeof arg.fill==="function"&amp;&amp;typeof arg.readUInt8==="function"}</span>},{}],68:[function(require,module,exports){(function(process,global){var formatRegExp=/%[sdj%]/g;exports.format=<span class="fstat-no" title="function not covered" >function(f){<span class="cstat-no" title="statement not covered" ></span>if(!isString(f)){<span class="cstat-no" title="statement not covered" >var objects=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;arguments.length;i++){<span class="cstat-no" title="statement not covered" >objects.push(inspect(arguments[i]))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objects.join(" ")}<span class="cstat-no" title="statement not covered" ></span>v</span>ar i=1;<span class="cstat-no" title="statement not covered" >v</span>ar args=arguments;<span class="cstat-no" title="statement not covered" >v</span>ar len=args.length;<span class="cstat-no" title="statement not covered" >v</span>ar str=String(f).replace(formatRegExp,<span class="fstat-no" title="function not covered" >function(x){<span class="cstat-no" title="statement not covered" ></span>if(x==="%%")<span class="cstat-no" title="statement not covered" >return"%";<span class="cstat-no" title="statement not covered" >i</span></span>f(i&gt;=len)<span class="cstat-no" title="statement not covered" >return x;<span class="cstat-no" title="statement not covered" >s</span></span>witch(x){case"%s":<span class="cstat-no" title="statement not covered" >return String(args[i++]);c</span>ase"%d":<span class="cstat-no" title="statement not covered" >return Number(args[i++]);c</span>ase"%j":<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.stringify(args[i++])}</span>catch(_){<span class="cstat-no" title="statement not covered" >return"[Circular]"}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return x}</span>}</span>);<span class="cstat-no" title="statement not covered" >f</span>or(var x=args[i];i&lt;len;x=args[++i]){<span class="cstat-no" title="statement not covered" >if(isNull(x)||!isObject(x)){<span class="cstat-no" title="statement not covered" >str+=" "+x}</span>else{<span class="cstat-no" title="statement not covered" >str+=" "+inspect(x)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn str}</span>;exports.deprecate=<span class="fstat-no" title="function not covered" >function(fn,msg){<span class="cstat-no" title="statement not covered" ></span>if(isUndefined(global.process)){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return exports.deprecate(fn,msg).apply(this,arguments)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(process.noDeprecation===true){<span class="cstat-no" title="statement not covered" >return fn}<span class="cstat-no" title="statement not covered" ></span>v</span>ar warned=false;<span class="fstat-no" title="function not covered" >f</span>unction deprecated(){<span class="cstat-no" title="statement not covered" ></span>if(!warned){<span class="cstat-no" title="statement not covered" >if(process.throwDeprecation){<span class="cstat-no" title="statement not covered" >throw new Error(msg)}</span>else <span class="cstat-no" title="statement not covered" >if(process.traceDeprecation){<span class="cstat-no" title="statement not covered" >console.trace(msg)}</span>else{<span class="cstat-no" title="statement not covered" >console.error(msg)}<span class="cstat-no" title="statement not covered" ></span>w</span></span>arned=true}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn fn.apply(this,arguments)}<span class="cstat-no" title="statement not covered" ></span>return deprecated}</span>;var debugs={};var debugEnviron;exports.debuglog=<span class="fstat-no" title="function not covered" >function(set){<span class="cstat-no" title="statement not covered" ></span>if(isUndefined(debugEnviron))<span class="cstat-no" title="statement not covered" >debugEnviron=process.env.NODE_DEBUG||"";<span class="cstat-no" title="statement not covered" >s</span></span>et=set.toUpperCase();<span class="cstat-no" title="statement not covered" >i</span>f(!debugs[set]){<span class="cstat-no" title="statement not covered" >if(new RegExp("\\b"+set+"\\b","i").test(debugEnviron)){<span class="cstat-no" title="statement not covered" >var pid=process.pid;<span class="cstat-no" title="statement not covered" >d</span>ebugs[set]=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var msg=exports.format.apply(exports,arguments);<span class="cstat-no" title="statement not covered" >c</span>onsole.error("%s %d: %s",set,pid,msg)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >debugs[set]=<span class="fstat-no" title="function not covered" >function(){</span>}}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn debugs[set]}</span>;<span class="fstat-no" title="function not covered" >function inspect(obj,opts){<span class="cstat-no" title="statement not covered" ></span>var ctx={seen:[],stylize:stylizeNoColor};<span class="cstat-no" title="statement not covered" >i</span>f(arguments.length&gt;=3)<span class="cstat-no" title="statement not covered" >ctx.depth=arguments[2];<span class="cstat-no" title="statement not covered" >i</span></span>f(arguments.length&gt;=4)<span class="cstat-no" title="statement not covered" >ctx.colors=arguments[3];<span class="cstat-no" title="statement not covered" >i</span></span>f(isBoolean(opts)){<span class="cstat-no" title="statement not covered" >ctx.showHidden=opts}</span>else <span class="cstat-no" title="statement not covered" >if(opts){<span class="cstat-no" title="statement not covered" >exports._extend(ctx,opts)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(isUndefined(ctx.showHidden))<span class="cstat-no" title="statement not covered" >ctx.showHidden=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(isUndefined(ctx.depth))<span class="cstat-no" title="statement not covered" >ctx.depth=2;<span class="cstat-no" title="statement not covered" >i</span></span>f(isUndefined(ctx.colors))<span class="cstat-no" title="statement not covered" >ctx.colors=false;<span class="cstat-no" title="statement not covered" >i</span></span>f(isUndefined(ctx.customInspect))<span class="cstat-no" title="statement not covered" >ctx.customInspect=true;<span class="cstat-no" title="statement not covered" >i</span></span>f(ctx.colors)<span class="cstat-no" title="statement not covered" >ctx.stylize=stylizeWithColor;<span class="cstat-no" title="statement not covered" >r</span></span>eturn formatValue(ctx,obj,ctx.depth)}</span>exports.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};<span class="fstat-no" title="function not covered" >function stylizeWithColor(str,styleType){<span class="cstat-no" title="statement not covered" ></span>var style=inspect.styles[styleType];<span class="cstat-no" title="statement not covered" >i</span>f(style){<span class="cstat-no" title="statement not covered" >return"["+inspect.colors[style][0]+"m"+str+"["+inspect.colors[style][1]+"m"}</span>else{<span class="cstat-no" title="statement not covered" >return str}</span>}<span class="fstat-no" title="function not covered" ></span>function stylizeNoColor(str,styleType){<span class="cstat-no" title="statement not covered" ></span>return str}<span class="fstat-no" title="function not covered" ></span>function arrayToHash(array){<span class="cstat-no" title="statement not covered" ></span>var hash={};<span class="cstat-no" title="statement not covered" >a</span>rray.forEach(<span class="fstat-no" title="function not covered" >function(val,idx){<span class="cstat-no" title="statement not covered" ></span>hash[val]=true}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn hash}<span class="fstat-no" title="function not covered" ></span>function formatValue(ctx,value,recurseTimes){<span class="cstat-no" title="statement not covered" ></span>if(ctx.customInspect&amp;&amp;value&amp;&amp;isFunction(value.inspect)&amp;&amp;value.inspect!==exports.inspect&amp;&amp;!(value.constructor&amp;&amp;value.constructor.prototype===value)){<span class="cstat-no" title="statement not covered" >var ret=value.inspect(recurseTimes,ctx);<span class="cstat-no" title="statement not covered" >i</span>f(!isString(ret)){<span class="cstat-no" title="statement not covered" >ret=formatValue(ctx,ret,recurseTimes)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}<span class="cstat-no" title="statement not covered" ></span>v</span>ar primitive=formatPrimitive(ctx,value);<span class="cstat-no" title="statement not covered" >i</span>f(primitive){<span class="cstat-no" title="statement not covered" >return primitive}<span class="cstat-no" title="statement not covered" ></span>v</span>ar keys=Object.keys(value);<span class="cstat-no" title="statement not covered" >v</span>ar visibleKeys=arrayToHash(keys);<span class="cstat-no" title="statement not covered" >i</span>f(ctx.showHidden){<span class="cstat-no" title="statement not covered" >keys=Object.getOwnPropertyNames(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isError(value)&amp;&amp;(keys.indexOf("message")&gt;=0||keys.indexOf("description")&gt;=0)){<span class="cstat-no" title="statement not covered" >return formatError(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(keys.length===0){<span class="cstat-no" title="statement not covered" >if(isFunction(value)){<span class="cstat-no" title="statement not covered" >var name=value.name?": "+value.name:"";<span class="cstat-no" title="statement not covered" >r</span>eturn ctx.stylize("[Function"+name+"]","special")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isRegExp(value)){<span class="cstat-no" title="statement not covered" >return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isDate(value)){<span class="cstat-no" title="statement not covered" >return ctx.stylize(Date.prototype.toString.call(value),"date")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isError(value)){<span class="cstat-no" title="statement not covered" >return formatError(value)}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar base="",array=false,braces=["{","}"];<span class="cstat-no" title="statement not covered" >i</span>f(isArray(value)){<span class="cstat-no" title="statement not covered" >array=true;<span class="cstat-no" title="statement not covered" >b</span>races=["[","]"]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isFunction(value)){<span class="cstat-no" title="statement not covered" >var n=value.name?": "+value.name:"";<span class="cstat-no" title="statement not covered" >b</span>ase=" [Function"+n+"]"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isRegExp(value)){<span class="cstat-no" title="statement not covered" >base=" "+RegExp.prototype.toString.call(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isDate(value)){<span class="cstat-no" title="statement not covered" >base=" "+Date.prototype.toUTCString.call(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isError(value)){<span class="cstat-no" title="statement not covered" >base=" "+formatError(value)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(keys.length===0&amp;&amp;(!array||value.length==0)){<span class="cstat-no" title="statement not covered" >return braces[0]+base+braces[1]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(recurseTimes&lt;0){<span class="cstat-no" title="statement not covered" >if(isRegExp(value)){<span class="cstat-no" title="statement not covered" >return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}</span>else{<span class="cstat-no" title="statement not covered" >return ctx.stylize("[Object]","special")}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>tx.seen.push(value);<span class="cstat-no" title="statement not covered" >v</span>ar output;<span class="cstat-no" title="statement not covered" >i</span>f(array){<span class="cstat-no" title="statement not covered" >output=formatArray(ctx,value,recurseTimes,visibleKeys,keys)}</span>else{<span class="cstat-no" title="statement not covered" >output=keys.map(<span class="fstat-no" title="function not covered" >function(key){<span class="cstat-no" title="statement not covered" ></span>return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)}</span>)}<span class="cstat-no" title="statement not covered" ></span>c</span>tx.seen.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn reduceToSingleString(output,base,braces)}<span class="fstat-no" title="function not covered" ></span>function formatPrimitive(ctx,value){<span class="cstat-no" title="statement not covered" ></span>if(isUndefined(value))<span class="cstat-no" title="statement not covered" >return ctx.stylize("undefined","undefined");<span class="cstat-no" title="statement not covered" >i</span></span>f(isString(value)){<span class="cstat-no" title="statement not covered" >var simple="'"+JSON.stringify(value).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";<span class="cstat-no" title="statement not covered" >r</span>eturn ctx.stylize(simple,"string")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isNumber(value))<span class="cstat-no" title="statement not covered" >return ctx.stylize(""+value,"number");<span class="cstat-no" title="statement not covered" >i</span></span>f(isBoolean(value))<span class="cstat-no" title="statement not covered" >return ctx.stylize(""+value,"boolean");<span class="cstat-no" title="statement not covered" >i</span></span>f(isNull(value))<span class="cstat-no" title="statement not covered" >return ctx.stylize("null","null")}<span class="fstat-no" title="function not covered" ></span></span>function formatError(value){<span class="cstat-no" title="statement not covered" ></span>return"["+Error.prototype.toString.call(value)+"]"}<span class="fstat-no" title="function not covered" ></span>function formatArray(ctx,value,recurseTimes,visibleKeys,keys){<span class="cstat-no" title="statement not covered" ></span>var output=[];<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,l=value.length;i&lt;l;++i){<span class="cstat-no" title="statement not covered" >if(hasOwnProperty(value,String(i))){<span class="cstat-no" title="statement not covered" >output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,String(i),true))}</span>else{<span class="cstat-no" title="statement not covered" >output.push("")}</span>}<span class="cstat-no" title="statement not covered" ></span>k</span>eys.forEach(<span class="fstat-no" title="function not covered" >function(key){<span class="cstat-no" title="statement not covered" ></span>if(!key.match(/^\d+$/)){<span class="cstat-no" title="statement not covered" >output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,true))}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn output}<span class="fstat-no" title="function not covered" ></span>function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){<span class="cstat-no" title="statement not covered" ></span>var name,str,desc;<span class="cstat-no" title="statement not covered" >d</span>esc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]};<span class="cstat-no" title="statement not covered" >i</span>f(desc.get){<span class="cstat-no" title="statement not covered" >if(desc.set){<span class="cstat-no" title="statement not covered" >str=ctx.stylize("[Getter/Setter]","special")}</span>else{<span class="cstat-no" title="statement not covered" >str=ctx.stylize("[Getter]","special")}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(desc.set){<span class="cstat-no" title="statement not covered" >str=ctx.stylize("[Setter]","special")}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!hasOwnProperty(visibleKeys,key)){<span class="cstat-no" title="statement not covered" >name="["+key+"]"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!str){<span class="cstat-no" title="statement not covered" >if(ctx.seen.indexOf(desc.value)&lt;0){<span class="cstat-no" title="statement not covered" >if(isNull(recurseTimes)){<span class="cstat-no" title="statement not covered" >str=formatValue(ctx,desc.value,null)}</span>else{<span class="cstat-no" title="statement not covered" >str=formatValue(ctx,desc.value,recurseTimes-1)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(str.indexOf("\n")&gt;-1){<span class="cstat-no" title="statement not covered" >if(array){<span class="cstat-no" title="statement not covered" >str=str.split("\n").map(<span class="fstat-no" title="function not covered" >function(line){<span class="cstat-no" title="statement not covered" ></span>return"  "+line}</span>).join("\n").substr(2)}</span>else{<span class="cstat-no" title="statement not covered" >str="\n"+str.split("\n").map(<span class="fstat-no" title="function not covered" >function(line){<span class="cstat-no" title="statement not covered" ></span>return"   "+line}</span>).join("\n")}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >str=ctx.stylize("[Circular]","special")}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isUndefined(name)){<span class="cstat-no" title="statement not covered" >if(array&amp;&amp;key.match(/^\d+$/)){<span class="cstat-no" title="statement not covered" >return str}<span class="cstat-no" title="statement not covered" ></span>n</span>ame=JSON.stringify(""+key);<span class="cstat-no" title="statement not covered" >i</span>f(name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)){<span class="cstat-no" title="statement not covered" >name=name.substr(1,name.length-2);<span class="cstat-no" title="statement not covered" >n</span>ame=ctx.stylize(name,"name")}</span>else{<span class="cstat-no" title="statement not covered" >name=name.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'");<span class="cstat-no" title="statement not covered" >n</span>ame=ctx.stylize(name,"string")}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn name+": "+str}<span class="fstat-no" title="function not covered" ></span>function reduceToSingleString(output,base,braces){<span class="cstat-no" title="statement not covered" ></span>var numLinesEst=0;<span class="cstat-no" title="statement not covered" >v</span>ar length=output.reduce(<span class="fstat-no" title="function not covered" >function(prev,cur){<span class="cstat-no" title="statement not covered" ></span>numLinesEst++;<span class="cstat-no" title="statement not covered" >i</span>f(cur.indexOf("\n")&gt;=0)<span class="cstat-no" title="statement not covered" >numLinesEst++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn prev+cur.replace(/\u001b\[\d\d?m/g,"").length+1}</span>,0);<span class="cstat-no" title="statement not covered" >i</span>f(length&gt;60){<span class="cstat-no" title="statement not covered" >return braces[0]+(base===""?"":base+"\n ")+" "+output.join(",\n  ")+" "+braces[1]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn braces[0]+base+" "+output.join(", ")+" "+braces[1]}<span class="fstat-no" title="function not covered" ></span>function isArray(ar){</span>
<span class="cstat-no" title="statement not covered" >return Array.isArray(ar)}</span>exports.isArray=isArray;<span class="fstat-no" title="function not covered" >function isBoolean(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="boolean"}</span>exports.isBoolean=isBoolean;<span class="fstat-no" title="function not covered" >function isNull(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===null}</span>exports.isNull=isNull;<span class="fstat-no" title="function not covered" >function isNullOrUndefined(arg){<span class="cstat-no" title="statement not covered" ></span>return arg==null}</span>exports.isNullOrUndefined=isNullOrUndefined;<span class="fstat-no" title="function not covered" >function isNumber(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="number"}</span>exports.isNumber=isNumber;<span class="fstat-no" title="function not covered" >function isString(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="string"}</span>exports.isString=isString;<span class="fstat-no" title="function not covered" >function isSymbol(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="symbol"}</span>exports.isSymbol=isSymbol;<span class="fstat-no" title="function not covered" >function isUndefined(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===void 0}</span>exports.isUndefined=isUndefined;<span class="fstat-no" title="function not covered" >function isRegExp(re){<span class="cstat-no" title="statement not covered" ></span>return isObject(re)&amp;&amp;objectToString(re)==="[object RegExp]"}</span>exports.isRegExp=isRegExp;<span class="fstat-no" title="function not covered" >function isObject(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="object"&amp;&amp;arg!==null}</span>exports.isObject=isObject;<span class="fstat-no" title="function not covered" >function isDate(d){<span class="cstat-no" title="statement not covered" ></span>return isObject(d)&amp;&amp;objectToString(d)==="[object Date]"}</span>exports.isDate=isDate;<span class="fstat-no" title="function not covered" >function isError(e){<span class="cstat-no" title="statement not covered" ></span>return isObject(e)&amp;&amp;(objectToString(e)==="[object Error]"||e instanceof Error)}</span>exports.isError=isError;<span class="fstat-no" title="function not covered" >function isFunction(arg){<span class="cstat-no" title="statement not covered" ></span>return typeof arg==="function"}</span>exports.isFunction=isFunction;<span class="fstat-no" title="function not covered" >function isPrimitive(arg){<span class="cstat-no" title="statement not covered" ></span>return arg===null||typeof arg==="boolean"||typeof arg==="number"||typeof arg==="string"||typeof arg==="symbol"||typeof arg==="undefined"}</span>exports.isPrimitive=isPrimitive;exports.isBuffer=require("./support/isBuffer");<span class="fstat-no" title="function not covered" >function objectToString(o){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.toString.call(o)}<span class="fstat-no" title="function not covered" ></span>function pad(n){<span class="cstat-no" title="statement not covered" ></span>return n&lt;10?"0"+n.toString(10):n.toString(10)}</span>var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];<span class="fstat-no" title="function not covered" >function timestamp(){<span class="cstat-no" title="statement not covered" ></span>var d=new Date;<span class="cstat-no" title="statement not covered" >v</span>ar time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(":");<span class="cstat-no" title="statement not covered" >r</span>eturn[d.getDate(),months[d.getMonth()],time].join(" ")}</span>exports.log=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))}</span>;exports.inherits=require("inherits");exports._extend=<span class="fstat-no" title="function not covered" >function(origin,add){<span class="cstat-no" title="statement not covered" ></span>if(!add||!isObject(add))<span class="cstat-no" title="statement not covered" >return origin;<span class="cstat-no" title="statement not covered" >v</span></span>ar keys=Object.keys(add);<span class="cstat-no" title="statement not covered" >v</span>ar i=keys.length;<span class="cstat-no" title="statement not covered" >w</span>hile(i--){<span class="cstat-no" title="statement not covered" >origin[keys[i]]=add[keys[i]]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn origin}</span>;<span class="fstat-no" title="function not covered" >function hasOwnProperty(obj,prop){<span class="cstat-no" title="statement not covered" ></span>return Object.prototype.hasOwnProperty.call(obj,prop)}</span>}).call(this,require("_process"),typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})</span>},{"./support/isBuffer":67,_process:48,inherits:66}],69:[function(require,module,exports){(function(process,global,Buffer){"use strict";var through=require("through2");var duplexify=require("duplexify");var WS=require("ws");<span class="cstat-no" title="statement not covered" >module.exports=WebSocketStream;<span class="fstat-no" title="function not covered" >f</span>unction WebSocketStream(target,protocols,options){<span class="cstat-no" title="statement not covered" ></span>var stream,socket;<span class="cstat-no" title="statement not covered" >v</span>ar isBrowser=process.title==="browser";<span class="cstat-no" title="statement not covered" >v</span>ar isNative=!!global.WebSocket;<span class="cstat-no" title="statement not covered" >v</span>ar socketWrite=isBrowser?socketWriteBrowser:socketWriteNode;<span class="cstat-no" title="statement not covered" >v</span>ar proxy=through.obj(socketWrite,socketEnd);<span class="cstat-no" title="statement not covered" >i</span>f(protocols&amp;&amp;!Array.isArray(protocols)&amp;&amp;"object"===typeof protocols){<span class="cstat-no" title="statement not covered" >options=protocols;<span class="cstat-no" title="statement not covered" >p</span>rotocols=null;<span class="cstat-no" title="statement not covered" >i</span>f(typeof options.protocol==="string"||Array.isArray(options.protocol)){<span class="cstat-no" title="statement not covered" >protocols=options.protocol}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!options)<span class="cstat-no" title="statement not covered" >options={};<span class="cstat-no" title="statement not covered" >v</span></span>ar bufferSize=options.browserBufferSize||1024*512;<span class="cstat-no" title="statement not covered" >v</span>ar bufferTimeout=options.browserBufferTimeout||1e3;<span class="cstat-no" title="statement not covered" >i</span>f(typeof target==="object"){<span class="cstat-no" title="statement not covered" >socket=target}</span>else{<span class="cstat-no" title="statement not covered" >if(isNative&amp;&amp;isBrowser){<span class="cstat-no" title="statement not covered" >socket=new WS(target,protocols)}</span>else{<span class="cstat-no" title="statement not covered" >socket=new WS(target,protocols,options)}<span class="cstat-no" title="statement not covered" ></span>s</span>ocket.binaryType="arraybuffer"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(socket.readyState===WS.OPEN){<span class="cstat-no" title="statement not covered" >stream=proxy}</span>else{<span class="cstat-no" title="statement not covered" >stream=duplexify.obj();<span class="cstat-no" title="statement not covered" >s</span>ocket.onopen=onopen}<span class="cstat-no" title="statement not covered" ></span>s</span>tream.socket=socket;<span class="cstat-no" title="statement not covered" >s</span>ocket.onclose=onclose;<span class="cstat-no" title="statement not covered" >s</span>ocket.onerror=onerror;<span class="cstat-no" title="statement not covered" >s</span>ocket.onmessage=onmessage;<span class="cstat-no" title="statement not covered" >p</span>roxy.on("close",destroy);<span class="cstat-no" title="statement not covered" >v</span>ar coerceToBuffer=options.binary||options.binary===undefined;<span class="fstat-no" title="function not covered" >f</span>unction socketWriteNode(chunk,enc,next){<span class="cstat-no" title="statement not covered" ></span>if(coerceToBuffer&amp;&amp;typeof chunk==="string"){<span class="cstat-no" title="statement not covered" >chunk=new Buffer(chunk,"utf8")}<span class="cstat-no" title="statement not covered" ></span>s</span>ocket.send(chunk,next)}<span class="fstat-no" title="function not covered" ></span>function socketWriteBrowser(chunk,enc,next){<span class="cstat-no" title="statement not covered" ></span>if(socket.bufferedAmount&gt;bufferSize){<span class="cstat-no" title="statement not covered" >setTimeout(socketWriteBrowser,bufferTimeout,chunk,enc,next);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(coerceToBuffer&amp;&amp;typeof chunk==="string"){<span class="cstat-no" title="statement not covered" >chunk=new Buffer(chunk,"utf8")}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{<span class="cstat-no" title="statement not covered" >socket.send(chunk)}</span>catch(err){<span class="cstat-no" title="statement not covered" >return next(err)}<span class="cstat-no" title="statement not covered" ></span>n</span>ext()}<span class="fstat-no" title="function not covered" ></span>function socketEnd(done){<span class="cstat-no" title="statement not covered" ></span>socket.close();<span class="cstat-no" title="statement not covered" >d</span>one()}<span class="fstat-no" title="function not covered" ></span>function onopen(){<span class="cstat-no" title="statement not covered" ></span>stream.setReadable(proxy);<span class="cstat-no" title="statement not covered" >s</span>tream.setWritable(proxy);<span class="cstat-no" title="statement not covered" >s</span>tream.emit("connect")}<span class="fstat-no" title="function not covered" ></span>function onclose(){<span class="cstat-no" title="statement not covered" ></span>stream.end();<span class="cstat-no" title="statement not covered" >s</span>tream.destroy()}<span class="fstat-no" title="function not covered" ></span>function onerror(err){<span class="cstat-no" title="statement not covered" ></span>stream.destroy(err)}<span class="fstat-no" title="function not covered" ></span>function onmessage(event){<span class="cstat-no" title="statement not covered" ></span>var data=event.data;<span class="cstat-no" title="statement not covered" >i</span>f(data instanceof ArrayBuffer)<span class="cstat-no" title="statement not covered" >data=new Buffer(new Uint8Array(data));e</span>lse <span class="cstat-no" title="statement not covered" >data=new Buffer(data);<span class="cstat-no" title="statement not covered" >p</span></span>roxy.push(data)}<span class="fstat-no" title="function not covered" ></span>function destroy(){<span class="cstat-no" title="statement not covered" ></span>socket.close()}<span class="cstat-no" title="statement not covered" ></span>return stream}</span>}).call(this,require("_process"),typeof global!=="undefined"?global:<span class="branch-1 cbranch-no" title="branch not covered" >typeof self!=="undefined"?self:typeof window!=="undefined"?window:{},</span>require("buffer").Buffer)},{_process:48,buffer:4,duplexify:7,through2:62,ws:70}],70:[function(require,module,exports){var ws=null;<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof WebSocket!=="undefined"){<span class="cstat-no" title="statement not covered" >ws=WebSocket}</span>else <span class="missing-if-branch" title="if path not taken" >I</span>if(typeof MozWebSocket!=="undefined"){<span class="cstat-no" title="statement not covered" >ws=MozWebSocket}</span>else{ws=window.WebSocket||<span class="branch-1 cbranch-no" title="branch not covered" >window.MozWebSocket}<span class="cstat-no" title="statement not covered" ></span>module.exports=ws}</span>,{}],71:[function(require,module,exports){module.exports=wrappy;function wrappy(fn,cb){<span class="missing-if-branch" title="if path not taken" >I</span>if(fn&amp;&amp;cb)<span class="cstat-no" title="statement not covered" >return wrappy(fn)(cb);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof fn!=="function")<span class="cstat-no" title="statement not covered" >throw new TypeError("need wrapper function");O</span>bject.keys(fn).forEach(<span class="fstat-no" title="function not covered" >function(k){<span class="cstat-no" title="statement not covered" ></span>wrapper[k]=fn[k]}</span>);return wrapper;<span class="fstat-no" title="function not covered" >function wrapper(){<span class="cstat-no" title="statement not covered" ></span>var args=new Array(arguments.length);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;args.length;i++){<span class="cstat-no" title="statement not covered" >args[i]=arguments[i]}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ret=fn.apply(this,args);<span class="cstat-no" title="statement not covered" >v</span>ar cb=args[args.length-1];<span class="cstat-no" title="statement not covered" >i</span>f(typeof ret==="function"&amp;&amp;ret!==cb){<span class="cstat-no" title="statement not covered" >Object.keys(cb).forEach(<span class="fstat-no" title="function not covered" >function(k){<span class="cstat-no" title="statement not covered" ></span>ret[k]=cb[k]}</span>)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret}</span>}},{}],72:[function(require,module,exports){module.exports=extend;var hasOwnProperty=Object.prototype.hasOwnProperty;<span class="fstat-no" title="function not covered" >function extend(){<span class="cstat-no" title="statement not covered" ></span>var target={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;arguments.length;i++){<span class="cstat-no" title="statement not covered" >var source=arguments[i];<span class="cstat-no" title="statement not covered" >f</span>or(var key in source){<span class="cstat-no" title="statement not covered" >if(hasOwnProperty.call(source,key)){<span class="cstat-no" title="statement not covered" >target[key]=source[key]}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn target}</span>},{}],mqtt:[function(require,module,exports){(function(process){"use strict";var MqttClient=require("../client");var url=require("url");var xtend=require("xtend");var protocols={};<span class="missing-if-branch" title="if path not taken" >I</span>if(process.title!=="browser"){<span class="cstat-no" title="statement not covered" >protocols.mqtt=require("./tcp");<span class="cstat-no" title="statement not covered" >p</span>rotocols.tcp=require("./tcp");<span class="cstat-no" title="statement not covered" >p</span>rotocols.ssl=require("./tls");<span class="cstat-no" title="statement not covered" >p</span>rotocols.tls=require("./tls");<span class="cstat-no" title="statement not covered" >p</span>rotocols.mqtts=require("./tls")}</span>protocols.ws=require("./ws");<span class="cstat-no" title="statement not covered" >protocols.wss=require("./ws");<span class="fstat-no" title="function not covered" >f</span>unction parseAuthOptions(opts){<span class="cstat-no" title="statement not covered" ></span>var matches;<span class="cstat-no" title="statement not covered" >i</span>f(opts.auth){<span class="cstat-no" title="statement not covered" >matches=opts.auth.match(/^(.+):(.+)$/);<span class="cstat-no" title="statement not covered" >i</span>f(matches){<span class="cstat-no" title="statement not covered" >opts.username=matches[1];<span class="cstat-no" title="statement not covered" >o</span>pts.password=matches[2]}</span>else{<span class="cstat-no" title="statement not covered" >opts.username=opts.auth}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function connect(brokerUrl,opts){<span class="cstat-no" title="statement not covered" ></span>if(typeof brokerUrl==="object"&amp;&amp;!opts){<span class="cstat-no" title="statement not covered" >opts=brokerUrl;<span class="cstat-no" title="statement not covered" >b</span>rokerUrl=null}<span class="cstat-no" title="statement not covered" ></span>o</span>pts=opts||{};<span class="cstat-no" title="statement not covered" >i</span>f(brokerUrl){<span class="cstat-no" title="statement not covered" >opts=xtend(url.parse(brokerUrl,true),opts);<span class="cstat-no" title="statement not covered" >i</span>f(opts.protocol===null){<span class="cstat-no" title="statement not covered" >throw new Error("Missing protocol")}<span class="cstat-no" title="statement not covered" ></span>o</span>pts.protocol=opts.protocol.replace(/:$/,"")}<span class="cstat-no" title="statement not covered" ></span>p</span>arseAuthOptions(opts);<span class="cstat-no" title="statement not covered" >i</span>f(opts.query&amp;&amp;typeof opts.query.clientId==="string"){<span class="cstat-no" title="statement not covered" >opts.clientId=opts.query.clientId}<span class="cstat-no" title="statement not covered" ></span>i</span>f(opts.cert&amp;&amp;opts.key){<span class="cstat-no" title="statement not covered" >if(opts.protocol){<span class="cstat-no" title="statement not covered" >if(["mqtts","wss"].indexOf(opts.protocol)===-1){<span class="cstat-no" title="statement not covered" >switch(opts.protocol){case"mqtt":<span class="cstat-no" title="statement not covered" >opts.protocol="mqtts";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ws":<span class="cstat-no" title="statement not covered" >opts.protocol="wss";<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('Unknown protocol for secure connection: "'+opts.protocol+'"!');<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >throw new Error("Missing secure protocol key")}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!protocols[opts.protocol]){<span class="cstat-no" title="statement not covered" >const isSecure=["mqtts","wss"].indexOf(opts.protocol)!==-1;<span class="cstat-no" title="statement not covered" >o</span>pts.protocol=["mqtt","mqtts","ws","wss"].filter(<span class="fstat-no" title="function not covered" >function(key,index){<span class="cstat-no" title="statement not covered" ></span>if(isSecure&amp;&amp;index%2===0){<span class="cstat-no" title="statement not covered" >return false}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn typeof protocols[key]==="function"}</span>)[0]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(opts.clean===false&amp;&amp;!opts.clientId){<span class="cstat-no" title="statement not covered" >throw new Error("Missing clientId for unclean clients")}<span class="fstat-no" title="function not covered" ></span>f</span>unction wrapper(client){<span class="cstat-no" title="statement not covered" ></span>if(opts.servers){<span class="cstat-no" title="statement not covered" >if(!client._reconnectCount||client._reconnectCount===opts.servers.length){<span class="cstat-no" title="statement not covered" >client._reconnectCount=0}<span class="cstat-no" title="statement not covered" ></span>o</span>pts.host=opts.servers[client._reconnectCount].host;<span class="cstat-no" title="statement not covered" >o</span>pts.port=opts.servers[client._reconnectCount].port;<span class="cstat-no" title="statement not covered" >o</span>pts.hostname=opts.host;<span class="cstat-no" title="statement not covered" >c</span>lient._reconnectCount++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn protocols[opts.protocol](client,opts)}<span class="cstat-no" title="statement not covered" ></span>return new MqttClient(wrapper,opts)}<span class="cstat-no" title="statement not covered" ></span>module.exports=connect;<span class="cstat-no" title="statement not covered" >m</span>odule.exports.connect=connect;<span class="cstat-no" title="statement not covered" >m</span>odule.exports.MqttClient=MqttClient}</span>).call(this,require("_process"))},{"../client":24,"./tcp":25,"./tls":26,"./ws":27,_process:48,url:63,xtend:72}]},{},[])("mqtt")});
&nbsp;
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Wed Apr 19 2017 09:45:28 GMT+0000 (UTC)</div>
</div>
</body>
</html>
