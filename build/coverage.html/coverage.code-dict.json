{"/home/travis/build/npmtest/node-npmtest-mosca/test.js":"/* istanbul instrument in package npmtest_mosca */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mosca/lib.npmtest_mosca.js":"/* istanbul instrument in package npmtest_mosca */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mosca = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mosca = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mosca/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mosca && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mosca */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mosca\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mosca.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_mosca.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mosca.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_mosca.__dirname +\n                    '/lib.npmtest_mosca.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/index.js":"\nmodule.exports.Server = require(\"./lib/server\");\nmodule.exports.Authorizer = require(\"./lib/authorizer\");\nmodule.exports.persistence = require(\"./lib/persistence\");\nmodule.exports.Stats = require(\"./lib/stats\");\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/server.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar Connection = require(\"mqtt-connection\");\nvar ws = require(\"websocket-stream\");\nvar steed = require(\"steed\")();\nvar ascoltatori = require(\"ascoltatori\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar pino = require(\"pino\");\nvar extend = require(\"extend\");\nvar Client = require(\"./client\");\nvar Stats = require(\"./stats\");\nvar shortid = require(\"shortid\");\nvar persistence = require('./persistence');\nvar options = require('./options');\nvar interfaces = require('./interfaces');\n\nvar defaults = options.defaultsLegacy();\nvar nop = function() {};\n\n/**\n * The Mosca Server is a very simple MQTT server that\n * provides a simple event-based API to craft your own MQTT logic\n * It supports QoS 0 & 1, without external storage.\n * It is backed by Ascoltatori, and it descends from\n * EventEmitter.\n *\n * Options:\n *  - `host`, the IP address of the server (see http://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback).\n *  - `interfaces`, list of network interfaces with necessary options.\n *  - `backend`, all the options for creating the Ascoltatore\n *    that will power this server.\n *  - `ascoltatore`, the ascoltatore to use (instead of `backend`).\n *  - `maxInflightMessages`, the maximum number of inflight messages per client.\n *  - `logger`, the options for Pino.\n *  - `persistence`, the options for the persistence.\n *     A sub-key `factory` is used to specify what persistence\n *     to use.\n *  - `credentials`, credentials for secure connection, includes two properties:\n *     - `keyPath`, the path to the key\n *     - `certPath`, the path to the certificate\n *     - `*`, additional properties are passed as options to `tls.createServer` (see https://nodejs.org/api/tls.html#tls_tls_createserver_options_secureconnectionlistener)\n *  - `stats`, publish the stats every 10s (default false).\n *  - `publishNewClient`, publish message to topic \"$SYS/{broker-id}/new/clients\" when new client connects.\n *  - `publishClientDisconnect`, publish message to topic \"$SYS/{broker-id}/disconnect/clients\" when a client disconnects.\n *  - `publishSubscriptions`, publish message to topic \"$SYS/{broker-id}/new/(un)subscribes\" when a client subscribes/unsubscribes.\n *\n * Interface may contain following properties:\n *  - `type`, name of a build-in type or a custom type factory\n *  - `port`, target port, overrides default port infered from `type`\n *  - `host`, target host, overrides\n *\n * Built-in interface types:\n *  - `mqtt`, normal mqtt, port: 1883\n *  - `mqtts`, mqtt over ssl, port: 8883, requires `credentials`\n *  - `http`, mqtt over websocket, port: 3000\n *  - `https`, mqtt over secure websocket, port: 3001, requires `credentials`\n *\n * Events:\n *  - `clientConnected`, when a client is connected;\n *    the client is passed as a parameter.\n *  - `clientDisconnecting`, when a client is being disconnected;\n *    the client is passed as a parameter.\n *  - `clientDisconnected`, when a client is disconnected;\n *    the client is passed as a parameter.\n *  - `published`, when a new message is published;\n *    the packet and the client are passed as parameters.\n *  - `subscribed`, when a client is subscribed to a topic;\n *    the topic and the client are passed as parameters.\n *  - `unsubscribed`, when a client is unsubscribed to a topic;\n *    the topic and the client are passed as parameters.\n *\n * @param {Object} opts The option object\n * @param {Function} callback The ready callback\n * @api public\n */\nfunction Server(opts, callback) {\n  var modernOpts = options.modernize(opts);\n  var validationResult = options.validate(modernOpts);\n\n  if (validationResult.errors.length > 0) {\n    var errMessage = validationResult.errors[0].message;\n    if (callback) {\n      callback(new Error(errMessage));\n    } else {\n      throw new Error(errMessage);\n    }\n  }\n\n  modernOpts = options.populate(modernOpts);\n\n  if (!(this instanceof Server)) {\n    return new Server(opts, callback);\n  }\n\n  EventEmitter.call(this);\n\n  if (true) { // REFACTOR: kludge for tests that rely on options structure\n    this.opts = extend(true, {}, defaults, opts);\n    this.modernOpts = modernOpts;\n\n    if (this.opts.secure) {\n      this.opts.secure.port = this.opts.secure.port || 8883;\n    }\n    if (this.opts.http) {\n      this.opts.http.port = this.opts.http.port || 3000;\n    }\n    if (this.opts.https) {\n      this.opts.https.port = this.opts.https.port || 3001;\n    }\n  } else { // REFACTOR: enable this once test are updated\n    this.opts = modernOpts;\n  }\n\n  callback = callback || function() {};\n\n  this._dedupId = 0;\n  this.clients = {};\n  this.closed = false;\n\n  if (this.modernOpts.logger.childOf) {\n    this.logger = this.modernOpts.logger.childOf;\n    delete this.modernOpts.logger.childOf;\n    delete this.modernOpts.logger.name;\n    this.logger = this.logger.child(this.modernOpts.logger);\n  } else {\n    this.logger = pino(this.modernOpts.logger);\n  }\n\n  if(this.modernOpts.stats) {\n    new Stats().wire(this);\n  }\n\n  var that = this;\n\n  // each Server has a dummy id for logging purposes\n  this.id = this.modernOpts.id || shortid.generate();\n\n  // initialize servers list\n  this.servers = [];\n\n\n  steed.series([\n\n    // steed.series: wait for ascoltatore\n    function (done) {\n\n      if(that.modernOpts.ascoltatore) {\n        that.ascoltatore = that.modernOpts.ascoltatore;\n        done();\n      }\n      else {\n        that.ascoltatore = ascoltatori.build(that.modernOpts.backend, done);\n        that.ascoltatore.on('error', that.emit.bind(that, 'error'));\n      }\n    },\n\n    // steed.series: wait for persistence\n\n    function (done) {\n      // REFACTOR: partially move to options.validate and options.populate?\n      var persistenceFactory = that.modernOpts.persistence && that.modernOpts.persistence.factory;\n      if (persistenceFactory) {\n        if (typeof persistenceFactory === 'string') {\n          var factoryName = persistenceFactory;\n          persistenceFactory = persistence.getFactory(factoryName);\n          if (!persistenceFactory) {\n            return callback(new Error('No persistence factory found for ' + factoryName ));\n          }\n        }\n\n        that.persistence = persistenceFactory(that.modernOpts.persistence, done);\n        that.persistence.wire(that);\n      } else {\n        that.persistence = null;\n        done();\n      }\n    },\n\n    // steed.series: iterate over defined interfaces, build servers and listen\n    function (done) {\n\n      steed.eachSeries(that.modernOpts.interfaces, function (iface, dn) {\n        var fallback = that.modernOpts;\n        var host = iface.host || that.modernOpts.host;\n        var port = iface.port || that.modernOpts.port;\n\n        var server = interfaces.serverFactory(iface, fallback, that);\n        that.servers.push(server);\n        server.maxConnections = iface.maxConnections || 10000000;\n        server.listen(port, host, dn);\n      }, done);\n    },\n\n    // steed.series: log startup information\n    function (done) {\n      var logInfo = {};\n\n      that.modernOpts.interfaces.forEach(function (iface) {\n        var name = iface.type;\n        if (typeof name !== \"string\") {\n          name = iface.type.name;\n        }\n        logInfo[name] = iface.port;\n      });\n\n      that.logger.info(logInfo, \"server started\");\n      that.emit(\"ready\");\n      done(null);\n    }\n  ], function(err, results){\n    if(err) {\n      callback(err);\n    }\n  });\n\n  that.on(\"clientConnected\", function(client) {\n    if(that.modernOpts.publishNewClient) {\n      that.publish({\n        topic: \"$SYS/\" + that.id + \"/new/clients\",\n        payload: client.id\n      });\n    }\n\n    this.clients[client.id] = client;\n  });\n\n  that.once(\"ready\", function() {\n    callback(null, that);\n  });\n\n  that.on('ready', function() {\n    that.ascoltatore.subscribe(\n      \"$SYS/+/new/clients\",\n      function(topic, payload) {\n        var serverId, clientId;\n\n        serverId = topic.split('/')[1];\n        clientId = payload;\n\n        if(that.clients[clientId] && serverId !== that.id) {\n          that.clients[clientId].close(null, \"new connection request\");\n        }\n      }\n    );\n  });\n\n  if(that.modernOpts.publishSubscriptions) {\n    that.on(\"subscribed\", function(topic, client) {\n      that.publish({\n        topic: \"$SYS/\" + that.id + \"/new/subscribes\",\n        payload: JSON.stringify({\n          clientId: client.id,\n          topic: topic\n        })\n      });\n    });\n\n    that.on(\"unsubscribed\", function(topic, client) {\n      that.publish({\n        topic: \"$SYS/\" + that.id + \"/new/unsubscribes\",\n        payload: JSON.stringify({\n          clientId: client.id,\n          topic: topic\n        })\n      });\n    });\n  }\n\n  that.on(\"clientDisconnected\", function(client) {\n    if(that.modernOpts.publishClientDisconnect) {\n      that.publish({\n        topic: \"$SYS/\" + that.id + \"/disconnect/clients\",\n        payload: client.id\n      });\n    }\n    delete this.clients[client.id];\n  });\n}\n\nmodule.exports = Server;\n\nServer.prototype = Object.create(EventEmitter.prototype);\n\nServer.prototype.toString = function() {\n  return 'mosca.Server';\n};\n\n/**\n * Subscribes to a topic on the MQTT broker.\n *\n * @api public\n * @param {String} topic The MQTT topic\n * @param {Function} callback The callback with (topic, payload) arguments\n * @param {Function} done The subscription result\n */\nServer.prototype.subscribe = function subscribe(topic, callback, done) {\n  this.ascoltatore.subscribe(topic, callback, done);\n};\n\n/**\n * Publishes a packet on the MQTT broker.\n *\n * @api public\n * @param {Object} packet The MQTT packet, it should include the\n *                        topic, payload, qos, and retain keys.\n * @param {Object} client The client object (internal)\n * @param {Function} callback The callback\n */\nServer.prototype.publish = function publish(packet, client, callback) {\n\n  var that = this;\n  var logger = this.logger;\n\n  if (typeof client === 'function') {\n    callback = client;\n    client = null;\n  } else if (client) {\n    logger = client.logger;\n  }\n\n  if (!callback) {\n    callback = nop;\n  }\n\n  var newPacket = {\n    topic: packet.topic,\n    payload: packet.payload,\n    messageId: this.generateUniqueId(),\n    qos: packet.qos,\n    retain: packet.retain\n  };\n\n  var opts = {\n    qos: packet.qos,\n    messageId: newPacket.messageId\n  };\n\n  if (client) {\n    opts.clientId = client.id;\n  }\n\n  that.storePacket(newPacket, function() {\n    if (that.closed) {\n      logger.debug({ packet: newPacket }, \"not delivering because we are closed\");\n      return;\n    }\n\n    that.ascoltatore.publish(\n      newPacket.topic,\n      newPacket.payload,\n      opts,\n      function() {\n        that.published(newPacket, client, function() {\n          if( newPacket.topic.indexOf( '$SYS' ) >= 0 ) {\n            logger.trace({ packet: newPacket }, \"published packet\");\n          } else {\n            logger.debug({ packet: newPacket }, \"published packet\");\n          }\n          that.emit(\"published\", newPacket, client);\n          callback(undefined, newPacket);\n        });\n      }\n    );\n  });\n};\n\n/**\n * The function that will be used to authenticate users.\n * This default implementation authenticate everybody.\n * Override at will.\n *\n * @api public\n * @param {Object} client The MQTTConnection that is a client\n * @param {String} username The username\n * @param {String} password The password\n * @param {Function} callback The callback to return the verdict\n */\nServer.prototype.authenticate = function(client, username, password, callback) {\n  callback(null, true);\n};\n\n/**\n * The function that is called after receiving a publish message but before\n * answering with puback for QoS 1 packet.\n * This default implementation does nothing\n * Override at will\n *\n * @api public\n * @param {Object} packet The MQTT packet\n * @param {Object} client The MQTTConnection that is a client\n * @param {Function} callback The callback to send the puback\n */\nServer.prototype.published = function(packet, client, callback) {\n  callback(null);\n};\n\n/**\n * The function that will be used to authorize clients to publish to topics.\n * This default implementation authorize everybody.\n * Override at will\n *\n * @api public\n * @param {Object} client The MQTTConnection that is a client\n * @param {String} topic The topic\n * @param {String} paylod The paylod\n * @param {Function} callback The callback to return the verdict\n */\nServer.prototype.authorizePublish = function(client, topic, payload, callback) {\n  callback(null, true);\n};\n\n/**\n * The function that will be used to authorize clients to subscribe to topics.\n * This default implementation authorize everybody.\n * Override at will\n *\n * @api public\n * @param {Object} client The MQTTConnection that is a client\n * @param {String} topic The topic\n * @param {Function} callback The callback to return the verdict\n */\nServer.prototype.authorizeSubscribe = function(client, topic, callback) {\n  callback(null, true);\n};\n\n/**\n * The function that will be used to authorize forwarding packet to client.\n * This default implementation authorize any packet for any client.\n * Override at will\n *\n * @api public\n * @param {Object} client The MQTTConnection that is a client.\n * @param {Object} packet The packet to be published.\n * @param {Function} callback The callback to return the authorization flag.\n */\nServer.prototype.authorizeForward = function(client, packet, callback) {\n  callback(null, true);\n};\n\n\n/**\n * Store a packet for future usage, if needed.\n * Only packets with the retained flag are setted, or for which\n * there is an \"offline\" subscription\".\n * This is a NOP, override at will.\n *\n * @api public\n * @param {Object} packet The MQTT packet to store\n * @param {Function} callback\n */\nServer.prototype.storePacket = function(packet, callback) {\n  if (callback) {\n    callback();\n  }\n};\n\n/**\n * Delete a packet for the offline storage\n * This is a NOP, override at will.\n *\n * @api public\n * @param {Object} client The client\n * @param {Number} messageId The messsageId of the packet\n * @param {Function} callback\n */\nServer.prototype.deleteOfflinePacket = function(client, messageId, callback) {\n  if (callback) {\n    callback();\n  }\n};\n\n/**\n * Forward all the retained messages of the specified pattern to\n * the client.\n * This is a NOP, override at will.\n *\n * @api public\n * @param {String} pattern The topic pattern.\n * @param {MoscaClient} client The client to forward the packet's to.\n * @param {Function} callback\n */\nServer.prototype.forwardRetained = function(pattern, client, callback) {\n  if (callback) {\n    callback();\n  }\n};\n\n/**\n * Restores the previous subscriptions in the client\n * This is a NOP, override at will.\n *\n * @param {MoscaClient} client\n * @param {Function} callback\n */\nServer.prototype.restoreClientSubscriptions = function(client, callback) {\n  if (callback) {\n    callback();\n  }\n};\n\n/**\n * Forward all the offline messages the client has received when it was offline.\n * This is a NOP, override at will.\n *\n * @param {MoscaClient} client\n * @param {Function} callback\n */\nServer.prototype.forwardOfflinePackets = function(client, callback) {\n  if (callback) {\n    callback();\n  }\n};\n\n/**\n * Updates an offline packet.\n * This is a NOP, override at will.\n *\n * @param {MoscaClient} client\n * @param {Integer} originMessageId The original message id\n * @param {Object} packet The new packet\n * @param {Function} callback\n */\nServer.prototype.updateOfflinePacket = function(client, originMessageId, packet, callback) {\n  if (callback) {\n    callback(null, packet);\n  }\n};\n\n/**\n * Persist a client.\n * This is a NOP, override at will.\n *\n * @param {MoscaClient} client\n * @param {Function} callback\n */\nServer.prototype.persistClient = function(client, callback) {\n  if (callback) {\n    callback();\n  }\n};\n\n/**\n * Closes the server.\n *\n * @api public\n * @param {Function} callback The closed callback function\n */\nServer.prototype.close = function(callback) {\n  var that = this;\n  var stuffToClose = [];\n\n  callback = callback || function nop() {};\n\n  if (that.closed) {\n    return callback();\n  }\n\n  that.closed = true;\n\n  Object.keys(that.clients).forEach(function(i) {\n    stuffToClose.push(that.clients[i]);\n  });\n\n  that.servers.forEach(function(server) {\n    stuffToClose.push(server);\n  });\n\n  if (that.persistence) {\n    stuffToClose.push(that.persistence);\n  }\n\n  steed.each(stuffToClose, function(toClose, cb) {\n    toClose.close(cb, \"server closed\");\n  }, function() {\n    that.ascoltatore.close(function () {\n      that.logger.info(\"server closed\");\n      that.emit(\"closed\");\n      callback();\n    });\n  });\n};\n\n/**\n * Attach a Mosca server to an existing http server\n *\n * @api public\n * @param {HttpServer} server\n * @param {String} path\n */\nServer.prototype.attachHttpServer = function(server, path) {\n  var that = this;\n\n  var opt = { server: server };\n  if (path) {\n    opt.path = path;\n  }\n  \n  ws.createServer(opt, function(stream) {\n    var conn = new Connection(stream);\n    new Client(conn, that);\n  });\n};\n\nServer.prototype.nextDedupId = function() {\n  return this._dedupId++;\n};\n\nServer.prototype.generateUniqueId = function() {\n  return shortid.generate();\n};\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/client.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar steed = require(\"steed\")();\nvar uuid = require(\"uuid\");\nvar retimer = require('retimer');\n\nfunction nop() {}\n\n/**\n * The Client is just the object modelling a server representation\n * of a client\n *\n * @param {MqttConnection} conn The mqtt connection object for this client\n * @param {Server} server The Mosca server this client will be tied to\n * @api public\n */\nfunction Client(conn, server) {\n  this.connection = conn;\n  this.server = server;\n  this.logger = server.logger;\n  this.subscriptions = {};\n\n  this.nextId = 1;\n  this.inflight = {};\n  this.inflightCounter = 0;\n  this._lastDedupId = -1;\n  this._closed = false;\n  this._closing = false;\n\n  this._setup();\n}\n\n/**\n * Sets up all the handlers, to not be called directly.\n *\n * @api private\n */\nClient.prototype._setup = function() {\n  var that = this, client = that.connection;\n\n  this._buildForward();\n\n  client.on(\"error\", nop);\n\n  function completeConnection() {\n    that.setUpTimer();\n\n    that.server.restoreClientSubscriptions(that, function(session_present) {\n      client.connack({\n        returnCode: 0,\n        // maybe session_present is null, custom old persistence engine\n        // or not persistence defined\n        sessionPresent: session_present ? true : false\n      });\n\n      that.logger.info(\"client connected\");\n      that.server.emit(\"clientConnected\", that);\n\n      // packets will be forward only if client.clean is false\n      that.server.forwardOfflinePackets(that);\n    });\n\n    client.on(\"puback\", function(packet) {\n      that.setUpTimer();\n      that.handlePuback(packet);\n    });\n\n    client.on(\"pingreq\", function() {\n      that.logger.debug(\"pingreq\");\n      that.setUpTimer();\n      that.handlePingreq();\n      that.connection.pingresp();\n    });\n\n    client.on(\"subscribe\", function(packet) {\n      that.setUpTimer();\n      that.handleSubscribe(packet);\n    });\n\n    client.on(\"publish\", function(packet) {\n      that.setUpTimer();\n      that.server.authorizePublish(that, packet.topic, packet.payload, function(err, success) {\n        that.handleAuthorizePublish(err, success, packet);\n      });\n    });\n\n    client.on(\"unsubscribe\", function(packet) {\n      that.setUpTimer();\n      that.logger.info({ packet: packet }, \"unsubscribe received\");\n      steed.map(that, packet.unsubscriptions, that.unsubscribeMapTo, function(err) {\n        if (err) {\n          that.logger.warn(err);\n          that.close(null, err.message);\n          return;\n        }\n        that.server.persistClient(that);\n        client.unsuback({\n          messageId: packet.messageId\n        });\n      });\n    });\n\n    client.on(\"disconnect\", function() {\n      that.logger.debug(\"disconnect requested\");\n      that.close(null, \"disconnect request\");\n    });\n\n    function handleError(err) {\n      that.logger.warn(err);\n      that.onNonDisconnectClose(err.message);\n    }\n\n    client.on(\"error\", handleError);\n    client.removeListener(\"error\", nop);\n\n    client.on(\"close\", function() {\n      that.onNonDisconnectClose(\"close\");\n    });\n  }\n\n  client.once(\"connect\", function(packet) {\n    that.handleConnect(packet, completeConnection);\n  });\n};\n\n/**\n * Sets up the keepalive timer.\n * To not be called directly.\n *\n * @api private\n */\nClient.prototype.setUpTimer = function() {\n  if (this.keepalive <= 0) {\n    return;\n  }\n\n  var timeout = this.keepalive * 1000 * 3 / 2;\n  var that = this;\n\n  this.logger.debug({ timeout: timeout }, \"setting keepalive timeout\");\n\n  if (this.timer) {\n    this.timer.reschedule(timeout);\n  } else {\n    this.timer = retimer(function keepaliveTimeout() {\n      that.logger.info(\"keepalive timeout\");\n      that.onNonDisconnectClose(\"keepalive timeout\");\n    }, timeout);\n  }\n};\n\n/**\n * Builds the forward property for this object.\n * It wraps 'this' inside a closure.\n *\n * @api private\n */\nClient.prototype._buildForward = function() {\n  var that = this;\n\n  function doForward(err, packet) {\n    if (err) {\n      return that.client && that.client.emit('error', err);\n    }\n\n    that.server.authorizeForward(that, packet, function(err, authorized) {\n      if (err) {\n        return that.client && that.client.emit('error', err);\n      }\n\n      if (!authorized) {\n        that.logger.warn(packet, \"Unauthorized Forward\");\n        return;\n      }\n\n      that.connection.publish(packet);\n\n      if (packet.qos === 1) {\n        that.inflight[packet.messageId] = packet;\n      }\n    });\n  }\n\n  this.forward = function(topic, payload, options, subTopic, qos, cb) {\n    if (options._dedupId <= that._lastDedupId) {\n      return;\n    }\n\n    that.logger.trace({ topic: topic }, \"delivering message\");\n\n    var sub = that.subscriptions[subTopic],\n        indexWildcard = subTopic.indexOf(\"#\"),\n        indexPlus = subTopic.indexOf(\"+\"),\n        forward = true,\n        newId = this.nextId++;\n\n    // Make sure 'nextId' always fits in a uint8 (http://git.io/vmgKI).\n    this.nextId %= 65536;\n\n    var packet = {\n      topic: topic,\n      payload: payload,\n      qos: qos,\n      messageId: newId\n    };\n\n    if (qos) {\n      that.inflightCounter++;\n    }\n\n    if (that._closed || that._closing) {\n      that.logger.debug({ packet: packet }, \"trying to send a packet to a disconnected client\");\n      forward = false;\n    } else if (that.inflightCounter >= that.server.opts.maxInflightMessages) {\n      that.logger.warn(\"too many inflight packets, closing\");\n      that.close(null, \"too many inflight packets\");\n      forward = false;\n    }\n\n    if (cb) {\n      cb();\n    }\n\n    // skip delivery of messages in $SYS for wildcards\n    forward = forward &&\n              ! ( topic.indexOf('$SYS') >= 0 &&\n                  (\n                    indexWildcard >= 0 &&\n                    indexWildcard < 2 ||\n                    indexPlus >= 0 &&\n                    indexPlus < 2\n                  )\n                );\n\n    if (forward) {\n      if (options._dedupId === undefined) {\n        options._dedupId = that.server.nextDedupId();\n        that._lastDedupId = options._dedupId;\n      }\n\n      if (qos && options.messageId) {\n        that.server.updateOfflinePacket(that, options.messageId, packet, doForward);\n      } else {\n        doForward(null, packet);\n      }\n    }\n  };\n};\n\n/**\n * Builds a function for unsubscribing from a topic.\n *\n * @api private\n */\nClient.prototype.unsubscribeMapTo = function(topic, cb) {\n  var that = this;\n  var sub = that.subscriptions[topic];\n  if (!sub || !sub.handler) {\n    that.server.emit(\"unsubscribed\", topic, that);\n    return cb();\n  }\n\n  that.server.ascoltatore.unsubscribe(topic, sub.handler, function(err) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    if (!that._closing || that.clean) {\n      delete that.subscriptions[topic];\n      that.logger.info({ topic: topic }, \"unsubscribed\");\n      that.server.emit(\"unsubscribed\", topic, that);\n    }\n\n    cb();\n  });\n};\n\n/**\n * Handle a connect packet, doing authentication.\n *\n * @api private\n */\nClient.prototype.handleConnect = function(packet, completeConnection) {\n  var that = this, logger, client = this.connection;\n\n  this.id = packet.clientId;\n\n  this.logger = logger = that.logger.child({ client: this });\n\n  // for MQTT 3.1.1 (protocolVersion == 4) it is valid to receive an empty\n  // clientId if cleanSession is set to 1. In this case, Mosca should generate\n  // a random ID.\n  // Otherwise, the connection should be rejected.\n  if(!this.id) {\n\n    if(packet.protocolVersion == 4 && packet.clean) {\n\n      this.id = uuid.v4();\n    }\n    else {\n\n      logger.info(\"identifier rejected\");\n      client.connack({\n        returnCode: 2\n      });\n      client.stream.end();\n      return;\n    }\n  }\n\n\n  that.server.authenticate(this, packet.username, packet.password,\n                           function(err, verdict) {\n\n    if (err) {\n      logger.info({ username: packet.username }, \"authentication error\");\n      client.connack({\n        returnCode: 4\n      });\n      client.stream.end();\n      return;\n    }\n\n    if (!verdict) {\n      logger.info({ username: packet.username }, \"authentication denied\");\n      client.connack({\n        returnCode: 5\n      });\n      client.stream.end();\n      return;\n    }\n\n    that.keepalive = packet.keepalive;\n    that.will = packet.will;\n\n    that.clean = packet.clean;\n\n    if (that.id in that.server.clients){\n      that.server.clients[that.id].close(completeConnection, \"new connection request\");\n    } else {\n      completeConnection();\n    }\n  });\n};\n\n/**\n * Handle a pingreq\n *\n * @api private\n */\nClient.prototype.handlePingreq = function() {\n  var that = this;\n  that.server.emit(\"pingreq\", that);\n};\n\n/**\n * Handle a puback packet.\n *\n * @api private\n */\nClient.prototype.handlePuback = function(packet) {\n  var logger = this.logger;\n  var that = this;\n\n  logger.debug({ packet: packet }, \"puback\");\n  if (this.inflight[packet.messageId]) {\n    this.server.emit(\"delivered\", this.inflight[packet.messageId], that);\n    this.inflightCounter--;\n    delete this.inflight[packet.messageId];\n    this.server.deleteOfflinePacket(this, packet.messageId, function(err) {\n      if (err) {\n        return that.client && that.client.emit(\"error\", err);\n      }\n      logger.debug({ packet: packet }, \"cleaned offline packet\");\n    });\n  } else {\n    logger.info({ packet: packet }, \"no matching packet\");\n  }\n};\n\n/**\n * Calculate the QoS of the subscriptions.\n *\n * @api private\n */\nfunction calculateGranted(client, packet) {\n  return packet.subscriptions.map(function(e) {\n    if (e.qos === 2) {\n      e.qos = 1;\n    }\n    if (client.subscriptions[e.topic] !== undefined) {\n      client.subscriptions[e.topic].qos = e.qos;\n    }\n    return e.qos;\n  });\n}\n\n/**\n * Handle the result of the Server's authorizeSubscribe method.\n *\n * @api private\n */\nClient.prototype.handleAuthorizeSubscribe = function(err, success, s, cb) {\n  if (err) {\n    cb(err);\n    return;\n  }\n\n  if (!success) {\n    this.logger.info({ topic: s.topic }, \"subscribe not authorized\");\n    cb(null, false);\n    return;\n  }\n\n  var that = this;\n\n  var handler = function(topic, payload, options) {\n    that.forward(topic, payload, options, s.topic, s.qos);\n  };\n\n  if (this.subscriptions[s.topic] === undefined) {\n    this.subscriptions[s.topic] = { qos: s.qos, handler: handler };\n    this.server.ascoltatore.subscribe(\n      s.topic,\n      handler,\n      function(err) {\n        if (err) {\n          delete that.subscriptions[s.topic];\n          cb(err);\n          return;\n        }\n        that.logger.info({ topic: s.topic, qos: s.qos }, \"subscribed to topic\");\n        //that.subscriptions[s.topic] = { qos: s.qos, handler: handler };\n        cb(null, true);\n      }\n    );\n  } else {\n    cb(null, true);\n  }\n};\n\nfunction handleEachSub (s, cb) {\n  /*jshint validthis:true */\n  var that = this;\n  if (this.subscriptions[s.topic] === undefined) {\n    this.server.authorizeSubscribe(that, s.topic, function(err, success) {\n      that.handleAuthorizeSubscribe(err, success, s, cb);\n    });\n  } else {\n    cb(null, true);\n  }\n}\n\n/**\n * Handle a subscribe packet.\n *\n * @api private\n */\nClient.prototype.handleSubscribe = function(packet) {\n  var that = this, server = this.server, logger = this.logger;\n\n  logger.debug({ packet: packet }, \"subscribe received\");\n\n  var granted = calculateGranted(this, packet);\n\n  steed.map(this, packet.subscriptions, handleEachSub, function(err, authorized) {\n\n    if (err) {\n      that.close(null, err.message);\n      return;\n    }\n\n    that.server.persistClient(that);\n\n    packet.subscriptions.forEach(function(sub, index) {\n      if (authorized[index]) {\n        that.server.forwardRetained(sub.topic, that);\n        that.server.emit(\"subscribed\", sub.topic, that);\n      } else {\n        granted[index] = 0x80;\n      }\n    });\n\n    if(!that._closed) {\n      that.connection.suback({\n        messageId: packet.messageId,\n        granted: granted\n      });\n    }\n  });\n};\n\n/**\n * Handle the result of a call to the Server's authorizePublish\n *\n * @api private\n */\nClient.prototype.handleAuthorizePublish = function(err, success, packet) {\n  var that = this;\n\n  if (err || !success) {\n    if (!this._closed && !this._closing) {\n      that.close(null, (err && err.message) || \"publish not authorized\");\n    }\n    return;\n  }\n\n  if (success instanceof Buffer) {\n    packet.payload = success;\n  }\n\n  that.server.publish(packet, that, function() {\n    if (packet.qos === 1 && !(that._closed || that._closing)) {\n      that.connection.puback({\n        messageId: packet.messageId\n      });\n    }\n  });\n};\n\n/**\n * Stuff to do when a client closes without a disconnect.\n * it also deliver the client last will.\n *\n * @api private\n */\nClient.prototype.onNonDisconnectClose = function(reason) {\n  var that = this, logger = that.logger, will = that.will;\n\n  if (this._closed || this._closing) {\n    return;\n  }\n\n  if (that.will) {\n    logger.info({ packet: will }, \"delivering last will\");\n    setImmediate(function() {\n      that.server.authorizePublish(that, will.topic, will.payload, function(err, success) {\n        that.handleAuthorizePublish(err, success, will);\n      });\n    });\n  }\n\n  this.close(null, reason);\n};\n\n/**\n * Close the client\n *\n * @api public\n * @param {Function} callback The callback to be called when the Client is closed\n */\nClient.prototype.close = function(callback, reason) {\n\n  callback = callback || nop;\n\n  if (this._closed || this._closing) {\n    return callback();\n  }\n\n  var that = this;\n\n  if (this.id) {\n    that.logger.debug(\"closing client, reason: \" + reason);\n\n    if (this.timer) {\n      this.timer.clear();\n    }\n  }\n\n  var cleanup = function() {\n    that._closed = true;\n\n    that.logger.info(\"closed\");\n    that.connection.removeAllListeners();\n    // ignore all errors after disconnection\n    that.connection.on(\"error\", function() {});\n    that.server.emit(\"clientDisconnected\", that, reason);\n\n    callback();\n  };\n\n  that._closing = true;\n\n  steed.map(that, Object.keys(that.subscriptions), that.unsubscribeMapTo, function(err) {\n    if (err) {\n      that.logger.info(err);\n    }\n\n    // needed in case of errors\n    if (!that._closed) {\n      cleanup();\n      // prefer destroy[Soon]() to prevent FIN_WAIT zombie connections\n      if (that.connection.stream.destroySoon) {\n        that.connection.stream.destroySoon();\n      } else if (that.connection.stream.destroy) {\n        that.connection.stream.destroy();\n      } else {\n        that.connection.stream.end();\n      }\n    }\n  });\n};\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/stats.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\"use strict\";\n\nvar moment = require(\"moment\");\nvar movingAverage = require(\"moving-average\");\nvar version = \"mosca \" + require(\"../package\").version;\n\n/**\n * Create a new load object.\n *\n * @api private\n */\nfunction Load(minutes) {\n  this.maPublishedMessages = movingAverage(minutes * 60 * 1000);\n  this.maPublishedMessages.push(Date.now(), 0);\n  this.maConnectedClients = movingAverage(minutes * 60 * 1000);\n  this.maConnectedClients.push(Date.now(), 0);\n}\n\nObject.defineProperties(Load.prototype, {\n  \"publishedMessages\": {\n    get: function () {\n      var value = this.maPublishedMessages.movingAverage();\n      value = Math.round(value * 100) / 100;\n      return value;\n    }\n  },\n  \"connectedClients\": {\n    get: function () {\n      var value = this.maConnectedClients.movingAverage();\n      value = Math.round(value * 100) / 100;\n      return value;\n    }\n  }\n});\n\n/**\n * A Stats object is used to keep track of the state of a mosca.Server\n * and can be wired() there.\n *\n * It provides the following stats:\n *  - connectedClients: the number of connected clients at this point in time\n *  - publishedMessages: the number of publish messages received since the the start\n *\n * It also track the load at 1min, 5min, and 15min of the same events.\n *\n * @api public\n */\nfunction Stats() {\n  if (!(this instanceof Stats)) {\n    return new Stats();\n  }\n\n  this.maxConnectedClients = 0;\n  this.connectedClients = 0;\n  this.lastIntervalConnectedClients = 0;\n  this.publishedMessages = 0;\n  this.lastIntervalPublishedMessages = 0;\n  this.started = new Date();\n\n  this.load = {\n    m15: new Load(15),\n    m5: new Load(5),\n    m1: new Load(1)\n  };\n}\n\n/**\n * Inlinable method for adding a connected\n * client.\n *\n * @api private\n */\nfunction clientConnected() {\n  /*jshint validthis:true */\n  this.stats.connectedClients++;\n  this.stats.lastIntervalConnectedClients++;\n  if( this.stats.connectedClients > this.stats.maxConnectedClients ) {\n    this.stats.maxConnectedClients = this.stats.connectedClients;\n  }\n}\n\n/**\n * Inlinable method for removing a connected\n * client.\n *\n * @api private\n */\nfunction clientDisconnected() {\n  /*jshint validthis:true */\n  this.stats.connectedClients--;\n  this.stats.lastIntervalConnectedClients--;\n}\n\n/**\n * Inlinable method for counting published\n * messages\n *\n * @api private\n */\nfunction published( packet ) {\n  /*jshint validthis:true */\n  if( packet && packet.topic && packet.topic.indexOf( '$SYS' ) < 0 ) { // count only publishes in user namespace\n    this.stats.publishedMessages++;\n    this.stats.lastIntervalPublishedMessages++;\n  }\n}\n\n/**\n * Events that update the stats\n *\n * @api private\n */\nvar events = [\n  clientConnected,\n  clientDisconnected,\n  published\n];\n\n/**\n * wire() adds the stats to a mosca.Server.\n *\n * @api public\n * @param {Server} server The Mosca Server.\n */\nStats.prototype.wire = function wire(server) {\n  server.stats = this;\n\n  var count = 0;\n\n  function doPublish(topic, value) {\n    server.publish({\n      topic: \"$SYS/\" + server.id + \"/\" + topic,\n      payload: \"\" + value\n    });\n  }\n\n  var mom = moment(this.started);\n\n  var timer = setInterval(function() {\n    var stats = server.stats;\n    var mem = process.memoryUsage();\n\n    var date = new Date();\n\n    stats.load.m1.maConnectedClients.push(date, stats.lastIntervalConnectedClients);\n    stats.load.m5.maConnectedClients.push(date, stats.lastIntervalConnectedClients);\n    stats.load.m15.maConnectedClients.push(date, stats.lastIntervalConnectedClients);\n    stats.lastIntervalConnectedClients = 0;\n\n    stats.load.m1.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);\n    stats.load.m5.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);\n    stats.load.m15.maPublishedMessages.push(date, stats.lastIntervalPublishedMessages);\n    stats.lastIntervalPublishedMessages = 0;\n\n    doPublish(\"version\", version);\n    doPublish(\"started_at\", server.stats.started.toISOString());\n    doPublish(\"uptime\", mom.from(Date.now(), true));\n    doPublish(\"clients/maximum\", stats.maxConnectedClients);\n    doPublish(\"clients/connected\", stats.connectedClients);\n    doPublish(\"publish/received\", stats.publishedMessages);\n    doPublish(\"load/connections/15min\", stats.load.m15.connectedClients);\n    doPublish(\"load/publish/received/15min\", stats.load.m15.publishedMessages);\n    doPublish(\"load/connections/5min\", stats.load.m5.connectedClients);\n    doPublish(\"load/publish/received/5min\", stats.load.m5.publishedMessages);\n    doPublish(\"load/connections/1min\", stats.load.m1.connectedClients);\n    doPublish(\"load/publish/received/1min\", stats.load.m1.publishedMessages);\n    doPublish(\"memory/rss\", mem.rss);\n    doPublish(\"memory/heap/current\", mem.heapUsed);\n    doPublish(\"memory/heap/maximum\", mem.heapTotal);\n  }, 10 * 1000);\n\n  events.forEach(function(event) {\n    server.on(event.name, event);\n  });\n\n  server.once(\"closed\", function() {\n    clearInterval(timer);\n\n    events.forEach(function(event) {\n      server.removeListener(event.name, event);\n    });\n  });\n};\n\nmodule.exports = Stats;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/index.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\n/**\n * Module exports\n *\n * @api public\n */\nmodule.exports.Memory = require(\"./memory\");\nmodule.exports.LevelUp = require(\"./levelup\");\nmodule.exports.Redis = require(\"./redis\");\nmodule.exports.Mongo = require(\"./mongo\");\n\nvar factories = {};\nObject.keys(module.exports).forEach(function(type) {\n  factories[type.toLowerCase()] = module.exports[type];\n});\n\nmodule.exports.getFactory = function(name) {\n  return factories[name.toLowerCase()];\n};\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/memory.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar LevelUpPersistence = require(\"./levelup\");\nvar util = require(\"util\");\nvar MemDOWN = require(\"memdown\");\nvar factory = function (location) { return new MemDOWN(location); };\n\n/**\n * A persistence based in memory that uses LevelUp with\n * MemDOWN.\n *\n * It exposes the same options of the LevelUpPersistence,\n * minus the `db`, which is set to MemDOWN for convenience.\n *\n * @api public\n * @param {Object} options The options to create this persistance\n * @param {Function} callback Called when ready.\n */\nfunction MemoryPersistence(options, callback) {\n  if (!(this instanceof MemoryPersistence)) {\n    return new MemoryPersistence(options, callback);\n  }\n\n  options = options || {};\n  options.db = factory;\n  options.path = \"RAM\";\n  LevelUpPersistence.call(this, options, callback);\n}\n\nutil.inherits(MemoryPersistence, LevelUpPersistence);\n\nMemoryPersistence.prototype.close = function(cb) {\n\n  MemDOWN.clearGlobalStore();\n\n  this._streams.forEach(function(stream) {\n    stream.destroy();\n  });\n  this.db.close(cb);\n};\n\n/**\n * Export it as a module\n *\n * @api public\n */\nmodule.exports = MemoryPersistence;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/levelup.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar levelup = require(\"levelup\");\nvar from = require(\"array-from\");\nvar sublevel = require(\"level-sublevel\");\nvar AbstractPersistence = require(\"./abstract\");\nvar JSONB = require(\"json-buffer\");\nvar util = require(\"util\");\nvar msgpack = require(\"msgpack5\")();\nvar Matcher = require(\"./matcher\");\nvar steed = require(\"steed\");\nvar extend = require(\"extend\");\nvar defaults = {\n  valueEncoding: {\n    encode: function(val) {\n      return msgpack.encode(val).slice();\n    },\n    decode: function(val) {\n      return msgpack.decode(val);\n    },\n    type: \"msgpack5\",\n    buffer: true\n  },\n  ttl: {\n    // TTL for subscriptions is 1 hour\n    subscriptions: 60 * 60 * 1000,\n\n    // TTL for packets is 1 hour\n    packets: 60 * 60 * 1000,\n  },\n  storeMessagesQos0: false\n};\n\n/**\n * A LevelUp-based persistance.\n *\n * The current options include:\n *  - `path`, the path to the database\n *  - `ttl`, an object containing three values:\n *    * `checkFrequency`, the frequency at which the\n *      the expiration will be checked. It defaults to 1 minute.\n *    * `subscriptions`, the time (ms) after which subscriptions\n *      will expire. It defaults to 1 hour.\n *    * `packets`, the time (ms) after which packets will expire.\n *      It defaults to 1 hour.\n *  - `db`, the AbstractLevelDown implementation.\n *  - all other `levelup` otions.\n *  - `storeMessagesQos0` store messages with qos 0, default false\n *     like mosquitto option 'queue_qos0_messages', non-standard option\n *\n * @api public\n * @param {Object} options The options to create this persistance\n * @param {Function} callback Called when ready.\n */\nfunction LevelUpPersistence(options, callback) {\n  if (!(this instanceof LevelUpPersistence)) {\n    return new LevelUpPersistence(options, callback);\n  }\n\n  this.options = extend(true, {}, defaults, options);\n\n\n  this.db = levelup(this.options.path, this.options);\n\n  var db = sublevel(this.db);\n\n  this._retained = db.sublevel(\"retained\");\n  this._clientSubscriptions = db.sublevel(\"clientSubscriptions\");\n  this._subscriptions = db.sublevel(\"subscriptions\");\n  this._offlinePackets = db.sublevel(\"offlinePackets\");\n  this._subMatcher = new Matcher();\n  this._packetCounter = 0;\n  this._lastStoredPacketTime = Date.now();\n  this._streams = [];\n\n  var that = this;\n  var stream = this._subscriptions.createReadStream();\n  this._streams.push(stream);\n  stream.on(\"data\", function(data) {\n    that._subMatcher.add(data.value.topic, data.key);\n  });\n  stream.on(\"end\", function() {\n    that._cleanupStream(stream);\n    if (callback) {\n      callback(null, that);\n    }\n  });\n  stream.on(\"close\", function() {\n    that._cleanupStream(stream);\n  });\n}\n\nutil.inherits(LevelUpPersistence, AbstractPersistence);\n\n/**\n * Private methods, not inteded to be called from outside\n *\n * @api private\n */\n\nLevelUpPersistence.prototype.storeRetained = function(packet, cb) {\n  if (packet.payload.length > 0) {\n    this._retained.put(packet.topic, packet, cb);\n  } else {\n    this._retained.del(packet.topic, cb);\n  }\n};\n\nLevelUpPersistence.prototype.lookupRetained = function(pattern, cb) {\n  var that = this;\n  var matched = [];\n  var matcher = new Matcher();\n  var stream = this._retained.createReadStream();\n  this._streams.push(stream);\n  matcher.add(pattern, true);\n\n  stream.on(\"error\", cb);\n\n  stream.on(\"end\", function() {\n    that._cleanupStream(stream);\n    cb(null, matched);\n  });\n\n  stream.on(\"close\", function() {\n    that._cleanupStream(stream);\n  });\n\n  stream.on(\"data\", function(data) {\n    if (matcher.match(data.key).size > 0) {\n      matched.push(data.value);\n    }\n  });\n};\n\nLevelUpPersistence.prototype.storeSubscriptions = function(client, done) {\n  var that = this;\n  var subscriptions = {};\n  var now = Date.now();\n\n  if (!client.clean) {\n    Object.keys(client.subscriptions).forEach(function(key) {\n      if (client.subscriptions[key].qos > 0) {\n        subscriptions[key] = client.subscriptions[key];\n        subscriptions[key].ttl = that.options.ttl.subscriptions + now;\n      }\n    });\n    this._clientSubscriptions.put(client.id, subscriptions, done);\n    Object.keys(subscriptions).forEach(function(key) {\n      var sub = {\n        client: client.id,\n        topic: key,\n        ttl: that.options.ttl.subscriptions + now,\n        qos: subscriptions[key].qos\n      };\n      var levelKey = util.format(\"%s:%s\", key, client.id);\n      that._subMatcher.add(key, levelKey);\n      that._subscriptions.put(levelKey, sub);\n    });\n  } else if (done) {\n    done();\n  }\n};\n\nvar nop = function() {};\nLevelUpPersistence.prototype.lookupSubscriptions = function(client, done) {\n  var that = this;\n  this._clientSubscriptions.get(client.id, function(err, subscriptions) {\n    var toRemove = [];\n\n    subscriptions = subscriptions || {};\n\n    Object.keys(subscriptions).forEach(function(key) {\n      var levelKey = util.format(\"%s:%s\", key, client.id);\n      if (subscriptions[key].ttl <= Date.now()) {\n        delete subscriptions[key];\n        that._subMatcher.remove(key, levelKey);\n        toRemove.push(levelKey);\n      }\n    });\n\n    if (client.clean) {\n      that._clientSubscriptions.del(client.id, function() {\n        Object.keys(subscriptions).forEach(function(key) {\n          // TODO we need to remove these from the subMatcher every time.\n          var levelKey = util.format(\"%s:%s\", key, client.id);\n          that._subMatcher.remove(key, levelKey);\n          toRemove.push(levelKey);\n        });\n\n        that.streamOfflinePackets(client, nop, function() {\n          that._subscriptions.batch(toRemove.map(function(levelKey) {\n            return {\n              key: levelKey,\n              type: 'del'\n            };\n          }), function(err) {\n            done(err, {});\n          });\n        });\n      });\n    } else if (done) {\n      done(null, subscriptions);\n    }\n  });\n};\n\nLevelUpPersistence.prototype.storeOfflinePacket = function(packet, done) {\n  var that = this;\n  var subs = this._subMatcher.match(packet.topic);\n  steed.map(from(subs), function(key, cb) {\n    that._subscriptions.get(key, function(err, sub) {\n      if (err) {\n        return cb(err);\n      }\n      that._storePacket(sub.client, packet, cb);\n    });\n  }, done);\n};\n\nLevelUpPersistence.prototype.streamOfflinePackets = function(client, cb, done) {\n  var that = this;\n  var prefix = util.format('%s:', client.id);\n  var count = 0;\n  var ended = false;\n  var stream = that._offlinePackets.createReadStream({\n    start : prefix,\n    end : prefix + '~'\n  });\n  this._streams.push(stream);\n\n  stream.on(\"data\", function(data) {\n\n    if (client.clean || data.value.ttl <= Date.now()) {\n      count++;\n      that._offlinePackets.del(data.key, function() {\n        count--;\n\n\t// for testing\n        if (ended && count === 0 && done) {\n          done();\n        }\n      });\n    } else {\n      cb(null, data.value);\n    }\n  });\n\n  stream.on(\"end\", function() {\n    that._cleanupStream(stream);\n    ended = true;\n\n    // for testing\n    if (count === 0 && done) {\n      done();\n    }\n  });\n\n  stream.on(\"close\", function() {\n    that._cleanupStream(stream);\n  });\n\n  // for testing\n  if (done) {\n    stream.on(\"error\", done);\n  }\n};\n\nLevelUpPersistence.prototype.deleteOfflinePacket = function(client, messageId, done) {\n  var that = this;\n  var prefix = util.format('%s:', client.id);\n  var found = false;\n  var stream = that._offlinePackets.createReadStream({\n    start : prefix,\n    end : prefix + '~'\n  });\n  this._streams.push(stream);\n\n  stream.on(\"data\", function(data) {\n    if (data.value.messageId !== messageId) {\n      return;\n    }\n\n    found = true;\n\n    that._offlinePackets.del(data.key, function() {\n      if (done) {\n        done();\n      }\n    });\n  });\n\n  stream.on(\"end\", function() {\n    that._cleanupStream(stream);\n  });\n\n  stream.on(\"close\", function() {\n    that._cleanupStream(stream);\n  });\n\n  if (done) {\n    stream.on(\"error\", done);\n    stream.on(\"end\", function() {\n      if (!found) {\n        done();\n      }\n    });\n  }\n};\n\nLevelUpPersistence.prototype.updateOfflinePacket = function(client, messageId, packet, done) {\n  var that = this;\n  var prefix = util.format('%s:', client.id);\n  var found = false;\n  var stream = that._offlinePackets.createReadStream({\n    start : prefix,\n    end : prefix + '~'\n  });\n  this._streams.push(stream);\n\n  stream.on(\"data\", function(data) {\n    if (data.value.messageId !== messageId) {\n      return;\n    }\n\n    found = true;\n\n    data.value.messageId = packet.messageId;\n\n    that._offlinePackets.put(data.key, data.value, function() {\n      if (done) {\n        done(null, packet);\n      }\n    });\n  });\n\n  stream.on(\"end\", function() {\n    that._cleanupStream(stream);\n  });\n\n  stream.on(\"close\", function() {\n    that._cleanupStream(stream);\n  });\n\n  if (done) {\n    stream.on(\"error\", done);\n    stream.on(\"end\", function() {\n      if (!found) {\n        done(null, packet);\n      }\n    });\n  }\n};\n\nLevelUpPersistence.prototype._storePacket = function(client, packet, cb) {\n  var currentTime = Date.now();\n  if (currentTime !== this._lastStoredPacketTime) {\n    this._packetCounter = 0;\n  }\n  this._lastStoredPacketTime = currentTime;\n  var key = util.format(\"%s:%d:%d\", client, currentTime, ++this._packetCounter);\n  packet.ttl = this.options.ttl.packets + currentTime;\n  this._offlinePackets.put(key, packet, cb);\n};\n\nLevelUpPersistence.prototype.close = function(cb) {\n  this._streams.forEach(function(stream) {\n    stream.destroy();\n  });\n  this.db.close(cb);\n};\n\nLevelUpPersistence.prototype._cleanupStream = function(stream) {\n  var index = this._streams.indexOf(stream);\n  if (index !== -1) {\n    this._streams.splice(index, 1);\n  }\n};\n\n/**\n * Export it as a module\n *\n * @api public\n */\nmodule.exports = LevelUpPersistence;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/abstract.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar steed = require(\"steed\")();\nvar EventEmitter = require(\"events\").EventEmitter;\nvar util = require(\"util\");\n\n/**\n * An Abstract Mosca persistance implementation\n *\n * @api public\n */\nfunction AbstractPersistence() {\n\n}\n\nutil.inherits(AbstractPersistence, EventEmitter);\n\n/**\n * This wires the Mosca server to a persistance, plugging in\n * the persistance into the relevant Mosca events.\n *\n * @api public\n * @param {Server} server The Mosca Server.\n */\nAbstractPersistence.prototype.wire = function(server) {\n  var that = this;\n  var nop = function() {};\n  server.persistence = this;\n\n  server.storePacket = function(packet, cb) {\n\n    // store qos 0 packets only if storeMessagesQos0 is true or retain is true\n    if(packet.qos === 0 && packet.retain === false && ! that.options.storeMessagesQos0){\n      return cb();\n    }\n\n    var total = 1;\n    var done = function() {\n      if (--total === 0 && cb) {\n        cb();\n      }\n    };\n    if (packet.retain) {\n      total++;\n      that.storeRetained(packet, done);\n    }\n    if (packet.qos !== 0 || that.options.storeMessagesQos0) {\n      total++;\n      that.storeOfflinePacket(packet, done);\n    }\n    done();\n  };\n\n  server.deleteOfflinePacket = function(client, messageId, cb) {\n    that.deleteOfflinePacket(client, messageId, cb);\n  };\n\n  server.updateOfflinePacket = function(client, messageId, packet, cb) {\n    that.updateOfflinePacket(client, messageId, packet, cb);\n  };\n\n  server.forwardRetained = function(pattern, client, done) {\n    that.lookupRetained(pattern, function(err, matches) {\n      if (err) {\n        client.connection.emit(\"error\", err);\n        return;\n      }\n      steed.each(matches, function(match, cb) {\n        client.forward(match.topic, match.payload, match, pattern, match.qos, cb);\n      }, done);\n    });\n  };\n\n  server.on(\"close\", function() {\n    that.close();\n  });\n\n  server.restoreClientSubscriptions = function restoreClientSubscriptions(client, done) {\n    that.lookupSubscriptions(client, function(err, subscriptions) {\n      if (err) {\n        client.connection.emit(\"error\", err);\n        return;\n      }\n\n      var subs = Object.keys(subscriptions);\n\n      steed.each(subs, function(topic, inCb) {\n        client.logger.debug({ topic: topic, qos: subscriptions[topic].qos }, \"restoring subscription\");\n        client.handleAuthorizeSubscribe(\n          null, true, {\n          topic: topic,\n          qos: subscriptions[topic].qos\n        }, inCb);\n      }, function(){done(subs.length === 0 ? false : true);});\n    });\n  };\n\n  server.forwardOfflinePackets = function(client, done) {\n    // do not waste cpu time find in stored packets...\n    // if client is clean lookupSubscriptions already delete stored packets\n    if(client.clean)\n      return done && done();\n\n    that.streamOfflinePackets(client, function(err, packet) {\n      packet.offline = true;\n      client.logger.debug({ packet: packet }, \"Forwarding offline packet\");\n      client.forward(packet.topic, packet.payload, packet, packet.topic, packet.qos);\n    }, done);\n  };\n\n  server.persistClient = function(client, done) {\n    client.logger.debug(\"Storing offline subscriptions\");\n    that.storeSubscriptions(client, done);\n  };\n};\n\n/**\n * Close the persistance.\n *\n * @api public\n * @param {Function} done the callback\n */\nAbstractPersistence.prototype.close = function(done) {\n  if (done) {\n    done(new Error(\"not implemented yet\"));\n  }\n};\n\n/**\n * Export it as a module\n *\n * @api public\n */\nmodule.exports = AbstractPersistence;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/matcher.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar Qlobber = require(\"qlobber\").QlobberDedup;\nvar util = require(\"util\");\n\nfunction Matcher() {\n  Qlobber.call(this, { separator: \"/\", wildcard_one: \"+\" });\n}\n\nutil.inherits(Matcher, Qlobber);\n\nmodule.exports = Matcher;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/redis.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar AbstractPersistence = require(\"./abstract\");\nvar from = require(\"array-from\");\nvar Redis = require(\"ioredis\");\nvar util = require(\"util\");\nvar Matcher = require(\"./matcher\");\nvar steed = require(\"steed\")();\nvar extend = require(\"extend\");\nvar shortid = require(\"shortid\");\nvar defaults = {\n  channel: \"$SYS/moscaSync\",\n  ttl: {\n    // TTL for subscriptions is 1 hour\n    subscriptions: 60 * 60 * 1000,\n\n    // TTL for packets is 1 hour\n    packets: 60 * 60 * 1000\n  },\n  storeMessagesQos0: false\n};\n\n/**\n * A Redis-based persistance.\n *\n * The current options include:\n *  - `url`, the redis' url (encompasses port/host/db/password).\n *  - `port`, the Redis' port.\n *  - `host`, the Redis' host.\n *  - `db`, the Redis' database.\n *  - `password`, the Redis' password.\n *  - `redisOpts`, the options for the Redis client.\n *  - `channel`, the pub/sub channel that will be used to synchronize\n *    the various clients. Defaults to `'moscaSync'`.\n *  - `ttl`, an object containing three values:\n *    * `subscriptions`, the time (ms) after which subscriptions\n *      will expire. It defaults to 1 hour.\n *    * `packets`, the time (ms) after which packets will expire.\n *  - `storeMessagesQos0` store messages with qos 0, default false\n *     like mosquitto option 'queue_qos0_messages', non-standard option\n *\n * @api public\n * @param {Object} options The options to create this persistance\n * @param {Function} callback\n */\nfunction RedisPersistence(options, callback) {\n  if (!(this instanceof RedisPersistence)) {\n    return new RedisPersistence(options, callback);\n  }\n\n  this.options = extend(true, {}, defaults, options);\n\n  this._subMatcher = new Matcher();\n\n  this._client = this._buildClient();\n  this._pubSubClient = this._buildClient();\n  this._id = shortid.generate();\n\n  this._packetKeyTTL = this.options.ttl.packets;\n  this._listKeyTTL = this._packetKeyTTL * 2; // list key should live longer than packet key\n  this._closing = false;\n  this._closed = false;\n\n  var fetchAndUpdateLocalSub = function(key, unsubs, retried, cb) {\n    that._client.get(key, function(err, result) {\n      if (err) {\n        if (cb) {\n          cb(err);\n        } else {\n          return;\n        }\n      }\n\n      var subs = JSON.parse(result);\n      if (!result || typeof subs !== 'object') {\n        if (!retried) {\n          setTimeout(fetchAndUpdateLocalSub.bind(null, key, unsubs, true, cb), 500);\n        } else {\n          cb && cb();\n        }\n        return;\n      }\n\n      updateLocalSub(key, subs, unsubs);\n\n      if (cb) {\n        cb();\n      }\n    });\n  };\n\n  var updateLocalSub = function(key, subs, unsubs) {\n    var xs = key.split(\":\");\n    var id = key.substr(xs[0].length + xs[1].length + 2);\n\n    Object.keys(subs).forEach(function(sub) {\n      that._subMatcher.add(sub, id);\n    });\n\n    if( unsubs ) {\n      unsubs.forEach(function(unsub) {\n        that._subMatcher.remove(unsub, id);\n      });\n    }\n  };\n\n  var that = this;\n\n  this._pubSubClient.subscribe(this.options.channel, function(){\n    if (that._explicitlyClosed()) {\n      return;\n    }\n    var subsStream = that._client.scanStream({\n      match: \"client:sub:*\",\n      count: 25000\n    });\n    var pipeline = that._client.pipeline();\n    var total = 0;\n    var done = null;\n\n    subsStream.on('data', function(moreKeys){\n      total += moreKeys.length;\n      moreKeys.map(function(k){\n        pipeline.get(k, function(err, result) {\n          if (err) {\n            done && done(err);\n            return;\n          }\n          var subs = JSON.parse(result);\n          if (!result || typeof subs !== 'object') {\n            done && done();\n            return;\n          }\n          updateLocalSub(k, subs);\n          done && done();\n        });\n      });\n    });\n\n    subsStream.on('end', function(){\n      if (total === 0) {\n        return callback(null, that);\n      }\n      done = function() {\n        if (--total === 0 && callback) {\n          callback(null, that);\n          callback = null;\n        }\n      };\n      pipeline.exec();\n    });\n  });\n\n  this._pubSubClient.on(\"message\", function(channel, message) {\n    if (that._explicitlyClosed()) {\n      return;\n    }\n    var parsed = JSON.parse(message);\n    if (parsed.process !== that._id) {\n      updateLocalSub(parsed.key, parsed.subs, parsed.unsubs);\n    }\n  });\n}\n\nutil.inherits(RedisPersistence, AbstractPersistence);\n\n/**\n * Private methods, not inteded to be called from outside\n *\n * @api private\n */\n\nRedisPersistence.prototype._buildClient = function() {\n  var options = this.options.redisOptions || {};\n\n  if (this.options.url) {\n    options.url = this.options.url;\n  }\n  \n  if (this.options.host) {\n    options.host = this.options.host;\n  }\n\n  if (this.options.port) {\n    options.port = this.options.port;\n  }\n\n  if (this.options.db) {\n    options.db = this.options.db;\n  }\n\n  if (this.options.password) {\n    options.password = this.options.password;\n  }\n\n  return new Redis(options);\n};\n\nRedisPersistence.prototype.storeRetained = function(packet, cb) {\n  if (this._explicitlyClosed()) {\n    return cb && cb(new Error('Explicitly closed'));\n  }\n  if (packet.payload.length > 0) {\n    this._client.hset(\"retained\", packet.topic, JSON.stringify(packet), cb);\n  } else {\n    this._client.hdel(\"retained\", packet.topic, cb);\n  }\n};\n\nRedisPersistence.prototype.lookupRetained = function(pattern, done) {\n  if (this._explicitlyClosed()) {\n    return done && done(new Error('Explicitly closed'));\n  }\n  var that = this;\n  var matched = [];\n  var match = function(topic, cb) {\n    that._client.hget(\"retained\", topic, function(err, packet) {\n      if (packet) {\n\n        packet = JSON.parse(packet);\n        packet.payload = new Buffer(packet.payload);\n\n        matched.push(packet);\n      }\n\n      cb(err, matched);\n    });\n  };\n\n  if (pattern.indexOf(\"#\") >= 0 || pattern.indexOf(\"+\") >= 0) {\n    var matcher = new Matcher();\n    matcher.add(pattern, true);\n\n    this._client.hkeys(\"retained\", function(err, topics) {\n      topics.sort();\n      topics = topics.filter(function(topic) {\n        return matcher.match(topic).size > 0;\n      });\n\n      steed.each(topics, match, function(err) {\n        done(err, matched);\n      });\n    });\n\n    // do something\n  } else {\n    match(pattern, done);\n  }\n};\n\nRedisPersistence.prototype.storeSubscriptions = function(client, cb) {\n  if (this._explicitlyClosed()) {\n    return cb && cb(new Error('Explicitly closed'));\n  }\n  if (client.clean) {\n    return cb && cb();\n  }\n  var clientSubKey = \"client:sub:\" + client.id;\n  var that = this;\n  var subscriptions = {};\n\n  Object.keys(client.subscriptions).forEach(function(key) {\n    if (client.subscriptions[key].qos > 0) {\n      subscriptions[key] = client.subscriptions[key];\n    }\n  });\n\n  this._client.get(clientSubKey, function(err, currentSubs){\n    var unsubs;\n    if( !err && currentSubs ) {\n      currentSubs = JSON.parse(currentSubs);\n      unsubs = Object.keys(currentSubs).filter(function (topic) {\n        return !subscriptions[topic];\n      });\n      unsubs.forEach(function (topic) {\n        that._subMatcher.remove(topic, client.id);\n      });\n    }\n    var op = that._client.multi()\n      .set(clientSubKey, JSON.stringify(subscriptions))\n      .publish(that.options.channel, JSON.stringify({\n        key: clientSubKey,\n        subs: subscriptions,\n        unsubs: unsubs,\n        process: that._id\n      }))\n      .pexpire(clientSubKey, that.options.ttl.subscriptions);\n\n    Object.keys(subscriptions).forEach(function(e) {\n      that._subMatcher.add(e, client.id);\n    });\n\n    op.exec(cb);\n  });\n};\n\nRedisPersistence.prototype._cleanClient = function(client, done) {\n  var that = this;\n\n  var key = \"client:sub:\" + client.id;\n\n  this._client.get(key, function(err, subs) {\n    subs = JSON.parse(subs) || {};\n\n    Object.keys(subs).forEach(function(sub) {\n      that._subMatcher.remove(sub, client.id);\n    });\n\n    steed.parallel([\n      function(cb) {\n        that._client.del(key, cb);\n      },\n      function(cb) {\n        that._client.del(\"packets:\" + client.id, cb);\n      }\n    ], function(err) {\n      if (done) {\n        done(err, {});\n      }\n    });\n  });\n};\n\nRedisPersistence.prototype.lookupSubscriptions = function(client, cb) {\n  if (this._explicitlyClosed()) {\n    return cb && cb(new Error('Explicitly closed'));\n  }\n\n  if (client.clean) {\n    this._cleanClient(client, cb);\n  }else{\n    var key = \"client:sub:\" + client.id;\n    var subscriptions;\n\n    var multi = this._client.multi();\n\n    multi.get(key);\n\n    multi.exec(function(err, result) {\n      subscriptions = JSON.parse(result[0][1]) || {};\n      cb(err, subscriptions);\n    });\n  }\n};\n\nRedisPersistence.prototype.storeOfflinePacket = function(packet, done) {\n  if (this._explicitlyClosed()) {\n    return done && done(new Error('Explicitly closed'));\n  }\n\n  var that = this;\n\n  var matches = this._subMatcher.match(packet.topic);\n  var pipeline = this._client.pipeline();\n  steed.each(from(matches), function(client, cb) {\n    that._storePacket(client, packet, pipeline, cb);\n  }, function(){\n    pipeline.exec(done);\n  });\n};\n\nRedisPersistence.prototype._storePacket = function(client, packet, pipeline, cb) {\n  if (this._explicitlyClosed()) {\n    return cb && cb(new Error('Explicitly closed'));\n  }\n\n  var packetKey = \"packets:\" + client + \":\" + packet.messageId,\n      listKey = \"packets:\" + client;\n\n  pipeline.multi()\n    .set(packetKey, JSON.stringify(packet))\n    .pexpire(packetKey, this._packetKeyTTL)\n    .rpush(listKey, packetKey)\n    .pexpire(listKey, this._listKeyTTL)\n    .exec();\n\n  cb();\n};\n\nvar keyRegexp = /^([^:]+):(.+):([^:]+)$/;\nRedisPersistence.prototype.streamOfflinePackets = function(client, cb, done) {\n  if (this._explicitlyClosed()) {\n    return cb && cb(new Error('Explicitly closed'));\n  }\n\n  var that = this,\n      listKey = \"packets:\" + client.id;\n\n  that._client.lrange(listKey, 0, 10000, function(err, results) {\n\n    var total = results.length;\n\n    // for testing\n    if(done && total === 0)\n      done();\n\n    function emit(key, result) {\n      if (result) {\n        var match = key.match(keyRegexp);\n        result = JSON.parse(result);\n        result.payload = new Buffer(result.payload);\n        result.messageId = match[3];\n\n        cb(null, result);\n      }\n    }\n\n    function fetch(multi, key) {\n      return multi.get(key);\n    }\n\n    results.reduce(fetch, that._client.multi()).exec(function(err,multiResults){\n      if(!multiResults && done) {\n        done(err);\n        return;\n      }\n      multiResults.forEach(function(multiResult, i){\n        var key = results[i];\n        var result = multiResult[1];\n        total --;\n        // If we don't get result for given packet key. It means\n        // that packet has expired. Just clean it from client packets key\n        if(!result) {\n          that._client.lrem(listKey, 0, key);\n          // for testing\n          if(done && total === 0)\n            done();\n          return;\n        }\n        emit(key, result);\n      });\n    });\n  });\n};\n\nRedisPersistence.prototype.deleteOfflinePacket = function(client, messageId, done) {\n  if (this._explicitlyClosed()) {\n    return done && done(new Error('Explicitly closed'));\n  }\n\n  var that = this;\n  var packetKey = \"packets:\" + client.id + \":\" + messageId;\n\n  this._client.multi()\n    .del(packetKey)\n    .lrem(\"packets:\" + client.id, 1, packetKey)\n    .exec(done);\n};\n\nRedisPersistence.prototype.updateOfflinePacket = function(client, messageId, packet, done) {\n  if (this._explicitlyClosed()) {\n    return done && done(new Error('Explicitly closed'));\n  }\n\n  var that = this;\n  var oldPacketKey = \"packets:\" + client.id + \":\" + messageId;\n  var newPacketKey = \"packets:\" + client.id + \":\" + packet.messageId;\n  var listKey = \"packets:\" + client.id;\n\n  that._client.multi()\n      .rename(oldPacketKey, newPacketKey)\n      .lrem(listKey, 1, oldPacketKey)\n      .rpush(listKey, newPacketKey)\n      .pexpire(listKey, this._listKeyTTL)\n      .exec(function(err) {\n        done(err, packet);\n      });\n};\n\nRedisPersistence.prototype.close = function(done) {\n  if (this._closed) {\n    return done && done();\n  }\n  if (this._closing) {\n    return done && this.once('close', done);\n  }\n  this._closing = true;\n\n  var that = this;\n\n  steed.each([\n    \"_client\", \"_pubSubClient\"\n  ], function(client, cb) {\n    if (that[client]) {\n      that[client].quit(function quit(err) {\n        delete that[client];\n        cb(err);\n      });\n    } else {\n      cb();\n    }\n  }, function() {\n    that._closed = true;\n    that.emit('close');\n    done();\n  });\n};\n\n/**\n * Is the client explicitly being closed or already closed\n *\n * @api private\n */\nRedisPersistence.prototype._explicitlyClosed = function(done) {\n  return this._closing || this._closed;\n};\n\n/**\n * Export it as a module\n *\n * @api public\n */\nmodule.exports = RedisPersistence;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/mongo.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar AbstractPersistence = require(\"./abstract\");\nvar mongo = require('mongodb');\nvar MongoClient = mongo.MongoClient;\nvar util = require(\"util\");\nvar steed = require(\"steed\")();\nvar Matcher = require(\"./matcher\");\nvar topicPatterns = require(\"./utils\").topicPatterns;\nvar extend = require(\"extend\");\nvar defaults = {\n  ttl: {\n    // TTL for subscriptions is 1 hour\n    subscriptions: 60 * 60 * 1000,\n\n    // TTL for packets is 1 hour\n    packets: 60* 60 * 1000,\n\n  },\n  mongo: {},\n  storeMessagesQos0: false\n};\n\n/**\n * A persistance based on MongoDB.\n * It currently performs in save mode.\n *\n * The current options include:\n *  - `url`, the connection URL of the database\n *  - `ttl`, an object containing three values:\n *    * `subscriptions`, the time (ms) after which subscriptions\n *      will expire. It defaults to 1 hour.\n *    * `packets`, the time (ms) after which packets will expire.\n *      It defaults to 1 hour.\n *  - `mongo`, all the options for the MongoDB driver.\n *  - `connection`, a MongoDB client to be reused\n *  - `storeMessagesQos0` store messages with qos 0, default false\n *     like mosquitto option 'queue_qos0_messages', non-standard option\n *\n * @api public\n * @param {Object} options The options, as describe above.\n * @param {Function} done The callback that will be called\n *                        when the persistance is ready\n */\nfunction MongoPersistence(options, done) {\n  if (!(this instanceof MongoPersistence)) {\n    return new MongoPersistence(options, done);\n  }\n\n\n  this.options = extend(true, {}, defaults, options);\n  this.options.mongo.safe = true;\n\n  // This offlineMessageTimeout(in milliseconds) can set the maximum life time for stored offline messages. This is a\n  // Mongo-only feature which relies on TTL index. Since Mongo checks expired entries on a minute-based clock, the\n  // actual lifetime is ceil(offlineMessageTimeout/60000) minutes. For this reason, we do not have an unit test\n  // for this feature.\n  if (options.offlineMessageTimeout) {\n    this.options.ttl.packets = options.offlineMessageTimeout;\n  }\n\n  var that = this;\n\n  var connected = function(err, db) {\n    if (err) {\n      if (done) {\n        return done(err);\n      }\n      // we have no way of providing an error handler\n      throw err;\n    }\n\n    that.db = db;\n    steed.parallel([\n      function(cb) {\n        db.collection(\"subscriptions\", function(err, coll) {\n          that._subscriptions = coll;\n          steed.parallel([\n            that._subscriptions.ensureIndex.bind(that._subscriptions, \"client\"),\n            that._subscriptions.ensureIndex.bind(that._subscriptions, { \"added\": 1 }, { expireAfterSeconds: Math.round(that.options.ttl.subscriptions / 1000 )} )\n          ], cb);\n        });\n      },\n      function(cb) {\n        db.collection(\"packets\", function(err, coll) {\n          if (err) {\n            return cb(err);\n          }\n\n          that._packets = coll;\n          steed.series([\n            that._packets.ensureIndex.bind(that._packets, \"client\"),\n            function(cb){\n              // Check expiration indexes. If not exist, create; If exist but with different TTL, delete and recreate; Otherwise, do nothing.\n              that._packets.indexes(function(error, colIndexes){\n                if (error) {\n                  cb(error);\n                } else {\n                  var addedIndexKey = {\"added\": 1};\n                  var addedIndexKeyString = 'added_1'; // If addedIndex changes, this value should also be changed accordingly.\n                  var addedIndexObj = colIndexes.filter(function(obj){\n                    return obj.name == addedIndexKeyString;\n                  });\n                  var packetTTLInSeconds = Math.round(that.options.ttl.packets / 1000);\n                  if (addedIndexObj.length <= 0 || addedIndexObj[0].expireAfterSeconds != packetTTLInSeconds) {\n                    if (addedIndexObj.length > 0) {\n                      // Different index TTL, recreate index to make sure the TTL is set to the new number.\n                      that._packets.dropIndex(addedIndexKeyString, function (error, result){\n                        if (error) {\n                          cb(error);\n                        } else {\n                          that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);\n                        }\n                      });\n                    } else {\n                      // Create Index for the first time.\n                      that._packets.createIndex(addedIndexKey, {expireAfterSeconds: packetTTLInSeconds}, cb);\n                    }\n                  } else {\n                    cb(null);\n                  }\n                }\n              });\n            }\n          ], cb);\n        });\n      },\n      function(cb) {\n        db.collection(\"retained\", function(err, coll) {\n          that._retained = coll;\n          that._retained.ensureIndex(\"topic\", { unique: true }, cb);\n        });\n      }\n    ], function(err) {\n      if (done) {\n        done(err, that);\n      }\n    });\n  };\n\n  // Connect to the db\n  if (options.connection) {\n    connected(null, this.options.connection);\n  } else {\n    MongoClient.connect(this.options.url, this.options.mongo, connected);\n  }\n}\n\nutil.inherits(MongoPersistence, AbstractPersistence);\n\n/**\n * Private methods, not inteded to be called from outside\n *\n * @api private\n */\nMongoPersistence.prototype.storeSubscriptions = function(client, done) {\n\n  var subscriptions;\n  var that = this;\n\n  if (!client.clean) {\n    subscriptions = Object.keys(client.subscriptions).filter(function(key) {\n      return client.subscriptions[key].qos > 0;\n    });\n\n    steed.each(subscriptions, function(key, cb) {\n      that._subscriptions.findAndModify({\n        client: client.id,\n        topic: key\n      }, [['date', -1]], {\n        $set: {\n          client: client.id,\n          topic: key,\n          qos: client.subscriptions[key].qos,\n          added: new Date()\n        }\n      }, { upsert: true}, cb);\n    }, done);\n  } else if (done) {\n    return done();\n  }\n};\n\nMongoPersistence.prototype.lookupSubscriptions = function(client, done) {\n  var that = this;\n  this._subscriptions.find({ client: client.id })\n                     .toArray(function(err, subscriptions) {\n\n    var now = Date.now();\n\n    subscriptions = (subscriptions || []).reduce(function(obj, sub) {\n      // mongodb TTL is not precise\n      if (sub.added.getTime() + that.options.ttl.subscriptions > now) {\n        obj[sub.topic] = {\n          qos: sub.qos\n        };\n      }\n      return obj;\n    }, {});\n\n    if (!client.clean) {\n      done(err, subscriptions);\n      return;\n    }\n\n    var toExecute = [\n      function removeSubscriptions(cb) {\n        that._subscriptions.remove({ client: client.id }, cb);\n      },\n      function removePackets(cb) {\n        that._packets.remove({ client: client.id }, cb);\n      }\n    ];\n\n    steed.parallel(toExecute, function(err) {\n      done(null, {});\n    });\n  });\n};\n\nMongoPersistence.prototype.storeRetained = function(packet, cb) {\n  if (packet.payload.length > 0) {\n    this._retained.update(\n      { topic: packet.topic },\n      packet,\n      {\n        upsert: true,\n        w: 1\n      },\n      function(err, n, result){\n        if(cb) {\n          return cb(err);\n        }\n      });\n  } else {\n    this._retained.remove(\n      { topic: packet.topic },\n      { w: 1 },\n      cb);\n  }\n};\n\nMongoPersistence.prototype.lookupRetained = function(pattern, cb) {\n  var regexp = new RegExp(pattern.replace(/(#|\\+)/, \".+\").replace('\\\\', '\\\\\\\\'));\n  var stream = this._retained.find({ topic: { $regex: regexp } }).stream();\n  var matched = [];\n  var matcher = new Matcher();\n  matcher.add(pattern, true);\n\n  stream.on(\"error\", cb);\n\n  stream.on(\"end\", function() {\n    cb(null, matched);\n  });\n\n  stream.on(\"data\", function(data) {\n    if (matcher.match(data.topic).size > 0) {\n      data.payload = data.payload.buffer;\n      matched.push(data);\n    }\n  });\n};\n\nMongoPersistence.prototype.storeOfflinePacket = function(packet, done) {\n\n  var patterns = topicPatterns(packet.topic);\n\n  var stream = this._subscriptions.find({ topic: { $in: patterns } }).stream();\n  var ended = false;\n  var completed = 0;\n  var started = 0;\n  var that = this;\n\n  if (done) {\n    stream.on(\"error\", done);\n  }\n\n  stream.on(\"data\", function(data) {\n    started++;\n\n    that._storePacket(data.client, packet, function(err) {\n      if (err) {\n        return stream.emit(\"error\", err);\n      }\n\n      // TODO handle the err in case of no callback\n      completed++;\n\n      if (done && ended && started === completed) {\n        done();\n      }\n    });\n  });\n\n  stream.on(\"end\", function() {\n    ended = true;\n    if (done && started === completed) {\n      done();\n    }\n  });\n};\n\nMongoPersistence.prototype._storePacket = function(client, packet, cb) {\n  var toStore = {\n    client: client,\n    packet: packet,\n    added: new Date()\n  };\n\n  this._packets.insert(toStore, {w:1}, cb);\n};\n\nMongoPersistence.prototype.streamOfflinePackets = function(client, cb, done) {\n \n  var stream = this._packets.find({ client: client.id }).stream();\n  var that = this;\n\n  var now = Date.now();\n\n  // for testing\n  if(done)\n    stream.on(\"end\", done);\n\n  stream.on(\"error\", cb);\n\n  stream.on(\"data\", function(data) {\n    // mongodb TTL is not precise\n    // mongodb automaticly remove the packet\n    if (data.added.getTime() + that.options.ttl.packets > now) {\n      data.packet.payload = data.packet.payload.buffer;\n      cb(null, data.packet);\n    }\n  });\n\n};\n\nMongoPersistence.prototype.deleteOfflinePacket = function(client, messageId, cb) {\n  var toSearch = {\n    client: client.id,\n    'packet.messageId': messageId\n  };\n\n  this._packets.remove(toSearch, {w:1}, cb);\n};\n\nMongoPersistence.prototype.updateOfflinePacket = function(client, messageId, packet, cb) {\n  this._packets.update({\n    client: client.id,\n    'packet.messageId': messageId\n  }, {\n    $set: { 'packet.messageId': packet.messageId }\n  }, {w:1}, function(err) {\n    cb(err, packet);\n  });\n};\n\nMongoPersistence.prototype.close = function(cb) {\n  if (this.db && this.options.autoClose !== false) {\n    this.db.close(cb);\n  } else {\n    cb();\n  }\n};\n\n/**\n * Export it as a module\n *\n * @api public\n */\nmodule.exports = MongoPersistence;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/persistence/utils.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar LRU = require(\"lru-cache\");\nvar cache = LRU({\n  max: 10000,  \n  maxAge: 1000 * 60 * 60\n});\n\n/**\n * Generate the possible patterns that might match a topic.\n *\n * @param {String} the topic\n * @return the list of the patterns\n */\nfunction _topicPatterns(topic) {\n  var parts = topic.split(\"/\");\n  var patterns = [topic];\n  var i, a = [], b = [], j, k, h, list = [];\n\n  for (j=1; j < parts.length; j++) {\n    list.length = 0; // clear the array\n\n    for (i=0; i < parts.length; i++) {\n      a.length = 0;\n      b.length = 0;\n\n      list.push(i);\n      for (h = 1; list.length < j; h++) {\n        list.unshift(parts.length - h);\n      }\n\n      for (k=0; k < parts.length; k++) {\n        if (list.indexOf(k) >= 0) {\n          a.push(parts[k]);\n          b.push(parts[k]);\n        } else {\n          if (k === 0 || a[a.length - 1] !== \"#\") {\n            a.push(\"#\");\n          }\n          b.push(\"+\");\n        }\n      }\n\n      patterns.push(a.join(\"/\"));\n      patterns.push(b.join(\"/\"));\n      list.shift();\n    }\n  }\n\n  return patterns;\n}\n\n/**\n * Generate the possible patterns that might match a topic.\n * Memozied version.\n *\n * @param {String} the topic\n * @return the list of the patterns\n */\nfunction topicPatterns(topic) {\n  var result = cache.get(topic);\n  if (!result) {\n    result = _topicPatterns(topic);\n  }\n  cache.set(topic, result);\n  return result;\n}\n\n\nmodule.exports.topicPatterns = topicPatterns;\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/options.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar pino = require(\"pino\");\nvar extend = require(\"extend\");\nvar clone = require(\"clone\");\nvar jsonschema = require(\"jsonschema\");\nvar serializers = require(\"./serializers\");\n\nmodule.exports = {\n  modernize: modernize,\n  validate: validate,\n  populate: populate,\n\n  defaultsModern: defaultsModern,\n  defaultsLegacy: defaultsLegacy,\n};\n\n\n/**\n * Modernize options.\n * This function does not populate missing fields with defaults.\n *\n * @api private\n * @param  {Object} options Legacy options\n * @return {Object}         Modernized options\n */\nfunction modernize(legacy) {\n\n  legacy = legacy || {};\n\n  var modernized = {};\n\n  // \"plain copyable\" conserved options\n  var conserved = [\n    \"id\",\n    \"host\",\n    \"maxInflightMessages\",\n    \"stats\",\n    \"publishNewClient\",\n    \"publishClientDisconnect\",\n    \"publishSubscriptions\"\n  ];\n\n  // copy all conserved options\n  conserved.forEach(function (name) {\n    if (legacy.hasOwnProperty(name)) {\n      modernized[name] = legacy[name];\n    }\n  });\n\n  // TODO: copy `backend` carefully\n  if (legacy.hasOwnProperty('backend')) {\n    modernized.backend = legacy.backend;\n  }\n\n  // TODO: copy `ascoltatore` carefully\n  if (legacy.hasOwnProperty('ascoltatore')) {\n    modernized.ascoltatore = legacy.ascoltatore;\n  }\n\n  // TODO: copy `persistence` carefully\n  if (legacy.hasOwnProperty('persistence')) {\n    modernized.persistence = legacy.persistence;\n  }\n\n  // TODO: copy `logger` carefully\n  if (legacy.hasOwnProperty('logger')) {\n    modernized.logger = legacy.logger;\n  }\n\n  // construct `credentials`\n  if (legacy.hasOwnProperty('credentials')) {\n    // copy as is\n    modernized.credentials = clone(legacy.credentials);\n  } else if (legacy.hasOwnProperty('secure')) {\n    // construct from `secure`\n    modernized.credentials = {};\n    if (legacy.secure.hasOwnProperty('keyPath')) {\n      modernized.credentials.keyPath = legacy.secure.keyPath;\n    }\n    if (legacy.secure.hasOwnProperty('certPath')) {\n      modernized.credentials.certPath = legacy.secure.certPath;\n    }\n  } // else no credentials were provided\n\n  // construct `interfaces`\n  if (legacy.hasOwnProperty('interfaces')) {\n    // cloning\n    modernized.interfaces = clone(legacy.interfaces);\n  } else {\n    // construct from legacy keys\n    modernized.interfaces = [];\n\n    // translate mqtt options\n    var mqtt_enabled = !legacy.onlyHttp && (typeof legacy.secure === 'undefined' || legacy.allowNonSecure);\n    if (mqtt_enabled) {\n      var mqtt_interface = { type: 'mqtt' };\n\n      if (legacy.hasOwnProperty('port')) {\n        mqtt_interface.port = legacy.port;\n      }\n\n      if (legacy.hasOwnProperty('maxConnections')) {\n        mqtt_interface.maxConnections = legacy.maxConnections;\n      }\n\n      modernized.interfaces.push(mqtt_interface);\n    }\n\n    // translate mqtts options\n    var mqtts_enabled = !legacy.onlyHttp && legacy.secure;\n    if (mqtts_enabled) {\n      var mqtts_interface = { type: 'mqtts' };\n\n      if (legacy.secure.hasOwnProperty('port')) {\n        mqtts_interface.port = legacy.secure.port;\n      }\n\n      modernized.interfaces.push(mqtts_interface);\n    }\n\n    // translate http options\n    var http_enabled = !!(legacy.http);\n    if (http_enabled) {\n      var http_interface = { type: 'http' };\n\n      if (legacy.http.hasOwnProperty('port')) {\n        http_interface.port = legacy.http.port;\n      }\n\n      if (legacy.http.hasOwnProperty('bundle')) {\n        http_interface.bundle = legacy.http.bundle;\n      }\n\n      if (legacy.http.hasOwnProperty('static')) {\n        http_interface.static = legacy.http.static;\n      }\n\n      modernized.interfaces.push(http_interface);\n    }\n\n    // translate https options\n    var https_enabled = !!(legacy.https);\n    if (https_enabled) {\n      var https_interface = { type: 'https' };\n\n      if (legacy.https.hasOwnProperty('port')) {\n        https_interface.port = legacy.https.port;\n      }\n\n      if (legacy.https.hasOwnProperty('bundle')) {\n        https_interface.bundle = legacy.https.bundle;\n      }\n\n      if (legacy.https.hasOwnProperty('static')) {\n        https_interface.static = legacy.https.static;\n      }\n\n      modernized.interfaces.push(https_interface);\n    }\n\n    // NOTE: there are ways end up with no interfaces at all, for example\n    // `httpOnly: true` with undefined http and https\n  }\n\n  return modernized;\n}\n\n\n/**\n * Validate modern options.\n *\n * @api private\n * @param  {Object} options             Modern options\n * @return {jsonschema.ValidatorResult} Result of validation\n */\nfunction validate(opts, validationOptions) {\n  var validator = new jsonschema.Validator();\n\n  // custom function type\n  validator.types.function = function testFunction(instance) {\n    return instance instanceof Function;\n  };\n\n  validator.addSchema({\n    id: '/Credentials',\n    type: 'object',\n    additionalProperties: true,\n    properties: {\n      'keyPath': { type: 'string', required: true },\n      'certPath': { type: 'string', required: true },\n      'caPaths': { type: 'array', required: false },\n      'requestCert': { type: 'boolean', required: false },\n      'rejectUnauthorized': { type: 'boolean', required: false }\n    }\n  });\n\n  validator.addSchema({\n    id: '/Interface',\n    type: 'object',\n    properties: {\n      'type': { type: ['string', 'function'], required: true },\n      'host': { type: ['string', 'null'] },\n      'port': { type: ['integer'] },\n      'credentials': { $ref: '/Credentials' },\n    }\n  });\n\n  validator.addSchema({\n    id: '/Options',\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n      'id': { type: 'string' },\n      'host': { type: ['string', 'null'] },\n      'interfaces': {\n        type: 'array',\n        items: { $ref: '/Interface' }\n      },\n      'credentials': { $ref: '/Credentials' },\n\n      'backend': { type: 'object' },     // TODO\n      'ascoltatore': { type: 'object' }, // TODO\n      'persistence': { type: 'object' }, // TODO\n      'logger': { type: 'object' },      // TODO\n\n      'maxInflightMessages': { type: 'integer' },\n      'stats': { type: 'boolean' },\n      'publishNewClient': { type: 'boolean' },\n      'publishClientDisconnect': { type: 'boolean' },\n      'publishSubscriptions': { type: 'boolean' }\n    }\n  });\n\n  var result = validator.validate(opts, '/Options', validationOptions);\n\n  // check required credentials\n  if (opts.hasOwnProperty('interfaces')) {\n    var hasCredentials = opts.hasOwnProperty('credentials');\n    var reqCredentials = opts.interfaces.some(function (iface) {\n      var req = (iface.type === 'mqtts' || iface.type === 'https');\n      var has = iface.hasOwnProperty('credentials');\n      return req && !has;\n    });\n\n    if (reqCredentials && !hasCredentials) {\n      result.addError('one of the defiend interfaces requires credentials');\n    }\n  }\n\n  // TODO: check conflicting backend and ascoltatore\n\n  return result;\n}\n\n\n/**\n * Populate missing fields in modern options.\n *\n * @api private\n * @param  {Object} options Modern options\n * @return {Object}         Populated options\n */\nfunction populate(opts) {\n  var defaults = defaultsModern();\n\n  // do not extend `interfaces`\n  if (opts.hasOwnProperty('interfaces')) {\n    delete defaults.interfaces;\n  }\n  var populated = extend(true, defaults, opts);\n\n  populated.interfaces.forEach(function (iface) {\n    if (typeof iface.port === \"undefined\") {\n      switch (iface.type) {\n        case \"mqtt\":   iface.port = 1883; break;\n        case \"mqtts\":  iface.port = 8883; break;\n        case \"http\":   iface.port = 3000; break;\n        case \"https\":  iface.port = 3001; break;\n      }\n    }\n  });\n\n  return populated;\n}\n\n\n/**\n * Construct legacy default options.\n *\n * @api private\n * @return {Object}  Legacy options\n */\nfunction defaultsLegacy() {\n  return {\n    port: 1883,\n    host: null,\n    maxConnections: 10000000,\n    backend: {\n      json: false,\n      wildcardOne: '+',\n      wildcardSome: '#'\n    },\n    stats: false,\n    publishNewClient: true,\n    publishClientDisconnect: true,\n    publishSubscriptions: true,\n    maxInflightMessages: 1024,\n    logger: {\n      name: \"mosca\",\n      level: \"warn\",\n      serializers: {\n        client: serializers.clientSerializer,\n        packet: serializers.packetSerializer,\n        req: pino.stdSerializers.req,\n        res: pino.stdSerializers.res\n      }\n    }\n  };\n}\n\n\n/**\n * Construct modern default options.\n *\n * @api private\n * @return {Object}  Modern options\n */\nfunction defaultsModern() {\n  return {\n    host: null,\n    interfaces: [\n      { type: \"mqtt\", port: 1883, maxConnections: 10000000 }\n    ],\n    backend: {\n      json: false,\n      wildcardOne: '+',\n      wildcardSome: '#'\n    },\n    stats: false,\n    publishNewClient: true,\n    publishClientDisconnect: true,\n    publishSubscriptions: true,\n    maxInflightMessages: 1024,\n    logger: {\n      name: \"mosca\",\n      level: \"warn\",\n      serializers: {\n        client: serializers.clientSerializer,\n        packet: serializers.packetSerializer,\n        req: pino.stdSerializers.req,\n        res: pino.stdSerializers.res\n      }\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/serializers.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nmodule.exports = {\n  clientSerializer: clientSerializer,\n  packetSerializer: packetSerializer\n};\n\n/**\n * Serializises a client for Bunyan.\n *\n * @api private\n */\nfunction clientSerializer(client) {\n  return client.id;\n}\n\n/**\n * Serializises a packet for Bunyan.\n *\n * @api private\n */\nfunction packetSerializer(packet) {\n  var result = {};\n\n  if (packet.messageId) {\n    result.messageId = packet.messageId;\n  }\n\n  if (packet.topic) {\n    result.topic = packet.topic;\n  }\n\n  if (packet.qos) {\n    result.qos = packet.qos;\n  }\n\n  if (packet.unsubscriptions) {\n    result.unsubscriptions = packet.unsubscriptions;\n  }\n\n  if (packet.subscriptions) {\n    result.subscriptions = packet.subscriptions;\n  }\n\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/interfaces.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar fs = require(\"fs\");\nvar Connection = require(\"mqtt-connection\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar net =  require(\"net\");\nvar tls = require(\"tls\");\nvar st = require(\"st\");\n\nvar Client = require(\"./client\");\n\nmodule.exports = {\n  serverFactory: serverFactory,\n\n  mqttFactory: mqttFactory,\n  mqttsFactory: mqttsFactory,\n  httpFactory: httpFactory,\n  httpsFactory: httpsFactory,\n\n  buildWrap: buildWrap,\n  buildServe: buildServe,\n};\n\n/**\n * Build internal server for the interface.\n * \n * @api private\n * @param  {Object} iface       Interface description\n * @param  {Object} fallback    Fallback values\n * @param  {mosca.Server} mosca Target mosca server\n * @return {any.Server}         Built server\n */\nfunction serverFactory(iface, fallback, mosca) {\n  var factories = {\n    \"mqtt\":  mqttFactory,\n    \"mqtts\": mqttsFactory,\n    \"http\":  httpFactory,\n    \"https\": httpsFactory,\n  };\n\n  var type = iface.type; // no fallback\n  var factory = factories[type] || type;\n  return factory(iface, fallback, mosca);\n}\n\nfunction mqttFactory(iface, fallback, mosca) {\n  return net.createServer(buildWrap(mosca));\n}\n\nfunction mqttsFactory(iface, fallback, mosca) {\n  var credentials = iface.credentials || fallback.credentials;\n  if (credentials === undefined) {\n    throw new Error(\"missing credentials for mqtts server\");\n  }\n\n  if (credentials.keyPath) {\n    credentials.key = fs.readFileSync(credentials.keyPath);\n  }\n\n  if (credentials.certPath) {\n    credentials.cert = fs.readFileSync(credentials.certPath);\n  }\n\n  if (credentials.caPaths) {\n    credentials.ca = [];\n    credentials.caPaths.forEach(function (caPath) {\n    \tcredentials.ca.push(fs.readFileSync(caPath));\n    });\n  }\n\n  return tls.createServer(credentials, buildWrap(mosca));\n}\n\nfunction httpFactory(iface, fallback, mosca) {\n  var serve = buildServe(iface, mosca);\n  var server = http.createServer(serve);\n\n  mosca.attachHttpServer(server);\n  return server;\n}\n\nfunction httpsFactory(iface, fallback, mosca) {\n  var credentials = iface.credentials || fallback.credentials;\n  if (credentials === undefined) {\n    throw new Error(\"missing credentials for https server\");\n  }\n\n  if (credentials.keyPath) {\n    credentials.key = fs.readFileSync(credentials.keyPath);\n  }\n\n  if (credentials.certPath) {\n    credentials.cert = fs.readFileSync(credentials.certPath);\n  }\n\n  if (credentials.caPaths) {\n    credentials.ca = [];\n    credentials.caPaths.forEach(function (caPath) {\n    \tcredentials.ca.push(fs.readFileSync(caPath));\n    });\n  }\n\n  var serve = buildServe(iface, mosca);\n  var server = https.createServer(credentials, serve);\n  mosca.attachHttpServer(server);\n  return server;\n}\n\n\n/**\n * Create the wrapper for mqtt server to disable Nagle algorithm.\n * \n * @param  {Object}   iface Inrerface from `interfaces`\n * @return {Function}       Wrap function\n */\nfunction buildWrap(mosca) {\n  return function wrap(stream) {\n    var connection = new Connection(stream);\n    stream.setNoDelay(true);\n    new Client(connection, mosca); // REFACTOR?\n  };\n}\n\n/**\n * Create the serve logic for http server.\n * \n * @param  {Object}   iface Inrerface from `interfaces`\n * @return {Function}       Serve function\n */\nfunction buildServe(iface, mosca) {\n  var mounts = [];\n  var logger = mosca.logger.child({ service: 'http bundle' });\n\n  if (iface.bundle) {\n    mounts.push(st({\n      path: __dirname + \"/../public\",\n      url: \"/\",\n      dot: true,\n      index: false,\n      passthrough: true\n    }));\n  }\n\n  if (iface.static) {\n    mounts.push(st({\n      path: iface.static,\n      dot: true,\n      url: \"/\",\n      index: \"index.html\",\n      passthrough: true\n    }));\n  }\n\n  return function serve(req, res) {\n\n    logger.info({ req: req });\n\n    var cmounts = [].concat(mounts);\n\n    res.on('finish', function() {\n      logger.info({ res: res });\n    });\n\n    function handle() {\n      var mount = cmounts.shift();\n\n      if (mount) {\n        mount(req, res, handle);\n      } else {\n        res.statusCode = 404;\n        res.end(\"Not Found\\n\");\n      }\n    }\n\n    handle();\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-mosca/mosca/lib/authorizer.js":"/*\nCopyright (c) 2013-2016 Matteo Collina, http://matteocollina.com\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\"use strict\";\n\nvar hasher = require(\"pbkdf2-password\")();\nvar minimatch = require(\"minimatch\");\nvar defaultGlob = \"**\";\n\n/**\n * mosca.Authorizer's responsibility is to give an implementation\n * of mosca.Server callback of authorizations, against a JSON file.\n *\n * @param {Object} users The user hash, as created by this class\n *  (optional)\n * @api public\n */\nfunction Authorizer(users) {\n  this.users = users || {};\n}\nmodule.exports = Authorizer;\n\n/**\n * It returns the authenticate function to plug into mosca.Server.\n *\n * @api public\n */\nAuthorizer.prototype.__defineGetter__(\"authenticate\", function() {\n  var that = this;\n  return function(client, user, pass, cb) {\n    that._authenticate(client, user, pass, cb);\n  };\n});\n\n/**\n * It returns the authorizePublish function to plug into mosca.Server.\n *\n * @api public\n */\nAuthorizer.prototype.__defineGetter__(\"authorizePublish\", function() {\n  var that = this;\n  return function(client, topic, payload, cb) {\n    cb(null, minimatch(topic, that.users[client.user].authorizePublish || defaultGlob));\n  };\n});\n\n/**\n * It returns the authorizeSubscribe function to plug into mosca.Server.\n *\n * @api public\n */\nAuthorizer.prototype.__defineGetter__(\"authorizeSubscribe\", function() {\n  var that = this;\n  return function(client, topic, cb) {\n    cb(null, minimatch(topic, that.users[client.user].authorizeSubscribe || defaultGlob));\n  };\n});\n\n/**\n * The real authentication function\n *\n * @api private\n */\nAuthorizer.prototype._authenticate = function(client, user, pass, cb) {\n\n  var missingUser = !user || !pass || !this.users[user];\n\n  if (missingUser) {\n    cb(null, false);\n    return;\n  }\n\n  user = user.toString();\n\n  client.user = user;\n  user = this.users[user];\n\n  hasher({\n    password: pass.toString(),\n    salt: user.salt\n  }, function(err, pass, salt, hash) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    var success = (user.hash === hash);\n    cb(null, success);\n  });\n};\n\n/**\n * An utility function to add an user.\n *\n * @api public\n * @param {String} user The username\n * @param {String} pass The password\n * @param {String} authorizePublish The authorizePublish pattern\n *   (optional)\n * @param {String} authorizeSubscribe The authorizeSubscribe pattern\n *   (optional)\n * @param {Function} cb The callback that will be called after the\n *   insertion.\n */\nAuthorizer.prototype.addUser = function(user, pass, authorizePublish,\n                                        authorizeSubscribe, cb) {\n  var that = this;\n\n  if (typeof authorizePublish === \"function\") {\n    cb = authorizePublish;\n    authorizePublish = null;\n    authorizeSubscribe = null;\n  } else if (typeof authorizeSubscribe == \"function\") {\n    cb = authorizeSubscribe;\n    authorizeSubscribe = null;\n  }\n\n  if (!authorizePublish) {\n    authorizePublish = defaultGlob;\n  }\n\n  if (!authorizeSubscribe) {\n    authorizeSubscribe = defaultGlob;\n  }\n\n  hasher({\n    password: pass.toString()\n  }, function(err, pass, salt, hash) {\n    if (!err) {\n      that.users[user] = {\n        salt: salt,\n        hash: hash,\n        authorizePublish: authorizePublish,\n        authorizeSubscribe: authorizeSubscribe\n      };\n    }\n    cb(err);\n  });\n  return this;\n};\n\n\n/**\n * An utility function to delete a user.\n *\n * @api public\n * @param {String} user The username\n * @param {String} pass The password\n * @param {Function} cb The callback that will be called after the\n *   deletion.\n */\nAuthorizer.prototype.rmUser = function(user, cb) {\n  delete this.users[user];\n  cb();\n  return this;\n};\n"}